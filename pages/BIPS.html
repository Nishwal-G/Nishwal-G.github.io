<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>How do cells remember who they are? | DNA ‚Üí Chromatin ‚Üí BIPS</title>

  <style>
    :root{
      /* =======================
         Lecture-notes theme
         ======================= */
      --page: #fbf7ef;                 /* cream ‚Äúpaper‚Äù */
      --paper: #ffffff;                /* white cards */
      --ink: #1f2937;                  /* main text */
      --muted: #4b5563;                /* secondary text */
      --border: rgba(31,41,55,0.12);   /* soft border */

      /* Figure (animation) window stays dark */
      --figureBg: #0b0b10;
      --figureBorder: rgba(31,41,55,0.18);

      /* Accents (less neon, more academic) */
      --green: #059669;
      --red: #dc2626;
      --pink: #db2777;
      --purple: #7c3aed;

      --maxw: 1100px;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }

    body{
      margin:0;
      background: var(--page);
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    .page{
      min-height: 100vh;
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
    }

    /* TEXT AREA (SCROLL STORY) */
    .textPanel{
      width: min(var(--maxw), 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: var(--paper);
      box-shadow: 0 10px 30px rgba(17,24,39,0.10);
      overflow: hidden;
    }

    .textInner{ padding: 18px 18px 14px 18px; }

    .kickerRow{
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .kicker{
      font-weight: 900;
      letter-spacing: 0.25px;
      font-size: 12px;
      color: rgba(31,41,55,0.65);
      text-transform: uppercase;
      margin: 0;
    }

    .progressPill{
      border: 1px solid rgba(31,41,55,0.18);
      background: rgba(31,41,55,0.03);
      color: rgba(31,41,55,0.80);
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      user-select:none;
    }

    .sceneTitle{
      font-weight: 950;
      letter-spacing: -0.4px;
      font-size: clamp(22px, 2.3vw, 30px);
      margin: 0;
      line-height: 1.12;
      color: var(--ink);
    }

    .sceneSub{
      margin-top: 10px;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.65;
    }

    /* Story sections (scroll) */
    .story{
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .section{
      border: 1px solid rgba(31,41,55,0.10);
      border-radius: 16px;
      padding: 14px 14px 12px 14px;
      background: rgba(255,255,255,0.96);
    }
    .section.active{
      border-color: rgba(37,99,235,0.25);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.06);
    }

    .sectionHeader{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .sectionTag{
      font-weight: 950;
      font-size: 12px;
      letter-spacing: 0.18px;
      text-transform: uppercase;
      color: rgba(31,41,55,0.60);
    }
    .sectionTitle{
      font-weight: 950;
      letter-spacing: -0.2px;
      font-size: 18px;
      margin: 6px 0 0 0;
      color: rgba(31,41,55,0.94);
    }
    .sectionSub{
      margin-top: 6px;
      color: rgba(31,41,55,0.70);
      font-size: 14px;
      line-height: 1.6;
    }

    /* Learning goal callout */
    .learnGoal{
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(31,41,55,0.12);
      background: rgba(5,150,105,0.06);
      border-left: 4px solid rgba(5,150,105,0.75);
      border-radius: 12px;
      color: rgba(31,41,55,0.88);
      font-size: 14px;
      line-height: 1.55;
    }
    .learnGoal strong{
      color: rgba(5,150,105,0.95);
      font-weight: 950;
    }

    .storyText{
      margin-top: 10px;
      color: rgba(31,41,55,0.92);
      font-size: 16px;
      line-height: 1.78;
    }
    .storyText p{ margin: 12px 0 0 0; }
    .storyText ul{
      margin: 10px 0 0 18px;
      padding: 0;
    }
    .storyText li{ margin: 8px 0; }

    /* Big clickable glossary-like words */
    .bigClick{
      display:inline-block;
      padding: 4px 10px;
      margin: 0 2px;
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,0.16);
      background: rgba(31,41,55,0.04);
      font-weight: 950;
      letter-spacing: 0.2px;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(31,41,55,0.92);
      cursor: pointer;
      user-select:none;
      transform: translateY(-1px);
      white-space: nowrap;
    }
    .bigClick:hover{ background: rgba(31,41,55,0.07); }
    .bigClick.green{ border-color: rgba(5,150,105,0.28); color: var(--green); background: rgba(5,150,105,0.05); }
    .bigClick.purple{ border-color: rgba(124,58,237,0.24); color: var(--purple); background: rgba(124,58,237,0.05); }
    .bigClick.white{ border-color: rgba(31,41,55,0.18); color: rgba(31,41,55,0.92); }

    /* Tiny helper row */
    .helperRow{
      margin-top: 10px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .hintPill{
      border: 1px solid rgba(31,41,55,0.18);
      background: rgba(31,41,55,0.03);
      color: rgba(31,41,55,0.75);
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
    }

    .toTop{
      border: 1px solid rgba(31,41,55,0.18);
      background: rgba(255,255,255,0.92);
      color: rgba(31,41,55,0.92);
      padding: 9px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 950;
      font-size: 12px;
      user-select:none;
    }
    .toTop:hover{ background: rgba(31,41,55,0.04); }

    /* Act 2+3+4 mini buttons (Base pair / Gene / Locks) */
    .miniControls{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .miniPill{
      border: 1px solid rgba(31,41,55,0.18);
      background: rgba(31,41,55,0.04);
      color: rgba(31,41,55,0.92);
      padding: 9px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 950;
      font-size: 12px;
      letter-spacing: 0.2px;
      text-transform: uppercase;
      user-select:none;
      min-height: 40px;
    }
    .miniPill:hover{ background: rgba(31,41,55,0.07); }
    .miniPill.white{ border-color: rgba(31,41,55,0.18); }
    .miniPill.green{ border-color: rgba(5,150,105,0.28); color: var(--green); background: rgba(5,150,105,0.05); }
    .miniPill.purple{ border-color: rgba(124,58,237,0.24); color: var(--purple); background: rgba(124,58,237,0.05); }

    /* CANVAS PANEL (dark figure window) */
    .stage{
      width: min(var(--maxw), 100%);
      height: min(62vh, 720px);
      border: 1px solid var(--figureBorder);
      border-radius: 18px;
      overflow: hidden;
      background: var(--figureBg);
      position: sticky;
      top: 14px;
      box-shadow: 0 10px 30px rgba(17,24,39,0.12);
    }

    #stageCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
    }

    /* Act-image overlay (final act only) */
    .stageImage{
      position:absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
      padding: 14px;
      background: rgba(0,0,0,0.10);
    }
    .stageImage.show{ display:block; }

    .legend{
      position:absolute;
      left: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.80);
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;

      opacity: 0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .legend.show{ opacity: 1; transform: translateY(0); }

    .dot{
      display:inline-block;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .dot.white{ background: rgba(255,255,255,0.85); }
    .dot.green{ background: var(--green); }
    .dot.red{ background: var(--red); }
    .dot.pink{ background: var(--pink); }
    .dot.purple{ background: var(--purple); }

    .dragHint{
      position:absolute;
      right: 12px;
      top: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.82);
      font-size: 12px;
      pointer-events:none;

      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .dragHint.show{ opacity: 1; transform: translateY(0); }

    @media (max-width: 860px){
      .stage{ height: 52vh; position: relative; top: auto; }
      .textInner{ padding: 16px 14px 12px 14px; }
      .storyText{ font-size: 16px; }
    }

    /* ============================================================
       Letter / base-pair panel shown under canvas in DNA sections
       ============================================================ */
    .pairPanel{
      width: min(var(--maxw), 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: var(--paper);
      box-shadow: 0 10px 30px rgba(17,24,39,0.08);
      overflow: hidden;
      display: none; /* toggled by JS */
    }
    .pairInner{ padding: 12px 14px 14px 14px; }
    .pairTitleRow{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .pairTitle{
      font-weight: 950;
      letter-spacing: -0.2px;
      font-size: 14px;
      color: rgba(31,41,55,0.88);
    }
    .pairHint{
      font-size: 12px;
      color: rgba(31,41,55,0.62);
      font-weight: 850;
    }

    .pairStripWrap{
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 6px;
    }

    .pairStrip{
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 6px;
      border: 1px solid rgba(31,41,55,0.10);
      border-radius: 14px;
      background: rgba(31,41,55,0.03);
      min-height: 86px;
    }

    .bp{
      width: 34px;
      height: 70px;
      border-radius: 14px;
      border: 1px solid rgba(31,41,55,0.12);
      background: rgba(255,255,255,0.80);
      position: relative;
      display:flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select:none;
      flex: 0 0 auto;
    }

    .bp .top, .bp .bot{
      width: 100%;
      text-align: center;
      font-weight: 950;
      font-size: 18px;
      line-height: 1.0;
      letter-spacing: 0.4px;
      color: rgba(31,41,55,0.88);
    }
    .bp .bot{
      margin-top: 14px;
      color: rgba(31,41,55,0.72);
    }

    /* connector ‚Äúrung‚Äù */
    .bp::after{
      content:"";
      position:absolute;
      left: 50%;
      top: 29px;
      transform: translateX(-50%);
      width: 2px;
      height: 12px;
      border-radius: 99px;
      background: rgba(31,41,55,0.22);
    }

    /* Active single base-pair highlight */
    .bp.active{
      border-color: rgba(37,99,235,0.35);
      background: rgba(37,99,235,0.08);
      box-shadow: 0 0 0 2px rgba(37,99,235,0.06) inset;
    }
    .bp.active .top, .bp.active .bot{ color: rgba(37,99,235,0.95); }
    .bp.active::after{ background: rgba(37,99,235,0.80); }

    /* Gene region highlight */
    .bp.gene{
      border-color: rgba(5,150,105,0.35);
      background: rgba(5,150,105,0.08);
    }
    .bp.gene .top, .bp.gene .bot{ color: rgba(5,150,105,0.95); }
    .bp.gene::after{ background: rgba(5,150,105,0.75); }

    .pairChips{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,0.12);
      background: rgba(31,41,55,0.03);
      color: rgba(31,41,55,0.72);
      font-weight: 900;
      font-size: 12px;
      user-select:none;
    }
    .chip .swatch{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: rgba(37,99,235,0.75);
    }
    .chip.green .swatch{ background: rgba(5,150,105,0.80); }

  </style>
</head>

<body>
  <div class="page">
    <section class="textPanel" aria-label="Story (scroll)">
      <div class="textInner">
        <div class="kickerRow">
          <div class="kicker">Scroll the story ‚Äî the figure updates as you go</div>
          <div class="progressPill" id="progressPill">Section 1 / 8</div>
        </div>

        <h1 class="sceneTitle">How do cells remember who they are?</h1>

        <div class="sceneSub">
          Same DNA, different jobs. This story shows a simple idea:
          <strong>DNA is the book</strong>, but <strong>how it‚Äôs folded</strong> helps decide what gets read.
          <br>
          As you scroll, the animation on the right changes to match the section you‚Äôre reading.
        </div>

        <div class="helperRow">
          <div class="hintPill" id="activeHint">Tip: scroll slowly ‚Äî the figure will ‚Äúsnap‚Äù to each chapter.</div>
          <button class="toTop" id="toTopBtn" type="button">‚Üë Back to top</button>
        </div>

        <div class="story" id="story"></div>
      </div>
    </section>

    <section class="stage" aria-label="Figure (animation canvas)">
      <canvas id="stageCanvas"></canvas>

      <!-- final image -->
      <img id="stageImage" class="stageImage" alt="Summary image"/>

      <div class="dragHint" id="dragHint">Drag the big red ‚Äúreader‚Äù</div>

      <div class="legend" id="legend">
        <span class="dot white"></span> DNA (as a squiggly chain)
        <span class="dot green"></span> a gene spot
        <span class="dot red"></span> reader proteins
        <span class="dot pink"></span> busy hub
        <span class="dot purple"></span> hard-to-open DNA
      </div>
    </section>

    <!-- DNA letters panel -->
    <section class="pairPanel" id="pairPanel" aria-label="DNA letters and base-pairing">
      <div class="pairInner">
        <div class="pairTitleRow">
          <div class="pairTitle">DNA as letters (A, C, G, T) ‚Äî with matching pairs</div>
          <div class="pairHint">A‚ÜîT and C‚ÜîG</div>
        </div>

        <div class="pairStripWrap">
          <div class="pairStrip" id="pairStrip"></div>
        </div>

        <div class="pairChips" aria-hidden="true">
          <span class="chip"><span class="swatch"></span> one base pair</span>
          <span class="chip green"><span class="swatch"></span> a gene region</span>
        </div>
      </div>
    </section>
  </div>

  <script>
    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");
    const stageImage = document.getElementById("stageImage");

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      return { w: canvas.width, h: canvas.height, dpr };
    }

    // RNG helpers
    function randn() {
      let u=0, v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    // ============================================================
    // Story sections (scroll-controlled)
    // ============================================================
    const storyEl = document.getElementById("story");
    const progressPill = document.getElementById("progressPill");
    const legend = document.getElementById("legend");
    const dragHint = document.getElementById("dragHint");
    const activeHint = document.getElementById("activeHint");

    document.getElementById("toTopBtn").addEventListener("click", () => {
      window.scrollTo({top: 0, behavior: "smooth"});
    });

    // Clickable words highlight behaviour (DNA sections)
    let highlight = null; // "basepair" | "gene" | "locks" | null

    document.addEventListener("click", (e) => {
      const el = e.target.closest("[data-click]");
      if (!el) return;
      const id = el.getAttribute("data-click");
      if (id === "basepair") highlight = (highlight === "basepair") ? null : "basepair";
      if (id === "gene")     highlight = (highlight === "gene") ? null : "gene";
      if (id === "locks")    highlight = (highlight === "locks") ? null : "locks";
      updatePairStrip();
    });

    // ============================================================
    // DNA letters strip (shown in DNA sections)
    // ============================================================
    const pairPanel = document.getElementById("pairPanel");
    const pairStrip = document.getElementById("pairStrip");

    const DNA_SEQ = "ATGCCATGTTACCGTACGATTCGAGCTAATCG";
    function complement(base){
      if (base === "A") return "T";
      if (base === "T") return "A";
      if (base === "C") return "G";
      if (base === "G") return "C";
      return "?";
    }

    const STRIP_GENE_START = 10;
    const STRIP_GENE_END   = 19;
    const STRIP_BASEPAIR_INDEX = 6;

    function buildPairStrip(){
      pairStrip.innerHTML = "";
      for (let i=0; i<DNA_SEQ.length; i++){
        const top = DNA_SEQ[i];
        const bot = complement(top);

        const bp = document.createElement("div");
        bp.className = "bp";
        bp.dataset.idx = String(i);

        const t = document.createElement("div");
        t.className = "top";
        t.textContent = top;

        const b = document.createElement("div");
        b.className = "bot";
        b.textContent = bot;

        bp.appendChild(t);
        bp.appendChild(b);
        pairStrip.appendChild(bp);
      }
    }

    function updatePairStrip(){
      const show = (mode === "dna" || mode === "locks");
      pairPanel.style.display = show ? "block" : "none";
      if (!show) return;

      const nodes = pairStrip.querySelectorAll(".bp");
      nodes.forEach(n => { n.classList.remove("active"); n.classList.remove("gene"); });

      if (highlight === "basepair"){
        const el = pairStrip.querySelector(`.bp[data-idx="${STRIP_BASEPAIR_INDEX}"]`);
        if (el) el.classList.add("active");
      }
      if (highlight === "gene"){
        for (let i=STRIP_GENE_START; i<=STRIP_GENE_END; i++){
          const el = pairStrip.querySelector(`.bp[data-idx="${i}"]`);
          if (el) el.classList.add("gene");
        }
      }
    }

    buildPairStrip();

    // ============================================================
    // The story content (8 sections)
    // ============================================================
    const SECTIONS = [
      {
        id: "s1",
        tag: "Chapter 1",
        title: "Same book, different jobs",
        sub: "Every cell carries the same DNA book ‚Äî but different cells read different parts.",
        goal: "Get the big idea: <strong>DNA is the book</strong>, but <strong>what gets read</strong> depends on access and 3D folding.",
        mode: "intro",
        hint: "You‚Äôre at the start. The figure shows the whole story arc.",
        showLegend: false,
        html: `
          <p>
            Imagine every cell owns the <strong>same book</strong>.
            The book is DNA.
          </p>
          <p>
            A skin cell and a neuron have the same book ‚Äî
            but they do different jobs because they don‚Äôt read the same pages at the same time.
          </p>
          <ul>
            <li><strong>DNA</strong> is the letters.</li>
            <li><strong>Genes</strong> are the sentences that mean something.</li>
            <li><strong>Locks</strong> can make some pages hard to open.</li>
            <li><strong>Folding</strong> changes what‚Äôs nearby and easy to reach.</li>
            <li><strong>Hungry readers</strong> (proteins) spend more time where there are many ‚Äúsentences‚Äù close together.</li>
          </ul>
        `
      },
      {
        id: "s2",
        tag: "Chapter 2",
        title: "DNA is a message in four letters",
        sub: "DNA uses a tiny alphabet: A, C, G, T.",
        goal: "Recognise the DNA alphabet and what a <strong>base pair</strong> is.",
        mode: "dna",
        hint: "Try clicking: Base pair / Gene in the text (little pill-words).",
        showLegend: false,
        html: `
          <p>
            DNA is written using just four letters:
            <strong>A</strong>, <strong>C</strong>, <strong>G</strong>, and <strong>T</strong>.
          </p>
          <p>
            DNA usually comes as a twisted ladder.
            Each rung is a matching pair:
            <span class="bigClick white" data-click="basepair">base pair</span>.
            A matches with T, and C matches with G.
          </p>
          <p>
            Click <span class="bigClick white" data-click="basepair">base pair</span> to highlight one rung ‚Äî
            both on the helix and in the little letter strip under the figure.
          </p>
        `
      },
      {
        id: "s3",
        tag: "Chapter 3",
        title: "A gene is a useful stretch of DNA",
        sub: "If letters are the alphabet, a gene is a sentence the cell can copy and use.",
        goal: "Understand a <strong>gene</strong> as a continuous stretch of DNA letters.",
        mode: "dna",
        hint: "Click the word ‚Äògene‚Äô below to highlight a whole region.",
        showLegend: false,
        html: `
          <p>
            A <span class="bigClick green" data-click="gene">gene</span>
            is a stretch of DNA that the cell can copy into RNA, and often use to build proteins.
          </p>
          <p>
            Different cell types choose different genes to read more often ‚Äî
            that‚Äôs a big part of what makes them different.
          </p>
          <p>
            Click <span class="bigClick green" data-click="gene">gene</span> to highlight a gene-sized region.
          </p>
        `
      },
      {
        id: "s4",
        tag: "Chapter 4",
        title: "Some pages are harder to open",
        sub: "Cells can ‚Äòlock‚Äô parts of DNA to make them less reachable.",
        goal: "See ‚Äúlocks‚Äù as a simple way to change <strong>access</strong> (easy vs hard to read).",
        mode: "locks",
        hint: "Click ‚Äòlocks‚Äô to make the purple regions stand out.",
        showLegend: false,
        html: `
          <p>
            Cells can add chemical marks that make some DNA regions more ‚Äúclosed‚Äù.
            Think of it like putting a <span class="bigClick purple" data-click="locks">lock</span> on a chapter.
          </p>
          <p>
            Locked regions are not gone ‚Äî they‚Äôre just harder for the cell‚Äôs readers to use.
          </p>
          <p>
            Click <span class="bigClick purple" data-click="locks">locks</span> to emphasise the purple locked zones.
          </p>
          <p>
            Now comes the part people often forget: DNA is also a <strong>physical object</strong>.
            It folds in 3D.
          </p>
        `
      },
      {
        id: "s5",
        tag: "Chapter 5",
        title: "Zoom out: DNA becomes a moving chain",
        sub: "Inside the nucleus, DNA is packed as chromatin: a flexible chain that wriggles and folds.",
        goal: "See chromatin as a <strong>wiggly chain</strong> that can fold and rearrange.",
        mode: "act4",
        hint: "Try it: drag the chain and fold it a bit.",
        showLegend: true,
        html: `
          <p>
            DNA is extremely long, so it gets packed up with proteins into <strong>chromatin</strong>.
          </p>
          <p>
            In this cartoon, chromatin is drawn as a chain of little beads.
            It moves and wiggles ‚Äî like a soft thread floating in a crowded room.
          </p>
          <p>
            <strong>Try it:</strong> drag the chain around. Let go, and it keeps gently moving.
          </p>
        `
      },
      {
        id: "s6",
        tag: "Chapter 6",
        title: "Hungry readers wander around",
        sub: "Reader proteins drift randomly, looking for good places to read.",
        goal: "Understand the wandering as simple <strong>random motion</strong> (bumping around).",
        mode: "act5",
        hint: "Watch the red dots wander. No hub yet ‚Äî just searching.",
        showLegend: true,
        html: `
          <p>
            The cell has ‚Äúreaders‚Äù ‚Äî proteins that help read genes.
            They are a bit like hungry readers in a library: they move around looking for text.
          </p>
          <p>
            At first, they mostly wander and bump into things.
            Nothing is pulling the DNA into a hub yet.
          </p>
        `
      },
      {
        id: "s7",
        tag: "Chapter 7",
        title: "A busy hub forms (and stays)",
        sub: "If a big reader can hold onto DNA well, nearby DNA gathers ‚Äî making a crowded reading spot.",
        goal: "See a simple feedback: <strong>crowding makes reading easier</strong>, so the hub tends to stay.",
        mode: "act6",
        hint: "Drag the big red reader. The chain should wrap and stay clustered around it.",
        showLegend: true,
        html: `
          <p>
            Now imagine one reader is especially ‚Äúhungry‚Äù and good at grabbing nearby DNA.
            When it grabs, DNA gets pulled closer together.
          </p>
          <p>
            Once lots of DNA is close together, it looks like there are ‚Äúmore sentences‚Äù in one place.
            That makes it a great spot for reading.
          </p>
          <p>
            <strong>Try it:</strong> drag the big red reader.
            You should see the chain gather and stay clustered around it.
          </p>
        `
      },
      {
        id: "s8",
        tag: "Chapter 8",
        title: "More readers drift to the busiest spot",
        sub: "Where the DNA is densest, hungry readers are most likely to hang around.",
        goal: "Connect density to bias: <strong>busy places stay busy</strong> ‚Äî helping stable cell identity.",
        mode: "act7",
        hint: "In this chapter, extra readers drift in ‚Äî and the chain stays clustered at the hub.",
        showLegend: true,
        html: `
          <p>
            Here‚Äôs the simple idea:
            hungry readers prefer the place with the most ‚Äúsentences‚Äù close together ‚Äî
            meaning the place where the DNA chain is most dense.
          </p>
          <p>
            So once a busy hub exists, more readers tend to drift toward it and linger.
            That leaves other regions quieter.
          </p>
          <p>
            Over time, that kind of bias can help the same genes get read again and again ‚Äî
            which is one way a cell can keep its identity.
          </p>
          <p style="opacity:0.85;">
            (Optional nerd note: some scientists call these busy hubs ‚Äútranscription factories‚Äù, but you don‚Äôt need that phrase.)
          </p>
        `
      }
    ];

    // Build the scroll story HTML
    function buildStory(){
      storyEl.innerHTML = "";
      for (let i=0;i<SECTIONS.length;i++){
        const S = SECTIONS[i];
        const div = document.createElement("div");
        div.className = "section";
        div.id = S.id;
        div.dataset.mode = S.mode;

        div.innerHTML = `
          <div class="sectionHeader">
            <div class="sectionTag">${S.tag}</div>
          </div>
          <div class="sectionTitle">${S.title}</div>
          <div class="sectionSub">${S.sub}</div>
          <div class="learnGoal"><strong>Learning goal:</strong> ${S.goal}</div>

          ${renderMiniControls(S.mode, i)}

          <div class="storyText">${S.html}</div>
        `;
        storyEl.appendChild(div);
      }
    }

    function renderMiniControls(mode, idx){
      // Show mini buttons only for the DNA/locks chapters (2‚Äì4)
      // Buttons simply toggle the highlight overlay (same behaviour as clicking words).
      if (!(mode === "dna" || mode === "locks")) return "";
      const showBase = (idx === 1 || idx === 2);
      const showGene = (idx === 2);
      const showLocks = (idx === 3);

      return `
        <div class="miniControls" aria-label="Quick highlights">
          ${showBase ? `<button class="miniPill white" type="button" data-mini="basepair">Base pair</button>` : ``}
          ${showGene ? `<button class="miniPill green" type="button" data-mini="gene">Gene</button>` : ``}
          ${showLocks ? `<button class="miniPill purple" type="button" data-mini="locks">Locks</button>` : ``}
        </div>
      `;
    }

    buildStory();

    // Mini button clicks
    storyEl.addEventListener("click", (e) => {
      const b = e.target.closest("button[data-mini]");
      if (!b) return;
      const id = b.getAttribute("data-mini");
      if (id === "basepair") highlight = (highlight === "basepair") ? null : "basepair";
      if (id === "gene")     highlight = (highlight === "gene") ? null : "gene";
      if (id === "locks")    highlight = (highlight === "locks") ? null : "locks";
      updatePairStrip();
    });

    // ============================================================
    // Scroll ‚Üí choose active section ‚Üí set mode
    // ============================================================
    let activeIndex = 0;
    let mode = "intro";

    function setActiveSection(i){
      activeIndex = clamp(i, 0, SECTIONS.length - 1);
      const S = SECTIONS[activeIndex];

      mode = S.mode;

      // cosmetics
      const nodes = document.querySelectorAll(".section");
      nodes.forEach((n, j) => n.classList.toggle("active", j === activeIndex));
      progressPill.textContent = `Section ${activeIndex + 1} / ${SECTIONS.length}`;

      legend.classList.toggle("show", !!S.showLegend);

      // Drag hint appears for the hub chapters
      dragHint.classList.toggle("show", (mode === "act6" || mode === "act7"));

      activeHint.textContent = S.hint;

      // Reset highlight when leaving DNA/locks modes (keeps it simpler)
      if (!(mode === "dna" || mode === "locks")) highlight = null;
      updatePairStrip();

      // Final image overlay not used in this scroll version.
      stageImage.classList.remove("show");
      stageImage.removeAttribute("src");
      canvas.style.display = "block";

      // Make sure polymer world is (re)initialised when mode changes
      initActWorld(true);
    }

    // IntersectionObserver to ‚Äúsnap‚Äù the figure to the section in view
    const sectionEls = Array.from(document.querySelectorAll(".section"));
    const io = new IntersectionObserver((entries) => {
      // choose the most visible entry
      let best = {idx: activeIndex, ratio: 0};
      for (const ent of entries){
        if (!ent.isIntersecting) continue;
        const idx = sectionEls.indexOf(ent.target);
        if (ent.intersectionRatio > best.ratio){
          best = {idx, ratio: ent.intersectionRatio};
        }
      }
      if (best.idx !== activeIndex && best.ratio > 0.30){
        setActiveSection(best.idx);
      }
    }, { threshold: [0.30, 0.55, 0.80] });

    sectionEls.forEach(el => io.observe(el));

    // ============================================================
    // Drawing helpers
    // ============================================================
    function drawBackground(){
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // subtle texture
      ctx.fillStyle = "rgba(255,255,255,0.015)";
      for (let i=0;i<110;i++){
        const x=(i*131)%canvas.width;
        const y=(i*193)%canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }

    function glowCircle(x,y,r,color,blur=18){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function roundRect(x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // ============================================================
    // Intro flowchart (Section 1)
    // ============================================================
    function drawIntroFlowchart(){
      const W = canvas.width, H = canvas.height;
      const pad = Math.min(W,H)*0.07;

      const boxes = [
        {x: pad, y: H*0.22, w: W*0.28, h: H*0.18, label:"DNA letters\n(A,C,G,T)"},
        {x: W*0.36, y: H*0.22, w: W*0.28, h: H*0.18, label:"Genes\n(sentences)"},
        {x: W*0.68, y: H*0.22, w: W*0.28 - pad, h: H*0.18, label:"Locks\n(harder to open)"},
        {x: W*0.20, y: H*0.56, w: W*0.30, h: H*0.18, label:"Folding\n(3D chain)"},
        {x: W*0.54, y: H*0.56, w: W*0.30, h: H*0.18, label:"Busy hubs\n(reading spots)"},
      ];

      // arrows
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.40)";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";

      function arrow(x1,y1,x2,y2){
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        const ang = Math.atan2(y2-y1, x2-x1);
        const ah = 10;
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - ah*Math.cos(ang-0.35), y2 - ah*Math.sin(ang-0.35));
        ctx.lineTo(x2 - ah*Math.cos(ang+0.35), y2 - ah*Math.sin(ang+0.35));
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.45)";
        ctx.fill();
      }

      arrow(boxes[0].x+boxes[0].w, boxes[0].y+boxes[0].h*0.5, boxes[1].x, boxes[1].y+boxes[1].h*0.5);
      arrow(boxes[1].x+boxes[1].w, boxes[1].y+boxes[1].h*0.5, boxes[2].x, boxes[2].y+boxes[2].h*0.5);
      arrow(boxes[0].x+boxes[0].w*0.5, boxes[0].y+boxes[0].h, boxes[3].x+boxes[3].w*0.35, boxes[3].y);
      arrow(boxes[2].x+boxes[2].w*0.5, boxes[2].y+boxes[2].h, boxes[4].x+boxes[4].w*0.65, boxes[4].y);
      arrow(boxes[3].x+boxes[3].w, boxes[3].y+boxes[3].h*0.5, boxes[4].x, boxes[4].y+boxes[4].h*0.5);

      ctx.restore();

      for (let i=0;i<boxes.length;i++){
        const b = boxes[i];
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.lineWidth = 2;
        roundRect(b.x, b.y, b.w, b.h, 16, true, true);

        const accent =
          (i===0) ? "rgba(255,255,255,0.55)" :
          (i===1) ? "rgba(0,255,140,0.55)" :
          (i===2) ? "rgba(190,120,255,0.55)" :
          (i===3) ? "rgba(255,255,255,0.40)" :
                   "rgba(255,120,200,0.50)";
        ctx.fillStyle = accent;
        roundRect(b.x+10, b.y+10, 10, b.h-20, 8, true, false);

        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "950 16px system-ui";
        const lines = b.label.split("\n");
        let ty = b.y + b.h*0.50 - (lines.length-1)*10;
        for (const line of lines){
          ctx.fillText(line, b.x + 28, ty);
          ty += 22;
        }
        ctx.restore();
      }

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "900 13px system-ui";
      ctx.fillText("Figure: DNA (book) + access + folding ‚Üí busy hubs ‚Üí biased reading", pad, H*0.90);
      ctx.restore();
    }

    // ============================================================
    // DNA helix (Sections 2‚Äì4)
    // ============================================================
    function drawDNAHelix(){
      const W = canvas.width, H = canvas.height;
      const cx = W * 0.52;
      const cy = H * 0.56;
      const amp = H * 0.14;
      const pitch = W * 0.022;
      const turns = 44;
      const tNow = performance.now() * 0.0016;

      const baseHi = (highlight === "basepair");
      const geneHi = (highlight === "gene");
      const lockHi = (highlight === "locks");

      const geneStart = 15;
      const geneEnd   = 24;

      const lockSegments = [
        { a: 7,  b: 12 },
        { a: 28, b: 33 }
      ];

      function isLocked(i){
        for (const seg of lockSegments){
          if (i >= seg.a && i <= seg.b) return true;
        }
        return false;
      }

      if (mode === "locks") {
        ctx.save();
        ctx.globalAlpha = lockHi ? 0.28 : 0.20;
        ctx.fillStyle = "rgba(170, 90, 255, 1)";
        const x0 = cx - (turns*pitch)/2;
        for (const seg of lockSegments){
          const xa = x0 + seg.a*pitch - pitch*0.6;
          const xb = x0 + seg.b*pitch + pitch*0.6;
          roundRect(xa, cy - amp*1.35, (xb-xa), amp*2.7, 16, true, false);
        }
        ctx.restore();
      }

      for (let i=0;i<turns;i++){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);

        const inGene = (i>=geneStart && i<=geneEnd);
        const locked = isLocked(i);

        let rungColor = "rgba(255,255,255,0.20)";
        let rungWidth = 2.0;

        if (geneHi && inGene) { rungColor = "rgba(0,255,140,0.92)"; rungWidth = 3.0; }
        else if (baseHi && (i%4===0)) { rungColor = "rgba(255,255,255,0.92)"; rungWidth = 3.0; }

        if (mode === "locks" && locked) {
          rungColor = lockHi ? "rgba(230, 200, 255, 0.95)" : "rgba(230, 200, 255, 0.55)";
          rungWidth = lockHi ? 3.0 : 2.2;
        }

        ctx.save();
        ctx.strokeStyle = rungColor;
        ctx.lineWidth = rungWidth;
        ctx.beginPath();
        ctx.moveTo(x,y1);
        ctx.lineTo(x,y2);
        ctx.stroke();
        ctx.restore();

        let backboneColor = "rgba(255,255,255,0.55)";
        if (geneHi && inGene) backboneColor = "rgba(0,255,140,0.65)";
        if (mode === "locks" && locked) backboneColor = lockHi ? "rgba(190, 120, 255, 0.80)" : "rgba(190, 120, 255, 0.50)";

        glowCircle(x, y1, 5.0, backboneColor, 18);
        glowCircle(x, y2, 5.0, backboneColor, 18);

        if (mode === "locks" && locked && (i % 3 === 0)) {
          ctx.save();
          ctx.font = "950 14px system-ui";
          ctx.fillStyle = lockHi ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.70)";
          ctx.shadowColor = "rgba(190,120,255,0.55)";
          ctx.shadowBlur = 16;
          ctx.fillText("üîí", x - 7, (0.5*(y1+y2)) + 5);
          ctx.restore();
        }
      }
    }

    // ============================================================
    // Polymer worlds (Sections 5‚Äì8)
    // ============================================================
    const world = {
      initialised: false,
      beads: [],
      bvx: [],
      bvy: [],
      tfs: [],
      frame: 0
    };

    const P = {
      beadCount: 210,
      restLen: 9,
      kSpring: 0.18,
      kBend: 0.010,
      damping: 0.92,
      beadR: 4.6,
      repelK: 0.55
    };

    const bigTF = { x: 0, y: 0, vx: 0, vy: 0, radius: 34 };
    let draggingTF = false;
    let dragOffset = {x:0, y:0};

    let draggingBead = { active:false, idx:-1 };
    let beadDragK = 0.020;

    function mouseToCanvas(e){
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left);
      const sy = (e.clientY - rect.top);
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: sx * scaleX, y: sy * scaleY };
    }
    function pointerPos(e){ return mouseToCanvas(e); }

    function findNearestBead(px, py, maxDist){
      let best = {idx:-1, d2: maxDist*maxDist};
      for (let i=0;i<world.beads.length;i++){
        const b = world.beads[i];
        const dx = b.x - px, dy = b.y - py;
        const d2 = dx*dx + dy*dy;
        if (d2 < best.d2){
          best = {idx:i, d2};
        }
      }
      return best.idx;
    }

    canvas.addEventListener("pointerdown", (e) => {
      const p = pointerPos(e);

      if (mode === "act6" || mode === "act7"){
        const dx = p.x - bigTF.x;
        const dy = p.y - bigTF.y;
        if (Math.sqrt(dx*dx+dy*dy) < bigTF.radius*1.15){
          draggingTF = true;
          dragOffset.x = dx;
          dragOffset.y = dy;
          canvas.setPointerCapture(e.pointerId);
          return;
        }
      }

      if (mode === "act4"){
        const idx = findNearestBead(p.x, p.y, 26);
        if (idx !== -1){
          draggingBead.active = true;
          draggingBead.idx = idx;
          canvas.setPointerCapture(e.pointerId);
        }
      }
    });

    const lastPointer = {x:0,y:0};

    canvas.addEventListener("pointermove", (e) => {
      const p = pointerPos(e);

      if (draggingTF){
        bigTF.x = p.x - dragOffset.x;
        bigTF.y = p.y - dragOffset.y;
        return;
      }
      lastPointer.x = p.x;
      lastPointer.y = p.y;
    });

    function stopDragging(){
      draggingTF = false;
      draggingBead.active = false;
      draggingBead.idx = -1;
    }
    canvas.addEventListener("pointerup", stopDragging);
    canvas.addEventListener("pointercancel", stopDragging);

    let bigTFs = []; // extra readers in act7

    function initActWorld(force=false){
      const polymerModes = ["act4","act5","act6","act7"];
      if (!polymerModes.includes(mode)) return;

      if (world.initialised && !force) return;

      world.initialised = true;
      world.frame = 0;
      resizeCanvas();
      const W = canvas.width, H = canvas.height;

      world.beads = [];
      world.bvx = new Array(P.beadCount).fill(0);
      world.bvy = new Array(P.beadCount).fill(0);

      const startX = W * 0.10;
      const midY = H * 0.56;

      for (let i=0;i<P.beadCount;i++){
        const x = startX + i*P.restLen;
        const y = midY + (H*0.06)*Math.sin(i*0.17) + (H*0.02)*randn();
        world.beads.push({x,y});
      }

      // Make act4 slightly folded so it‚Äôs fun to drag
      if (mode === "act4"){
        const a1 = {x: W*0.44, y: H*0.50};
        const a2 = {x: W*0.60, y: H*0.62};

        for (let i=0;i<P.beadCount;i++){
          const p = world.beads[i];
          const t = i/(P.beadCount-1);

          const w1 = Math.exp(-Math.pow((t-0.25)/0.14,2));
          const w2 = Math.exp(-Math.pow((t-0.50)/0.14,2));
          const w3 = Math.exp(-Math.pow((t-0.75)/0.14,2));

          const ax = a1.x*w1 + a2.x*w2 + a1.x*w3;
          const ay = a1.y*w1 + a2.y*w2 + a1.y*w3;

          const w = 0.55*(w1+w2+w3);
          p.x = p.x*(1-w) + ax*w;
          p.y = p.y*(1-w) + ay*w;
        }
        for (let i=0;i<P.beadCount;i++){
          const p = world.beads[i];
          const t = i/(P.beadCount-1);
          p.y += (H*0.05)*Math.sin(10*t);
        }
      }

      // act5: many small readers wandering
      world.tfs = [];
      if (mode === "act5"){
        for (let i=0;i<36;i++){
          world.tfs.push({
            x: W*(0.20 + 0.60*Math.random()),
            y: H*(0.20 + 0.60*Math.random()),
            vx: 0, vy: 0
          });
        }
      }

      // act6: big reader in the middle
      if (mode === "act6"){
        bigTF.x = W*0.60;
        bigTF.y = H*0.56;
        bigTF.vx = 0; bigTF.vy = 0;
      }

      // act7: start already clustered around the big reader
      if (mode === "act7"){
        bigTF.x = W*0.58;
        bigTF.y = H*0.54;
        bigTF.vx = 0; bigTF.vy = 0;

        const center = {x: bigTF.x, y: bigTF.y};
        const R0 = bigTF.radius * 1.10;
        const R1 = bigTF.radius * 3.8;

        for (let i=0;i<P.beadCount;i++){
          const t = i/(P.beadCount-1);
          const w = Math.exp(-Math.pow((t-0.52)/0.22,2));
          if (w < 0.12) continue;

          const angle = (i*0.36);
          const r = (R0 + (R1-R0)*(0.5+0.5*Math.sin(i*0.07))) * (0.6 + 0.5*w);
          const targetX = center.x + r*Math.cos(angle);
          const targetY = center.y + r*Math.sin(angle);

          world.beads[i].x = world.beads[i].x*(1-w) + targetX*w;
          world.beads[i].y = world.beads[i].y*(1-w) + targetY*w;
        }

        bigTFs = [];
        const count = 7;
        for (let i=0;i<count;i++){
          bigTFs.push({
            x: W*(0.12 + 0.76*Math.random()),
            y: H*(0.18 + 0.64*Math.random()),
            vx: 0, vy: 0,
            radius: 26 + 6*Math.random()
          });
        }
      }
    }

    function springForce(ax, ay, bx, by, rest, k){
      const dx=bx-ax, dy=by-ay;
      const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
      const f=k*(r-rest);
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function bendForce(p0,p1,p2,kB){
      const mx=0.5*(p0.x+p2.x);
      const my=0.5*(p0.y+p2.y);
      return {fx:kB*(mx-p1.x), fy:kB*(my-p1.y)};
    }
    function repelPair(ax, ay, bx, by, minDist, k){
      const dx=bx-ax, dy=by-ay;
      const r2=dx*dx+dy*dy+1e-6;
      const r=Math.sqrt(r2);
      if (r>=minDist) return {fx:0, fy:0};
      const overlap=minDist-r;
      const f=k*overlap;
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function softWalls(x,y,vx,vy){
      const W=canvas.width, H=canvas.height;
      const margin=70;
      const k=0.0018;
      if (x<margin) vx += k*(margin-x);
      if (x>W-margin) vx -= k*(x-(W-margin));
      if (y<margin) vy += k*(margin-y);
      if (y>H-margin) vy -= k*(y-(H-margin));
      return {vx,vy};
    }

    // This is the ‚Äúhub‚Äù force: the chain is gently pulled toward the big reader
    // In act7 we make it stronger so the chain stays clustered (no relaxing away).
    function wrapForce(p, tf, strength){
      const dx=tf.x - p.x;
      const dy=tf.y - p.y;
      const d=Math.sqrt(dx*dx+dy*dy)+1e-6;

      const attractR = tf.radius * 4.2;
      const repelR   = tf.radius * 1.10;

      let fx=0, fy=0;
      if (d < repelR){
        const push = (repelR - d) * (0.10 * strength);
        fx -= push * dx/d;
        fy -= push * dy/d;
      } else if (d < attractR){
        const s = (1 - d/attractR);
        const pull = (0.010 * strength) * s;
        fx += pull * dx;
        fy += pull * dy;
      }
      return {fx, fy};
    }

    function stepPolymer(){
      world.frame++;
      const n = P.beadCount;

      // Springs + bending
      for (let i=0;i<n-1;i++){
        const a=world.beads[i], b=world.beads[i+1];
        const f=springForce(a.x,a.y,b.x,b.y,P.restLen,P.kSpring);
        world.bvx[i] += f.fx; world.bvy[i] += f.fy;
        world.bvx[i+1] -= f.fx; world.bvy[i+1] -= f.fy;
      }
      for (let i=1;i<n-1;i++){
        const f=bendForce(world.beads[i-1], world.beads[i], world.beads[i+1], P.kBend);
        world.bvx[i] += f.fx;
        world.bvy[i] += f.fy;
      }

      // Soft self-avoidance
      const minBB = 2*P.beadR;
      for (let i=0;i<n;i++){
        const i0=Math.max(0,i-14);
        const i1=Math.min(n-1,i+14);
        for (let j=i0;j<=i1;j++){
          if (j===i) continue;
          if (Math.abs(i-j)<=1) continue;
          const a=world.beads[i], b=world.beads[j];
          const f=repelPair(a.x,a.y,b.x,b.y,minBB,0.55);
          world.bvx[i] -= f.fx; world.bvy[i] -= f.fy;
          world.bvx[j] += f.fx; world.bvy[j] += f.fy;
        }
      }

      // Dragging a bead (act4)
      if (mode === "act4" && draggingBead.active && draggingBead.idx >= 0){
        const i = draggingBead.idx;
        const b = world.beads[i];
        const dx = (lastPointer.x - b.x);
        const dy = (lastPointer.y - b.y);
        world.bvx[i] += beadDragK * dx;
        world.bvy[i] += beadDragK * dy;
      }

      // Hub force (act6 + act7)
      if (mode === "act6" || mode === "act7"){
        const strength = (mode === "act7") ? 1.8 : 1.0; // <-- key change: act7 stays clustered
        for (let i=0;i<n;i++){
          const p=world.beads[i];
          const f = wrapForce(p, bigTF, strength);
          world.bvx[i] += f.fx;
          world.bvy[i] += f.fy;
        }
      }

      // Brownian wiggle: tune per act
      let brown = 0.16;
      if (mode === "act4") brown = 0.22;
      if (mode === "act5") brown = 0.02;
      if (mode === "act6") brown = 0.12;
      if (mode === "act7") brown = 0.006; // very low so hub doesn‚Äôt ‚Äúmelt away‚Äù

      for (let i=0;i<n;i++){
        world.bvx[i] += brown*randn();
        world.bvy[i] += brown*randn();
        world.bvx[i] *= P.damping;
        world.bvy[i] *= P.damping;

        world.beads[i].x += world.bvx[i];
        world.beads[i].y += world.bvy[i];

        const out=softWalls(world.beads[i].x, world.beads[i].y, world.bvx[i], world.bvy[i]);
        world.bvx[i]=out.vx; world.bvy[i]=out.vy;
      }

      // Small readers wandering (act5)
      if (mode === "act5"){
        const W=canvas.width, H=canvas.height;
        for (const tf of world.tfs){
          tf.vx += 0.55*randn();
          tf.vy += 0.55*randn();
          tf.vx *= 0.93;
          tf.vy *= 0.93;
          tf.x += tf.vx;
          tf.y += tf.vy;
          if (tf.x<0) tf.x += W;
          if (tf.x>W) tf.x -= W;
          if (tf.y<0) tf.y += H;
          if (tf.y>H) tf.y -= H;
        }
      }

      // Extra readers drift toward the hub (act7)
      if (mode === "act7"){
        const W=canvas.width, H=canvas.height;
        const target = {x: bigTF.x, y: bigTF.y};
        for (const tf of bigTFs){
          tf.vx += 0.12*randn();
          tf.vy += 0.12*randn();

          // gentle ‚Äúhungry toward dense‚Äù drift
          tf.vx += 0.0018*(target.x - tf.x);
          tf.vy += 0.0018*(target.y - tf.y);

          tf.vx *= 0.88;
          tf.vy *= 0.88;
          tf.x += tf.vx;
          tf.y += tf.vy;

          if (tf.x<0) tf.x += W;
          if (tf.x>W) tf.x -= W;
          if (tf.y<0) tf.y += H;
          if (tf.y>H) tf.y -= H;
        }
      }
    }

    function drawPolymerAndTFs(){
      // chain
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      world.beads.forEach((p,i)=>{
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads
      for (const p of world.beads){
        glowCircle(p.x,p.y, 4.6, "rgba(255,255,255,0.52)", 15);
      }

      // small readers (act5)
      if (mode === "act5"){
        for (const tf of world.tfs){
          glowCircle(tf.x, tf.y, 6.2, "rgba(255,60,60,0.65)", 20);
        }
      }

      // big reader hub (act6/act7)
      if (mode === "act6" || mode === "act7"){
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        glowCircle(bigTF.x, bigTF.y, bigTF.radius*5.0, "rgba(255,120,200,0.020)", 160);
        glowCircle(bigTF.x, bigTF.y, bigTF.radius*2.6, "rgba(255,60,60,0.020)", 120);
        ctx.restore();

        glowCircle(bigTF.x, bigTF.y, bigTF.radius, "rgba(255,60,60,0.92)", 44);
      }

      // extra readers drifting in (act7)
      if (mode === "act7"){
        for (const tf of bigTFs){
          glowCircle(tf.x, tf.y, tf.radius, "rgba(255,60,60,0.55)", 28);
        }
      }
    }

    // ============================================================
    // Main tick
    // ============================================================
    function tick(){
      resizeCanvas();
      drawBackground();

      if (mode === "intro"){
        drawIntroFlowchart();
      } else if (mode === "dna" || mode === "locks"){
        drawDNAHelix();
      } else if (mode === "act4" || mode === "act5" || mode === "act6" || mode === "act7"){
        initActWorld(false);
        stepPolymer();
        drawPolymerAndTFs();
      }

      requestAnimationFrame(tick);
    }

    // ============================================================
    // Init / resize
    // ============================================================
    window.addEventListener("resize", () => {
      resizeCanvas();
      initActWorld(true);
    });

    resizeCanvas();
    setActiveSection(0);
    tick();
  </script>
</body>
</html>








































