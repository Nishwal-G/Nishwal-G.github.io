<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DNA → Chromatin → BIPS (Simple) | Nishwal Gora</title>
  <style>
    :root{
      --bg:#050507;
      --border:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --maxw:1100px;

      --green: rgba(0,255,140,0.95);
      --greenDim: rgba(0,255,140,0.35);
      --red: rgba(255,60,60,0.92);
      --redDim: rgba(255,60,60,0.55);
      --pink: rgba(255,120,200,0.70);
      --purple: rgba(190,120,255,0.92);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }

    .page{
      min-height:100vh;
      padding:14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:14px;
    }

    /* Text panel above canvas */
    .textPanel{
      width:min(var(--maxw),100%);
      border:1px solid var(--border);
      border-radius:18px;
      background:rgba(0,0,0,0.46);
      backdrop-filter: blur(12px);
      box-shadow:0 20px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .textInner{ padding:16px; }
    .kicker{
      font-weight:900;
      letter-spacing:0.3px;
      font-size:12px;
      color:rgba(255,255,255,0.70);
      text-transform:uppercase;
      margin-bottom:8px;
    }
    .sceneTitle{
      margin:0;
      font-weight:950;
      letter-spacing:-0.3px;
      font-size: clamp(20px, 2.2vw, 28px);
      line-height:1.1;
    }
    .sceneSub{
      margin-top:8px;
      color:var(--muted);
      font-size:14px;
      line-height:1.55;
    }
    .story{
      margin-top:12px;
      color:rgba(255,255,255,0.78);
      font-size:15px;
      line-height:1.72;
    }
    .story p{ margin:10px 0 0 0; }

    .controls{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      align-items:center;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .pill{
      border:1px solid var(--border);
      background:rgba(0,0,0,0.38);
      color:rgba(255,255,255,0.90);
      padding:9px 14px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      backdrop-filter: blur(10px);
      user-select:none;
    }
    .pill:hover{ background:rgba(255,255,255,0.10); }
    .pill.strong{ background:rgba(255,255,255,0.12); }
    .pill.ghost{ background:rgba(255,255,255,0.04); }
    .pill:disabled{ opacity:0.35; cursor:default; }

    /* Canvas */
    .stage{
      width:min(var(--maxw),100%);
      height:min(62vh,720px);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      overflow:hidden;
      background:rgba(0,0,0,0.25);
      position:relative;
    }
    #stageCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    .legend{
      position:absolute;
      left:12px;
      bottom:12px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:16px;
      background:rgba(0,0,0,0.32);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,0.70);
      font-size:12px;
      display:flex;
      gap:10px;
      align-items:center;
      pointer-events:none;

      opacity:0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .legend.show{ opacity:1; transform: translateY(0); }
    .dot{ width:9px; height:9px; border-radius:50%; display:inline-block; margin-right:6px; }
    .dot.white{ background:rgba(255,255,255,0.85); }
    .dot.green{ background:var(--green); }
    .dot.red{ background:var(--red); }
    .dot.pink{ background:var(--pink); }

    @media (max-width:860px){
      .stage{ height:52vh; }
    }
  </style>
</head>

<body>
  <div class="page">
    <section class="textPanel">
      <div class="textInner">
        <div class="kicker" id="kicker">Act 4 of 8</div>
        <h1 class="sceneTitle" id="sceneTitle">Act 4 — Chromatin as a wiggly polymer</h1>
        <div class="sceneSub" id="sceneSub">Press Next / Prev to move through the acts. Press Reset to replay the current act.</div>
        <div class="story" id="story"></div>

        <div class="controls">
          <button class="pill ghost" id="prevBtn" type="button">← Prev</button>
          <button class="pill ghost" id="resetBtn" type="button">↻ Reset</button>
          <button class="pill strong" id="nextBtn" type="button">Next →</button>
        </div>
      </div>
    </section>

    <section class="stage">
      <canvas id="stageCanvas"></canvas>
      <div class="legend" id="legend">
        <span><span class="dot white"></span>chromatin</span>
        <span><span class="dot green"></span>gene region</span>
        <span><span class="dot red"></span>TF (reader)</span>
        <span><span class="dot pink"></span>cluster / hub</span>
      </div>
    </section>
  </div>

  <script>
    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");
    function resizeCanvas(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      return {w:canvas.width, h:canvas.height};
    }
    window.addEventListener("resize", () => { resizeCanvas(); initAct(true); });

    // RNG
    function randn(){
      let u=0,v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    // Draw helpers
    function drawBackground(){
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      for (let i=0;i<140;i++){
        const x=(i*97)%canvas.width;
        const y=(i*181)%canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }
    function glowCircle(x,y,r,color,blur){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // ============================================================
    // ACTS 4–8 only (as requested: simplified chromatin animations)
    // ============================================================
    let act = 4;

    const UI = {
      kicker: document.getElementById("kicker"),
      title: document.getElementById("sceneTitle"),
      sub: document.getElementById("sceneSub"),
      story: document.getElementById("story"),
      prev: document.getElementById("prevBtn"),
      next: document.getElementById("nextBtn"),
      reset: document.getElementById("resetBtn"),
      legend: document.getElementById("legend"),
    };

    const ACTS = {
      4: {
        title: "Act 4 — Chromatin as a wiggly polymer",
        sub: "We zoom out: DNA is packed into chromatin, which behaves like a moving, bending chain.",
        story: `
          <p>
            Now imagine zooming out so far that the DNA helix is too small to see. What you see instead is
            <strong>chromatin</strong>: DNA plus proteins, packed into a 3D structure.
          </p>
          <p>
            Physicists often model chromatin as a <strong>polymer</strong>: a chain of beads connected by springs.
            In this cartoon, each bead represents a huge chunk of DNA (millions of base pairs).
          </p>
          <p>
            The key point is that chromatin is not frozen. It <strong>wiggles</strong>, bends, and explores shapes over time.
          </p>
        `,
        mode: "polymer_only"
      },
      5: {
        title: "Act 5 — TFs float around (no attraction yet)",
        sub: "Transcription factors (TFs) are proteins that drift randomly in the nucleus like pollen in water.",
        story: `
          <p>
            Genes are “read” by proteins. A famous class is <strong>transcription factors</strong> (TFs).
            They move around by random jiggling (thermal motion), colliding with everything in the nucleus.
          </p>
          <p>
            In this act, TFs are just <span style="color: rgba(255,60,60,0.92); font-weight:900;">red</span> particles
            drifting around. They are not especially attracted to genes yet — they are searching.
          </p>
        `,
        mode: "polymer_plus_free_tfs"
      },
      6: {
        title: "Act 6 — A TF pulls two genes together (one stays lonely)",
        sub: "If a TF interacts with two nearby gene regions, it can help bring them close in 3D.",
        story: `
          <p>
            Here’s the physical idea: if a TF can help connect two gene regions, it can “pull” them closer in 3D space.
            That creates a small cluster where reading becomes easier.
          </p>
          <p>
            Watch: two green gene regions are encouraged to come together into one cluster.
            A third green region stays isolated and has almost no red TFs nearby.
          </p>
        `,
        mode: "two_genes_cluster_one_lonely"
      },
      7: {
        title: "Act 7 — Positive feedback: more TFs gather at the cluster",
        sub: "Once a cluster forms, TFs bump into it more often, so more TFs accumulate there.",
        story: `
          <p>
            A cluster doesn’t just sit there — it changes the “traffic pattern” in the nucleus.
            A dense cluster is a bigger target, so wandering TFs are more likely to hit it and stick around.
          </p>
          <p>
            This is a simple <strong>positive feedback</strong>: clustering makes reading easier, which can attract more TFs,
            which can stabilise the cluster. The lonely green region remains relatively quiet.
          </p>
        `,
        mode: "cluster_attracts_more_tfs"
      },
      8: {
        title: "Act 8 — A ‘map’ of the nucleus: hotspots and quiet regions",
        sub: "A final picture: chromatin looks like a web, with a few active hubs and many quiet regions.",
        story: `
          <p>
            In real cells, chromatin can look like a complex 3D web. Some places are busy: many TFs and active genes.
            Other regions are quiet: fewer TFs, less reading.
          </p>
          <p>
            This kind of organisation is sometimes described using the idea of <strong>transcription factories</strong>:
            hotspots where reading happens more often.
          </p>
        `,
        mode: "static_web_snapshot"
      }
    };

    UI.prev.addEventListener("click", () => { act = Math.max(4, act-1); applyAct(); });
    UI.next.addEventListener("click", () => { act = Math.min(8, act+1); applyAct(); });
    UI.reset.addEventListener("click", () => initAct(true));

    function applyAct(){
      UI.kicker.textContent = `Act ${act} of 8`;
      UI.title.textContent = ACTS[act].title;
      UI.sub.textContent = ACTS[act].sub;
      UI.story.innerHTML = ACTS[act].story;

      UI.prev.disabled = (act === 4);
      UI.next.disabled = (act === 8);

      // legend on for polymer acts
      UI.legend.classList.toggle("show", act >= 4);

      initAct(true);
    }

    // ============================================================
    // World state (simplified)
    // ============================================================
    const W = {
      beads: [],
      bvx: [],
      bvy: [],
      isGene: [],
      // Act 6/7: which genes are "cluster genes" vs "lonely gene"
      geneRole: [], // "cluster" | "lonely" | "none"

      tfs: [], // {x,y,vx,vy, mode:"free"|"bias"}
      frame: 0
    };

    // Tunable physics for "more wiggle" (Act 4 request)
    const P = {
      beadCount: 220,
      restLen: 9,

      // Make it MUCH wigglier than before:
      kSpring: 0.10,        // softer springs
      kBend: 0.004,         // less bending stiffness
      damping: 0.90,        // less damping -> more motion persists
      brownian: 0.55,       // stronger Brownian kicks

      beadR: 4.6,
      repelK: 0.42,

      // TFs
      tfCountAct5: 22,
      tfCountAct7: 48,
      tfR: 6.2,
      tfBrown: 0.55,
      tfDamp: 0.94,

      // Bias strengths (act6/7)
      pullGeneTogether: 0.0048, // pulls two gene regions toward one another (via a virtual "bridge")
      tfBiasToCluster: 0.0018,  // gentle drift toward cluster center in act7
      tfBiasAwayLonely: 0.0008  // slight push away from lonely region so it stays quiet
    };

    function initAct(force){
      resizeCanvas();
      const mode = ACTS[act].mode;
      W.frame = 0;

      if (mode === "static_web_snapshot"){
        // no dynamic world needed
        return;
      }

      // Build polymer fresh each act (independent animations)
      const cw = canvas.width, ch = canvas.height;

      W.beads = [];
      W.bvx = new Array(P.beadCount).fill(0);
      W.bvy = new Array(P.beadCount).fill(0);
      W.isGene = new Array(P.beadCount).fill(false);
      W.geneRole = new Array(P.beadCount).fill("none");

      // Start as a long chain across the screen with a wavy shape
      const startX = cw * 0.06;
      const midY = ch * 0.58;
      for (let i=0;i<P.beadCount;i++){
        const x = startX + i*P.restLen;
        const y = midY + (ch*0.10)*Math.sin(i*0.22) + (ch*0.04)*Math.sin(i*0.07);
        W.beads.push({x,y});
      }

      // Define 3 gene regions
      const centers = [
        Math.floor(P.beadCount * 0.26),
        Math.floor(P.beadCount * 0.52),
        Math.floor(P.beadCount * 0.78),
      ];
      for (const c of centers){
        for (let j=-6;j<=6;j++){
          const idx = c + j;
          if (idx>=0 && idx<P.beadCount) W.isGene[idx] = true;
        }
      }

      // Roles for act6/7: two genes cluster, one lonely
      if (mode === "two_genes_cluster_one_lonely" || mode === "cluster_attracts_more_tfs"){
        // choose left + middle to cluster, right to be lonely
        const c1 = centers[0];
        const c2 = centers[1];
        const cl = centers[2];

        for (let i=0;i<P.beadCount;i++){
          if (!W.isGene[i]) continue;
          if (Math.abs(i-c1) <= 7 || Math.abs(i-c2) <= 7) W.geneRole[i] = "cluster";
          if (Math.abs(i-cl) <= 7) W.geneRole[i] = "lonely";
        }
      }

      // TFs for act5/6/7
      W.tfs = [];
      if (mode === "polymer_plus_free_tfs"){
        spawnTFs(P.tfCountAct5, "free");
      }
      if (mode === "two_genes_cluster_one_lonely"){
        spawnTFs(P.tfCountAct5, "free"); // just a few, mostly near the cluster later via “bridge”
      }
      if (mode === "cluster_attracts_more_tfs"){
        spawnTFs(P.tfCountAct7, "bias"); // more TFs with gentle bias to cluster
      }
    }

    function spawnTFs(n, tfMode){
      const cw = canvas.width, ch = canvas.height;
      for (let i=0;i<n;i++){
        W.tfs.push({
          x: cw*(0.20 + 0.60*Math.random()),
          y: ch*(0.18 + 0.64*Math.random()),
          vx: 0,
          vy: 0,
          mode: tfMode
        });
      }
    }

    // Physics helpers
    function springForce(ax, ay, bx, by, rest, k){
      const dx=bx-ax, dy=by-ay;
      const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
      const f=k*(r-rest);
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function bendForce(p0,p1,p2,kB){
      const mx=0.5*(p0.x+p2.x);
      const my=0.5*(p0.y+p2.y);
      return {fx:kB*(mx-p1.x), fy:kB*(my-p1.y)};
    }
    function repelPair(ax, ay, bx, by, minDist, k){
      const dx=bx-ax, dy=by-ay;
      const r2=dx*dx+dy*dy+1e-6;
      const r=Math.sqrt(r2);
      if (r>=minDist) return {fx:0, fy:0};
      const overlap=minDist-r;
      const f=k*overlap;
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function softWalls(x,y,vx,vy){
      const cw=canvas.width, ch=canvas.height;
      const margin=60;
      const k=0.0020;
      if (x<margin) vx += k*(margin-x);
      if (x>cw-margin) vx -= k*(x-(cw-margin));
      if (y<margin) vy += k*(margin-y);
      if (y>ch-margin) vy -= k*(y-(ch-margin));
      return {vx,vy};
    }

    function step(){
      const mode = ACTS[act].mode;

      if (mode === "static_web_snapshot") return;

      const n = P.beadCount;

      // --- polymer dynamics ---
      // springs
      for (let i=0;i<n-1;i++){
        const a=W.beads[i], b=W.beads[i+1];
        const f=springForce(a.x,a.y,b.x,b.y,P.restLen,P.kSpring);
        W.bvx[i] += f.fx; W.bvy[i] += f.fy;
        W.bvx[i+1] -= f.fx; W.bvy[i+1] -= f.fy;
      }

      // bending
      for (let i=1;i<n-1;i++){
        const f=bendForce(W.beads[i-1], W.beads[i], W.beads[i+1], P.kBend);
        W.bvx[i] += f.fx;
        W.bvy[i] += f.fy;
      }

      // excluded volume (local)
      const minBB = 2*P.beadR;
      for (let i=0;i<n;i++){
        const i0=Math.max(0,i-14);
        const i1=Math.min(n-1,i+14);
        for (let j=i0;j<=i1;j++){
          if (j===i) continue;
          if (Math.abs(i-j)<=1) continue;
          const a=W.beads[i], b=W.beads[j];
          const f=repelPair(a.x,a.y,b.x,b.y,minBB,P.repelK);
          W.bvx[i] -= f.fx; W.bvy[i] -= f.fy;
          W.bvx[j] += f.fx; W.bvy[j] += f.fy;
        }
      }

      // Act 6/7: virtual “TF bridge” pulling the two cluster gene regions together
      if (mode === "two_genes_cluster_one_lonely" || mode === "cluster_attracts_more_tfs"){
        // compute centers for cluster genes and lonely genes
        let cx=0, cy=0, cc=0;
        let lx=0, ly=0, lc=0;

        for (let i=0;i<n;i++){
          if (!W.isGene[i]) continue;
          if (W.geneRole[i] === "cluster"){ cx += W.beads[i].x; cy += W.beads[i].y; cc++; }
          if (W.geneRole[i] === "lonely"){ lx += W.beads[i].x; ly += W.beads[i].y; lc++; }
        }
        if (cc>0){ cx/=cc; cy/=cc; }
        if (lc>0){ lx/=lc; ly/=lc; }

        // Pull all "cluster gene" beads toward the cluster center (tighten)
        for (let i=0;i<n;i++){
          if (W.geneRole[i] !== "cluster") continue;
          const dx = cx - W.beads[i].x;
          const dy = cy - W.beads[i].y;
          W.bvx[i] += 0.0022*dx;
          W.bvy[i] += 0.0022*dy;
        }

        // Additionally: bring the two gene regions closer by pulling them to a common target
        // We do this by gently pulling cluster center toward the middle of the stage.
        const targetX = canvas.width*0.52;
        const targetY = canvas.height*0.55;
        const ddx = targetX - cx;
        const ddy = targetY - cy;

        // distribute this pull across cluster gene beads
        for (let i=0;i<n;i++){
          if (W.geneRole[i] !== "cluster") continue;
          W.bvx[i] += P.pullGeneTogether*ddx;
          W.bvy[i] += P.pullGeneTogether*ddy;
        }

        // Keep the lonely region away (so it stays lonely and quiet)
        for (let i=0;i<n;i++){
          if (W.geneRole[i] !== "lonely") continue;
          const dx = (canvas.width*0.82) - W.beads[i].x;
          const dy = (canvas.height*0.42) - W.beads[i].y;
          W.bvx[i] += 0.0018*dx;
          W.bvy[i] += 0.0018*dy;
        }
      }

      // integrate beads
      for (let i=0;i<n;i++){
        W.bvx[i] += P.brownian*randn();
        W.bvy[i] += P.brownian*randn();
        W.bvx[i] *= P.damping;
        W.bvy[i] *= P.damping;

        W.beads[i].x += W.bvx[i];
        W.beads[i].y += W.bvy[i];

        const out=softWalls(W.beads[i].x, W.beads[i].y, W.bvx[i], W.bvy[i]);
        W.bvx[i]=out.vx; W.bvy[i]=out.vy;
      }

      // --- TF dynamics (acts 5–7) ---
      if (mode === "polymer_plus_free_tfs" || mode === "two_genes_cluster_one_lonely" || mode === "cluster_attracts_more_tfs"){
        // compute cluster + lonely centers for biasing
        let cx=0, cy=0, cc=0;
        let lx=0, ly=0, lc=0;

        for (let i=0;i<n;i++){
          if (!W.isGene[i]) continue;
          if (W.geneRole[i] === "cluster"){ cx += W.beads[i].x; cy += W.beads[i].y; cc++; }
          if (W.geneRole[i] === "lonely"){ lx += W.beads[i].x; ly += W.beads[i].y; lc++; }
        }
        if (cc>0){ cx/=cc; cy/=cc; }
        if (lc>0){ lx/=lc; ly/=lc; }

        for (const tf of W.tfs){
          tf.vx += P.tfBrown*randn();
          tf.vy += P.tfBrown*randn();
          tf.vx *= P.tfDamp;
          tf.vy *= P.tfDamp;

          // Act 7: gentle bias toward the cluster region + away from lonely region
          if (mode === "cluster_attracts_more_tfs" && tf.mode === "bias"){
            tf.vx += P.tfBiasToCluster*(cx - tf.x);
            tf.vy += P.tfBiasToCluster*(cy - tf.y);

            tf.vx += P.tfBiasAwayLonely*(tf.x - lx);
            tf.vy += P.tfBiasAwayLonely*(tf.y - ly);
          }

          // Act 6: keep TFs near cluster, but leave lonely region quiet
          if (mode === "two_genes_cluster_one_lonely"){
            tf.vx += 0.0010*(cx - tf.x);
            tf.vy += 0.0010*(cy - tf.y);

            tf.vx += 0.0012*(tf.x - lx);
            tf.vy += 0.0012*(tf.y - ly);
          }

          tf.x += tf.vx;
          tf.y += tf.vy;

          const cw=canvas.width, ch=canvas.height;
          if (tf.x<0) tf.x += cw;
          if (tf.x>cw) tf.x -= cw;
          if (tf.y<0) tf.y += ch;
          if (tf.y>ch) tf.y -= ch;
        }
      }

      W.frame++;
    }

    // ============================================================
    // Rendering
    // ============================================================
    function drawPolymer(){
      // polymer line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      W.beads.forEach((p,i)=>{
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads: white + green gene regions
      for (let i=0;i<W.beads.length;i++){
        const p=W.beads[i];
        if (W.isGene[i]){
          glowCircle(p.x,p.y, 6.4, "rgba(0,255,140,0.95)", 28);
        } else {
          glowCircle(p.x,p.y, 4.8, "rgba(255,255,255,0.55)", 16);
        }
      }
    }

    function drawTFs(alpha=1){
      for (const tf of W.tfs){
        glowCircle(tf.x, tf.y, P.tfR, `rgba(255,60,60,${0.78*alpha})`, 22);
      }
    }

    function drawClusterGlow(){
      // derive cluster center glow for acts 6/7
      let cx=0, cy=0, cc=0;
      for (let i=0;i<W.beads.length;i++){
        if (W.geneRole[i] === "cluster"){
          cx += W.beads[i].x;
          cy += W.beads[i].y;
          cc++;
        }
      }
      if (cc>0){
        cx/=cc; cy/=cc;
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        glowCircle(cx, cy, 90, "rgba(255,120,200,0.025)", 110);
        glowCircle(cx, cy, 52, "rgba(255,120,200,0.045)", 80);
        ctx.restore();
      }
    }

    function drawStaticWeb(){
      const cw=canvas.width, ch=canvas.height;

      // big webby chromatin network (static)
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2.2;
      ctx.shadowColor = "rgba(255,255,255,0.10)";
      ctx.shadowBlur = 16;

      // Draw several sinuous strands crisscrossing
      const strands = 9;
      for (let s=0;s<strands;s++){
        ctx.beginPath();
        const y0 = ch*(0.18 + 0.70*(s/(strands-1)));
        for (let i=0;i<240;i++){
          const t=i/239;
          const x = cw*(0.06 + 0.88*t);
          const y = y0 + ch*0.06*Math.sin(8*t + 0.9*s) + ch*0.03*Math.sin(21*t + 0.4*s);
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
      ctx.restore();

      // Hotspots (pink) + TF crowds (red)
      const hubs = [
        {x: cw*0.28, y: ch*0.36},
        {x: cw*0.55, y: ch*0.62},
        {x: cw*0.78, y: ch*0.44}
      ];

      ctx.save();
      ctx.globalCompositeOperation="lighter";
      for (const h of hubs){
        glowCircle(h.x,h.y, 120, "rgba(255,120,200,0.020)", 150);
        glowCircle(h.x,h.y, 65,  "rgba(255,120,200,0.045)", 95);
      }
      ctx.restore();

      // gene hotspots bright green, many quiet greens faint
      function geneSpot(x,y,active){
        const col = active ? "rgba(0,255,140,0.95)" : "rgba(0,255,140,0.18)";
        const blur = active ? 34 : 16;
        glowCircle(x,y, active?8:6, col, blur);
      }

      // Active near hubs
      geneSpot(cw*0.26, ch*0.35, true);
      geneSpot(cw*0.30, ch*0.37, true);
      geneSpot(cw*0.54, ch*0.61, true);
      geneSpot(cw*0.57, ch*0.63, true);
      geneSpot(cw*0.79, ch*0.44, true);

      // Many quiet genes scattered
      for (let i=0;i<22;i++){
        const x = cw*(0.10 + 0.82*Math.random());
        const y = ch*(0.18 + 0.70*Math.random());
        geneSpot(x,y,false);
      }

      // TF crowds near hubs + sparse elsewhere
      function tfCloud(cx,cy,n,spread){
        for (let i=0;i<n;i++){
          const x = cx + spread*randn();
          const y = cy + spread*randn();
          glowCircle(x,y, 6.2, "rgba(255,60,60,0.85)", 22);
        }
      }
      tfCloud(hubs[0].x,hubs[0].y, 28, 30);
      tfCloud(hubs[1].x,hubs[1].y, 26, 30);
      tfCloud(hubs[2].x,hubs[2].y, 20, 28);

      for (let i=0;i<10;i++){
        const x = cw*(0.12 + 0.78*Math.random());
        const y = ch*(0.20 + 0.66*Math.random());
        glowCircle(x,y, 6.0, "rgba(255,60,60,0.25)", 16);
      }

      // labels
      ctx.save();
      ctx.font="900 16px system-ui";
      ctx.fillStyle="rgba(255,255,255,0.88)";
      ctx.fillText("A web of chromatin with hotspots (factories) and quiet regions", 16, 28);
      ctx.font="14px system-ui";
      ctx.fillStyle="rgba(255,255,255,0.62)";
      ctx.fillText("Hotspots: many TFs + active genes • Quiet regions: fewer TFs + less reading", 16, 50);
      ctx.restore();
    }

    function draw(){
      drawBackground();

      const mode = ACTS[act].mode;

      if (mode === "static_web_snapshot"){
        drawStaticWeb();
        return;
      }

      // Acts 4–7: polymer always
      drawPolymer();

      if (mode === "two_genes_cluster_one_lonely" || mode === "cluster_attracts_more_tfs"){
        drawClusterGlow();
      }

      // Act 5: free TFs
      if (mode === "polymer_plus_free_tfs"){
        drawTFs(1.0);
      }

      // Act 6: a few TFs, mostly near cluster and away from lonely region
      if (mode === "two_genes_cluster_one_lonely"){
        drawTFs(0.95);

        // annotate lonely region lightly (optional)
        // (We keep minimal; you can remove these text lines if you want.)
        ctx.save();
        ctx.font="900 14px system-ui";
        ctx.fillStyle="rgba(255,255,255,0.70)";
        ctx.fillText("cluster gene region (more TFs)", 16, canvas.height - 40);
        ctx.fillStyle="rgba(255,255,255,0.55)";
        ctx.fillText("lonely gene region (few TFs)", 16, canvas.height - 18);
        ctx.restore();
      }

      // Act 7: many TFs bias to cluster
      if (mode === "cluster_attracts_more_tfs"){
        drawTFs(1.0);
      }
    }

    function tick(){
      resizeCanvas();
      step();
      draw();
      requestAnimationFrame(tick);
    }

    // Start
    resizeCanvas();
    initAct(true);
    applyAct();
    tick();

    function applyAct(){
      UI.kicker.textContent = `Act ${act} of 8`;
      UI.title.textContent = ACTS[act].title;
      UI.sub.textContent = ACTS[act].sub;
      UI.story.innerHTML = ACTS[act].story;

      UI.prev.disabled = (act === 4);
      UI.next.disabled = (act === 8);

      UI.legend.classList.toggle("show", true);
      initAct(true);
    }
  </script>
</body>
</html>











