<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How do cells remember who they are? | DNA ‚Üí Chromatin ‚Üí BIPS</title>

  <style>
    :root{
      /* =======================
         Lecture-notes theme
         ======================= */
      --page: #fbf7ef;                 /* cream ‚Äúpaper‚Äù */
      --paper: #ffffff;                /* white cards */
      --ink: #1f2937;                  /* main text */
      --muted: #4b5563;                /* secondary text */
      --border: rgba(31,41,55,0.12);   /* soft border */

      /* Figure (animation) window stays dark */
      --figureBg: #0b0b10;
      --figureBorder: rgba(31,41,55,0.18);

      /* Accents (less neon, more academic) */
      --green: #059669;
      --red: #dc2626;
      --pink: #db2777;
      --purple: #7c3aed;

      --maxw: 1100px;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }

    body{
      margin:0;
      background: var(--page);
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    .page{
      min-height: 100vh;
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
    }

    /* TEXT AREA (ABOVE CANVAS) */
    .textPanel{
      width: min(var(--maxw), 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: var(--paper);
      box-shadow: 0 10px 30px rgba(17,24,39,0.10);
      overflow: hidden;
    }

    .textInner{ padding: 18px 18px 14px 18px; }

    .kicker{
      font-weight: 900;
      letter-spacing: 0.2px;
      font-size: 12px;
      color: rgba(31,41,55,0.65);
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .sceneTitle{
      font-weight: 950;
      letter-spacing: -0.4px;
      font-size: clamp(22px, 2.3vw, 30px);
      margin: 0;
      line-height: 1.12;
      color: var(--ink);
    }

    .sceneSub{
      margin-top: 10px;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.65;
    }

    /* learning goal callout */
    .learnGoal{
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(31,41,55,0.12);
      background: rgba(5,150,105,0.06);
      border-left: 4px solid rgba(5,150,105,0.75);
      border-radius: 12px;
      color: rgba(31,41,55,0.88);
      font-size: 14px;
      line-height: 1.55;
      display: none;
    }
    .learnGoal strong{
      color: rgba(5,150,105,0.95);
      font-weight: 950;
    }

    .storyText{
      margin-top: 14px;
      color: rgba(31,41,55,0.92);
      font-size: 16px;
      line-height: 1.78;
    }
    .storyText p{ margin: 12px 0 0 0; }
    .storyText ul{
      margin: 10px 0 0 18px;
      padding: 0;
    }
    .storyText li{ margin: 8px 0; }

    /* nice internal sub-sections (for the combined page) */
    .subBlock{
      margin-top: 14px;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(31,41,55,0.10);
      background: rgba(31,41,55,0.02);
    }
    .subTitle{
      font-weight: 950;
      letter-spacing: -0.2px;
      margin: 0;
      font-size: 15px;
      color: rgba(31,41,55,0.92);
    }
    .subLead{
      margin-top: 6px;
      font-size: 14px;
      line-height: 1.6;
      color: rgba(31,41,55,0.72);
    }

    /* Big clickable glossary-like words */
    .bigClick{
      display:inline-block;
      padding: 4px 10px;
      margin: 0 2px;
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,0.16);
      background: rgba(31,41,55,0.04);
      font-weight: 950;
      letter-spacing: 0.2px;
      text-transform: uppercase;
      font-size: 13px;
      color: rgba(31,41,55,0.92);
      cursor: pointer;
      user-select:none;
      transform: translateY(-1px);
    }
    .bigClick:hover{ background: rgba(31,41,55,0.07); }
    .bigClick.green{ border-color: rgba(5,150,105,0.28); color: var(--green); background: rgba(5,150,105,0.05); }
    .bigClick.purple{ border-color: rgba(124,58,237,0.24); color: var(--purple); background: rgba(124,58,237,0.05); }
    .bigClick.white{ border-color: rgba(31,41,55,0.18); color: rgba(31,41,55,0.92); }

    /* Controls */
    .controls{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      margin-top: 14px;
      flex-wrap: wrap;
    }

    .pill{
      border: 1px solid rgba(31,41,55,0.18);
      background: rgba(255,255,255,0.92);
      color: rgba(31,41,55,0.92);
      padding: 10px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 950;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      user-select:none;
      min-height: 42px;
    }
    .pill:hover{ background: rgba(31,41,55,0.04); }
    .pill.ghost{ background: rgba(255,255,255,0.92); }
    .pill.strong{
      background: rgba(37,99,235,0.10);
      border-color: rgba(37,99,235,0.30);
      color: rgba(37,99,235,0.95);
    }
    .pill:disabled{ opacity: 0.45; cursor: default; }

    /* Mini buttons (Base pair / Gene / Locks) */
    .miniControls{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .miniPill{
      border: 1px solid rgba(31,41,55,0.18);
      background: rgba(31,41,55,0.04);
      color: rgba(31,41,55,0.92);
      padding: 9px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 950;
      font-size: 12px;
      letter-spacing: 0.2px;
      text-transform: uppercase;
      user-select:none;
      min-height: 40px;
    }
    .miniPill:hover{ background: rgba(31,41,55,0.07); }
    .miniPill.white{ border-color: rgba(31,41,55,0.18); }
    .miniPill.green{ border-color: rgba(5,150,105,0.28); color: var(--green); background: rgba(5,150,105,0.05); }
    .miniPill.purple{ border-color: rgba(124,58,237,0.24); color: var(--purple); background: rgba(124,58,237,0.05); }

    /* CANVAS PANEL (dark figure window) */
    .stage{
      width: min(var(--maxw), 100%);
      height: min(62vh, 720px);
      border: 1px solid var(--figureBorder);
      border-radius: 18px;
      overflow: hidden;
      background: var(--figureBg);
      position: relative;
      box-shadow: 0 10px 30px rgba(17,24,39,0.12);
    }

    #stageCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
    }

    /* Image overlay (unused now; kept for compatibility if you want later) */
    .stageImage{
      position:absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
      padding: 14px;
      background: rgba(0,0,0,0.10);
    }
    .stageImage.show{ display:block; }

    .legend{
      position:absolute;
      left: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.80);
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;

      opacity: 0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .legend.show{ opacity: 1; transform: translateY(0); }

    .dot{
      display:inline-block;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .dot.white{ background: rgba(255,255,255,0.85); }
    .dot.green{ background: var(--green); }
    .dot.red{ background: var(--red); }
    .dot.pink{ background: var(--pink); }
    .dot.purple{ background: var(--purple); }

    .dragHint{
      position:absolute;
      right: 12px;
      top: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.82);
      font-size: 12px;
      pointer-events:none;

      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .dragHint.show{ opacity: 1; transform: translateY(0); }

    @media (max-width: 860px){
      .stage{ height: 52vh; }
      .textInner{ padding: 16px 14px 12px 14px; }
      .storyText{ font-size: 16px; }
    }

    /* ============================================================
       Letter / base-pair panel shown under canvas in Acts 2‚Äì3
       ============================================================ */
    .pairPanel{
      width: min(var(--maxw), 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: var(--paper);
      box-shadow: 0 10px 30px rgba(17,24,39,0.08);
      overflow: hidden;
      display: none; /* toggled by JS */
    }
    .pairInner{ padding: 12px 14px 14px 14px; }
    .pairTitleRow{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .pairTitle{
      font-weight: 950;
      letter-spacing: -0.2px;
      font-size: 14px;
      color: rgba(31,41,55,0.88);
    }
    .pairHint{
      font-size: 12px;
      color: rgba(31,41,55,0.62);
      font-weight: 850;
    }

    .pairStripWrap{
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 6px;
    }

    .pairStrip{
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 6px;
      border: 1px solid rgba(31,41,55,0.10);
      border-radius: 14px;
      background: rgba(31,41,55,0.03);
      min-height: 86px;
    }

    .bp{
      width: 34px;
      height: 70px;
      border-radius: 14px;
      border: 1px solid rgba(31,41,55,0.12);
      background: rgba(255,255,255,0.80);
      position: relative;
      display:flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select:none;
      flex: 0 0 auto;
    }

    .bp .top, .bp .bot{
      width: 100%;
      text-align: center;
      font-weight: 950;
      font-size: 18px;
      line-height: 1.0;
      letter-spacing: 0.4px;
      color: rgba(31,41,55,0.88);
    }
    .bp .bot{
      margin-top: 14px;
      color: rgba(31,41,55,0.72);
    }

    /* connector ‚Äúrung‚Äù */
    .bp::after{
      content:"";
      position:absolute;
      left: 50%;
      top: 29px;
      transform: translateX(-50%);
      width: 2px;
      height: 12px;
      border-radius: 99px;
      background: rgba(31,41,55,0.22);
    }

    /* Active single base-pair highlight */
    .bp.active{
      border-color: rgba(37,99,235,0.35);
      background: rgba(37,99,235,0.08);
      box-shadow: 0 0 0 2px rgba(37,99,235,0.06) inset;
    }
    .bp.active .top, .bp.active .bot{ color: rgba(37,99,235,0.95); }
    .bp.active::after{ background: rgba(37,99,235,0.80); }

    /* Gene region highlight */
    .bp.gene{
      border-color: rgba(5,150,105,0.35);
      background: rgba(5,150,105,0.08);
    }
    .bp.gene .top, .bp.gene .bot{ color: rgba(5,150,105,0.95); }
    .bp.gene::after{ background: rgba(5,150,105,0.75); }

    .pairChips{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,0.12);
      background: rgba(31,41,55,0.03);
      color: rgba(31,41,55,0.72);
      font-weight: 900;
      font-size: 12px;
      user-select:none;
    }
    .chip .swatch{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: rgba(37,99,235,0.75);
    }
    .chip.green .swatch{ background: rgba(5,150,105,0.80); }
  </style>
</head>

<body>
  <div class="page">
    <section class="textPanel" aria-label="Story text">
      <div class="textInner">
        <div class="kicker" id="kicker">Page 1 of 6</div>

        <h1 class="sceneTitle" id="sceneTitle">How do cells know who they are?</h1>

        <div class="sceneSub" id="sceneSub">
          Read the story, then look at the figure underneath. Use Next / Prev to move through the pages.
        </div>

        <div class="learnGoal" id="learnGoal"></div>

        <div class="storyText" id="storyText"></div>

        <!-- Mini buttons: shown for DNA + Gene + Locks pages -->
        <div class="miniControls" id="dnaButtons" style="display:none;">
          <button class="miniPill white" id="btnBasepair" type="button">Base pairs</button>
          <button class="miniPill green" id="btnGene" type="button">Gene</button>
          <button class="miniPill purple" id="btnLocks" type="button">Locks</button>
        </div>

        <div class="controls">
          <button class="pill ghost" id="prevBtn" type="button">‚Üê Prev</button>
          <button class="pill ghost" id="resetBtn" type="button" title="Reset this page">‚Üª Reset</button>
          <button class="pill strong" id="nextBtn" type="button">Next ‚Üí</button>
        </div>
      </div>
    </section>

    <section class="stage" aria-label="Figure (animation canvas)">
      <canvas id="stageCanvas"></canvas>

      <!-- kept but not used now -->
      <img id="stageImage" class="stageImage" alt="Page image"/>

      <div class="dragHint" id="dragHint">Drag the big red reader</div>

      <div class="legend" id="legend">
        <span class="dot white"></span> DNA / chromatin (a squiggly chain)
        <span class="dot green"></span> a gene region
        <span class="dot red"></span> reader proteins
        <span class="dot pink"></span> busy hub
        <span class="dot purple"></span> locked DNA
      </div>
    </section>

    <!-- ATCG + pairing panel under the figure (Pages 2‚Äì3 only) -->
    <section class="pairPanel" id="pairPanel" aria-label="DNA letters and base-pairing">
      <div class="pairInner">
        <div class="pairTitleRow">
          <div class="pairTitle">DNA as letters (A, C, G, T) with base-pairing</div>
          <div class="pairHint">A‚ÜîT and C‚ÜîG</div>
        </div>

        <div class="pairStripWrap">
          <div class="pairStrip" id="pairStrip"></div>
        </div>

        <div class="pairChips" aria-hidden="true">
          <span class="chip"><span class="swatch"></span> base pair (click ‚ÄúBase pairs‚Äù)</span>
          <span class="chip green"><span class="swatch"></span> gene region (click ‚ÄúGene‚Äù)</span>
        </div>
      </div>
    </section>
  </div>

  <script>
    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    const stageImage = document.getElementById("stageImage");

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      return { w: canvas.width, h: canvas.height, dpr };
    }

    // RNG helpers
    function randn() {
      let u=0, v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    // ============================================================
    // UI
    // ============================================================
    const sceneTitle = document.getElementById("sceneTitle");
    const sceneSub   = document.getElementById("sceneSub");
    const storyText  = document.getElementById("storyText");
    const kicker     = document.getElementById("kicker");
    const learnGoal  = document.getElementById("learnGoal");

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");

    const legend = document.getElementById("legend");
    const dragHint = document.getElementById("dragHint");

    const dnaButtons = document.getElementById("dnaButtons");
    const btnBasepair = document.getElementById("btnBasepair");
    const btnGene = document.getElementById("btnGene");
    const btnLocks = document.getElementById("btnLocks");

    // ============================================================
    // Letter / base-pair strip under the figure (Pages 2‚Äì3)
    // ============================================================
    const pairPanel = document.getElementById("pairPanel");
    const pairStrip = document.getElementById("pairStrip");

    const DNA_SEQ = "ATGCCATGTTACCGTACGATTCGAGCTAATCG";
    function complement(base){
      if (base === "A") return "T";
      if (base === "T") return "A";
      if (base === "C") return "G";
      if (base === "G") return "C";
      return "?";
    }

    const STRIP_GENE_START = 10;
    const STRIP_GENE_END   = 19;
    const STRIP_BASEPAIR_INDEX = 6;

    function buildPairStrip(){
      pairStrip.innerHTML = "";
      for (let i=0; i<DNA_SEQ.length; i++){
        const top = DNA_SEQ[i];
        const bot = complement(top);

        const bp = document.createElement("div");
        bp.className = "bp";
        bp.dataset.idx = String(i);

        const t = document.createElement("div");
        t.className = "top";
        t.textContent = top;

        const b = document.createElement("div");
        b.className = "bot";
        b.textContent = bot;

        bp.appendChild(t);
        bp.appendChild(b);
        pairStrip.appendChild(bp);
      }
    }

    // ============================================================
    // Clickable words (text) + click-to-highlight (DNA)
    // ============================================================
    let highlight = null; // "basepair" | "gene" | "locks" | null

    document.addEventListener("click", (e) => {
      const el = e.target.closest("[data-click]");
      if (!el) return;
      const id = el.getAttribute("data-click");
      if (id === "basepair") highlight = (highlight === "basepair") ? null : "basepair";
      if (id === "gene")     highlight = (highlight === "gene") ? null : "gene";
      if (id === "locks")    highlight = (highlight === "locks") ? null : "locks";
      updatePairStrip();
    });

    btnBasepair.addEventListener("click", () => {
      highlight = (highlight === "basepair") ? null : "basepair";
      updatePairStrip();
    });
    btnGene.addEventListener("click", () => {
      highlight = (highlight === "gene") ? null : "gene";
      updatePairStrip();
    });
    btnLocks.addEventListener("click", () => {
      highlight = (highlight === "locks") ? null : "locks";
      updatePairStrip();
    });

    function updatePairStrip(){
      // Show only on Page 2 (index 1) and Page 3 (index 2)
      const show = (actIndex === 1 || actIndex === 2);
      pairPanel.style.display = show ? "block" : "none";
      if (!show) return;

      const nodes = pairStrip.querySelectorAll(".bp");
      nodes.forEach(n => { n.classList.remove("active"); n.classList.remove("gene"); });

      if (highlight === "basepair"){
        const el = pairStrip.querySelector(`.bp[data-idx="${STRIP_BASEPAIR_INDEX}"]`);
        if (el) el.classList.add("active");
      }
      if (highlight === "gene"){
        for (let i=STRIP_GENE_START; i<=STRIP_GENE_END; i++){
          const el = pairStrip.querySelector(`.bp[data-idx="${i}"]`);
          if (el) el.classList.add("gene");
        }
      }
    }

    buildPairStrip();

    // ============================================================
    // Acts (pages)
    //  - We KEEP the old structure.
    //  - We simply merge the old 6+7+8 content into ONE final page (Page 6).
    // ============================================================
    let actIndex = 0;
    let mode = "intro"; // intro | dna | locks | act4 | act5 | hub_story

    const ACTS = [
      {
        mode: "intro",
        title: "How do cells know who they are?",
        sub: "Most cells carry the same DNA ‚Äî but they don‚Äôt act the same. Why?",
        goal: "Understand one simple idea: <strong>DNA is the book</strong>, but <strong>access + folding</strong> help decide what gets read.",
        html: `
          <p>
            Imagine every cell owns the <strong>same book</strong>.
            That book is DNA.
          </p>
          <p>
            A skin cell and a neuron have the same book ‚Äî but they do different jobs because they don‚Äôt read the same chapters.
          </p>
          <ul>
            <li><strong>DNA</strong> is written in four letters: A, C, G, T.</li>
            <li><strong>Genes</strong> are the useful ‚Äúsentences‚Äù in the book.</li>
            <li><strong>Locks</strong> can make some chapters hard to open.</li>
            <li><strong>Folding</strong> changes what is nearby and easy to reach.</li>
          </ul>
          <p>
            On the later pages you‚Äôll meet ‚Äúreaders‚Äù (proteins) that are hungry to read ‚Äî and they tend to hang around where there are
            lots of sentences close together.
          </p>
        `,
        showLegend: false
      },
      {
        mode: "dna",
        title: "DNA is a message in four letters",
        sub: "DNA uses a tiny alphabet: A, C, G, T ‚Äî and it comes as a twisted ladder.",
        goal: "Recognise the DNA alphabet and what a <strong>base pair</strong> is.",
        html: `
          <p>
            DNA is written using four letters:
            <strong>A</strong>, <strong>C</strong>, <strong>G</strong>, and <strong>T</strong>.
          </p>
          <p>
            DNA often looks like a twisted ladder.
            Each rung is a matched pair:
            <span class="bigClick white" data-click="basepair">base pair</span>.
            A matches with T, and C matches with G.
          </p>
          <p>
            Click <span class="bigClick white" data-click="basepair">base pair</span> to highlight one rung
            (also shown in the letter strip under the figure).
          </p>
        `,
        showLegend: false
      },
      {
        mode: "dna",
        title: "A gene is a useful stretch of DNA",
        sub: "If letters are the alphabet, a gene is a sentence the cell can copy and use.",
        goal: "See a <strong>gene</strong> as a continuous stretch of DNA letters.",
        html: `
          <p>
            A <span class="bigClick green" data-click="gene">gene</span> is a stretch of DNA that the cell can copy into RNA,
            and often use to build proteins.
          </p>
          <p>
            Different cell types read different genes more often.
            That‚Äôs a big part of what makes them different.
          </p>
          <p>
            Click <span class="bigClick green" data-click="gene">gene</span> to highlight one gene-sized region.
          </p>
        `,
        showLegend: false
      },
      {
        mode: "locks",
        title: "Some chapters are harder to open",
        sub: "Cells can ‚Äòlock‚Äô parts of DNA to make them less reachable.",
        goal: "Understand locks as a simple way to change <strong>access</strong> (easy vs hard to read).",
        html: `
          <p>
            Cells can place chemical marks that make some DNA regions more ‚Äúclosed‚Äù.
            Think of it like putting a <span class="bigClick purple" data-click="locks">lock</span> on a chapter.
          </p>
          <p>
            Locked regions are not gone ‚Äî they‚Äôre just harder for the cell‚Äôs readers to use.
          </p>
          <p>
            Click <span class="bigClick purple" data-click="locks">locks</span> to emphasise the purple locked zones.
          </p>
          <p>
            Now zoom out: DNA is also a physical object. It folds in 3D.
          </p>
        `,
        showLegend: false
      },
      {
        mode: "act4",
        title: "Zoom out: DNA becomes a moving chain",
        sub: "Inside the nucleus, DNA is packed as chromatin: a flexible chain that wriggles and folds.",
        goal: "See chromatin as a <strong>wiggly chain</strong> that can fold and rearrange.",
        html: `
          <p>
            DNA is extremely long, so it gets packed up with proteins into <strong>chromatin</strong>.
          </p>
          <p>
            In this cartoon, chromatin is drawn as a chain of beads.
            It moves and wiggles ‚Äî like a soft thread floating in a busy room.
          </p>
          <p>
            <strong>Try it:</strong> drag the chain and fold it a bit.
          </p>
        `,
        showLegend: true
      },
      {
        mode: "hub_story",
        title: "Hungry readers and their Busy Hub",
        sub: "Readers wander, a hub can form, and then more readers drift to the busiest spot.",
        goal: "Learn one simple loop: <strong>dense DNA</strong> makes a place easier to read, so readers tend to gather there.",
        html: `
          <p>
            Now meet the <strong>readers</strong> (red): proteins that help read genes.
            Imagine they are <strong>hungry to read</strong>.
            They roam around looking for good places to spend their time.
          </p>

          <div class="subBlock">
            <h3 class="subTitle">Part 1: Readers wander around</h3>
            <div class="subLead">At first, they mostly drift and bump around randomly.</div>
            <p>
              That wandering is normal ‚Äî it‚Äôs like people walking around a library looking for the best desk.
            </p>
          </div>

          <div class="subBlock">
            <h3 class="subTitle">Part 2: A ‚Äúbusy hub‚Äù can form</h3>
            <div class="subLead">If one big hungry reader grabs DNA well, nearby DNA gathers into a crowded spot.</div>
            <p>
              <strong>Try it:</strong> drag the big red reader.
              The DNA chain should gather and stay clustered around it ‚Äî like bringing lots of sentences into one place.
            </p>
          </div>

          <div class="subBlock">
            <h3 class="subTitle">Part 3: More readers drift to the busiest spot</h3>
            <div class="subLead">Where DNA is densest, hungry readers are most likely to hang around.</div>
            <p>
              Once a hub exists, more readers tend to drift toward it and linger.
              Other regions get fewer visits.
              Over time, that kind of bias can help the same genes get read again and again ‚Äî which helps a cell keep its identity.
            </p>
            <p style="opacity:0.86;">
              (Some scientists call these busy hubs ‚Äútranscription factories‚Äù, but you don‚Äôt need that phrase here.)
            </p>
          </div>
        `,
        showLegend: true
      }
    ];

    function applyAct(i){
      actIndex = clamp(i, 0, ACTS.length - 1);
      const A = ACTS[actIndex];

      mode = A.mode;
      highlight = null;

      kicker.textContent = `Page ${actIndex + 1} of ${ACTS.length}`;
      sceneTitle.textContent = A.title;
      sceneSub.textContent = A.sub;
      storyText.innerHTML = A.html;

      // learning goal
      if (A.goal && A.goal.trim().length > 0){
        learnGoal.innerHTML = `<strong>Learning goal:</strong> ${A.goal.replace(/^Learning goal:\s*/i,"")}`;
        learnGoal.style.display = "block";
      } else {
        learnGoal.style.display = "none";
        learnGoal.textContent = "";
      }

      prevBtn.disabled = (actIndex === 0);
      nextBtn.disabled = (actIndex === ACTS.length - 1);

      // Reset button only for polymer pages (Page 5 and Page 6 here: act4 + hub_story)
      resetBtn.style.display = (mode === "act4" || mode === "hub_story") ? "inline-flex" : "none";

      // drag hint
      dragHint.classList.toggle("show", mode === "hub_story");

      if (A.showLegend) legend.classList.add("show");
      else legend.classList.remove("show");

      // Mini buttons visibility logic:
      const showMini = (mode === "dna" || mode === "locks");
      dnaButtons.style.display = showMini ? "flex" : "none";

      btnBasepair.style.display = "none";
      btnGene.style.display = "none";
      btnLocks.style.display = "none";

      if (actIndex === 1) { // DNA
        btnBasepair.style.display = "inline-block";
      } else if (actIndex === 2) { // Gene
        btnBasepair.style.display = "inline-block";
        btnGene.style.display = "inline-block";
      } else if (actIndex === 3) { // Locks
        btnLocks.style.display = "inline-block";
      }

      // no image overlay in this version (we keep the canvas always)
      stageImage.classList.remove("show");
      stageImage.removeAttribute("src");
      canvas.style.display = "block";

      updatePairStrip();
      initActWorld(true);
    }

    prevBtn.addEventListener("click", () => applyAct(actIndex - 1));
    nextBtn.addEventListener("click", () => applyAct(actIndex + 1));
    resetBtn.addEventListener("click", () => initActWorld(true));

    // ============================================================
    // Drawing helpers
    // ============================================================
    function drawBackground(){
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = "rgba(255,255,255,0.015)";
      for (let i=0;i<110;i++){
        const x=(i*131)%canvas.width;
        const y=(i*193)%canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }

    function glowCircle(x,y,r,color,blur=18){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function roundRect(x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // ============================================================
    // Intro flowchart on the canvas (Page 1)
    // ============================================================
    function drawIntroFlowchart(){
      const W = canvas.width, H = canvas.height;
      const pad = Math.min(W,H)*0.07;

      const boxes = [
        {x: pad, y: H*0.22, w: W*0.28, h: H*0.18, label:"DNA letters\n(A,C,G,T)"},
        {x: W*0.36, y: H*0.22, w: W*0.28, h: H*0.18, label:"Genes\n(sentences)"},
        {x: W*0.68, y: H*0.22, w: W*0.28 - pad, h: H*0.18, label:"Locks\n(harder to open)"},
        {x: W*0.20, y: H*0.56, w: W*0.30, h: H*0.18, label:"Folding\n(3D chain)"},
        {x: W*0.54, y: H*0.56, w: W*0.30, h: H*0.18, label:"Busy hubs\n(reading spots)"},
      ];

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.40)";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";

      function arrow(x1,y1,x2,y2){
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        const ang = Math.atan2(y2-y1, x2-x1);
        const ah = 10;
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - ah*Math.cos(ang-0.35), y2 - ah*Math.sin(ang-0.35));
        ctx.lineTo(x2 - ah*Math.cos(ang+0.35), y2 - ah*Math.sin(ang+0.35));
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.45)";
        ctx.fill();
      }

      arrow(boxes[0].x+boxes[0].w, boxes[0].y+boxes[0].h*0.5, boxes[1].x, boxes[1].y+boxes[1].h*0.5);
      arrow(boxes[1].x+boxes[1].w, boxes[1].y+boxes[1].h*0.5, boxes[2].x, boxes[2].y+boxes[2].h*0.5);

      arrow(boxes[0].x+boxes[0].w*0.5, boxes[0].y+boxes[0].h, boxes[3].x+boxes[3].w*0.35, boxes[3].y);
      arrow(boxes[2].x+boxes[2].w*0.5, boxes[2].y+boxes[2].h, boxes[4].x+boxes[4].w*0.65, boxes[4].y);
      arrow(boxes[3].x+boxes[3].w, boxes[3].y+boxes[3].h*0.5, boxes[4].x, boxes[4].y+boxes[4].h*0.5);

      ctx.restore();

      for (let i=0;i<boxes.length;i++){
        const b = boxes[i];
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.lineWidth = 2;
        roundRect(b.x, b.y, b.w, b.h, 16, true, true);

        const accent =
          (i===0) ? "rgba(255,255,255,0.55)" :
          (i===1) ? "rgba(0,255,140,0.55)" :
          (i===2) ? "rgba(190,120,255,0.55)" :
          (i===3) ? "rgba(255,255,255,0.40)" :
                   "rgba(255,120,200,0.50)";
        ctx.fillStyle = accent;
        roundRect(b.x+10, b.y+10, 10, b.h-20, 8, true, false);

        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "950 16px system-ui";
        const lines = b.label.split("\n");
        let ty = b.y + b.h*0.50 - (lines.length-1)*10;
        for (const line of lines){
          ctx.fillText(line, b.x + 28, ty);
          ty += 22;
        }
        ctx.restore();
      }

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "900 13px system-ui";
      ctx.fillText("Figure: book (DNA) + access + folding ‚Üí busy hubs ‚Üí biased reading", pad, H*0.90);
      ctx.restore();
    }

    // ============================================================
    // DNA helix (pages: dna + locks)
    // ============================================================
    function drawDNAHelix(){
      const W = canvas.width, H = canvas.height;
      const cx = W * 0.52;
      const cy = H * 0.56;
      const amp = H * 0.14;
      const pitch = W * 0.022;
      const turns = 44;
      const tNow = performance.now() * 0.0016;

      const baseHi = (highlight === "basepair");
      const geneHi = (highlight === "gene");
      const lockHi = (highlight === "locks");

      const geneStart = 15;
      const geneEnd   = 24;

      const lockSegments = [
        { a: 7,  b: 12 },
        { a: 28, b: 33 }
      ];

      function isLocked(i){
        for (const seg of lockSegments){
          if (i >= seg.a && i <= seg.b) return true;
        }
        return false;
      }

      if (mode === "locks") {
        ctx.save();
        ctx.globalAlpha = lockHi ? 0.28 : 0.20;
        ctx.fillStyle = "rgba(170, 90, 255, 1)";
        const x0 = cx - (turns*pitch)/2;
        for (const seg of lockSegments){
          const xa = x0 + seg.a*pitch - pitch*0.6;
          const xb = x0 + seg.b*pitch + pitch*0.6;
          roundRect(xa, cy - amp*1.35, (xb-xa), amp*2.7, 16, true, false);
        }
        ctx.restore();
      }

      for (let i=0;i<turns;i++){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);

        const inGene = (i>=geneStart && i<=geneEnd);
        const locked = isLocked(i);

        let rungColor = "rgba(255,255,255,0.20)";
        let rungWidth = 2.0;

        if (geneHi && inGene) { rungColor = "rgba(0,255,140,0.92)"; rungWidth = 3.0; }
        else if (baseHi && (i%4===0)) { rungColor = "rgba(255,255,255,0.92)"; rungWidth = 3.0; }

        if (mode === "locks" && locked) {
          rungColor = lockHi ? "rgba(230, 200, 255, 0.95)" : "rgba(230, 200, 255, 0.55)";
          rungWidth = lockHi ? 3.0 : 2.2;
        }

        ctx.save();
        ctx.strokeStyle = rungColor;
        ctx.lineWidth = rungWidth;
        ctx.beginPath();
        ctx.moveTo(x,y1);
        ctx.lineTo(x,y2);
        ctx.stroke();
        ctx.restore();

        let backboneColor = "rgba(255,255,255,0.55)";
        if (geneHi && inGene) backboneColor = "rgba(0,255,140,0.65)";
        if (mode === "locks" && locked) backboneColor = lockHi ? "rgba(190, 120, 255, 0.80)" : "rgba(190, 120, 255, 0.50)";

        glowCircle(x, y1, 5.0, backboneColor, 18);
        glowCircle(x, y2, 5.0, backboneColor, 18);

        if (mode === "locks" && locked && (i % 3 === 0)) {
          ctx.save();
          ctx.font = "950 14px system-ui";
          ctx.fillStyle = lockHi ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.70)";
          ctx.shadowColor = "rgba(190,120,255,0.55)";
          ctx.shadowBlur = 16;
          ctx.fillText("üîí", x - 7, (0.5*(y1+y2)) + 5);
          ctx.restore();
        }
      }
    }

    // ============================================================
    // Polymer worlds for pages 5‚Äì6
    //  - act4: drag chain
    //  - hub_story: big TF hub + extra TFs drift in, and chain STAYS clustered
    // ============================================================
    const world = {
      initialised: false,
      beads: [],
      bvx: [],
      bvy: [],
      tfs: [],
      frame: 0
    };

    const P = {
      beadCount: 210,
      restLen: 9,
      kSpring: 0.18,
      kBend: 0.010,
      damping: 0.92,
      beadR: 4.6,
      repelK: 0.55
    };

    const bigTF = { x: 0, y: 0, vx: 0, vy: 0, radius: 34 };
    let draggingTF = false;
    let dragOffset = {x:0, y:0};

    let draggingBead = { active:false, idx:-1 };
    let beadDragK = 0.020;

    function mouseToCanvas(e){
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left);
      const sy = (e.clientY - rect.top);
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: sx * scaleX, y: sy * scaleY };
    }
    function pointerPos(e){ return mouseToCanvas(e); }

    function findNearestBead(px, py, maxDist){
      let best = {idx:-1, d2: maxDist*maxDist};
      for (let i=0;i<world.beads.length;i++){
        const b = world.beads[i];
        const dx = b.x - px, dy = b.y - py;
        const d2 = dx*dx + dy*dy;
        if (d2 < best.d2){
          best = {idx:i, d2};
        }
      }
      return best.idx;
    }

    const lastPointer = {x:0,y:0};

    canvas.addEventListener("pointerdown", (e) => {
      const p = pointerPos(e);

      // hub page: drag the big reader
      if (mode === "hub_story"){
        const dx = p.x - bigTF.x;
        const dy = p.y - bigTF.y;
        if (Math.sqrt(dx*dx+dy*dy) < bigTF.radius*1.15){
          draggingTF = true;
          dragOffset.x = dx;
          dragOffset.y = dy;
          canvas.setPointerCapture(e.pointerId);
          return;
        }
      }

      // chain page: drag beads
      if (mode === "act4"){
        const idx = findNearestBead(p.x, p.y, 26);
        if (idx !== -1){
          draggingBead.active = true;
          draggingBead.idx = idx;
          canvas.setPointerCapture(e.pointerId);
        }
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      const p = pointerPos(e);

      if (draggingTF){
        bigTF.x = p.x - dragOffset.x;
        bigTF.y = p.y - dragOffset.y;
        return;
      }
      lastPointer.x = p.x;
      lastPointer.y = p.y;
    });

    function stopDragging(){
      draggingTF = false;
      draggingBead.active = false;
      draggingBead.idx = -1;
    }
    canvas.addEventListener("pointerup", stopDragging);
    canvas.addEventListener("pointercancel", stopDragging);

    let extraTFs = []; // extra readers drifting in on hub page

    function initActWorld(force=false){
      const polymerModes = ["act4","hub_story"];
      if (!polymerModes.includes(mode)) return;

      if (world.initialised && !force) return;

      world.initialised = true;
      world.frame = 0;
      resizeCanvas();
      const W = canvas.width, H = canvas.height;

      world.beads = [];
      world.bvx = new Array(P.beadCount).fill(0);
      world.bvy = new Array(P.beadCount).fill(0);

      const startX = W * 0.10;
      const midY = H * 0.56;

      for (let i=0;i<P.beadCount;i++){
        const x = startX + i*P.restLen;
        const y = midY + (H*0.06)*Math.sin(i*0.17) + (H*0.02)*randn();
        world.beads.push({x,y});
      }

      // act4: pre-fold a little so dragging feels nice
      if (mode === "act4"){
        const a1 = {x: W*0.44, y: H*0.50};
        const a2 = {x: W*0.60, y: H*0.62};

        for (let i=0;i<P.beadCount;i++){
          const p = world.beads[i];
          const t = i/(P.beadCount-1);

          const w1 = Math.exp(-Math.pow((t-0.25)/0.14,2));
          const w2 = Math.exp(-Math.pow((t-0.50)/0.14,2));
          const w3 = Math.exp(-Math.pow((t-0.75)/0.14,2));

          const ax = a1.x*w1 + a2.x*w2 + a1.x*w3;
          const ay = a1.y*w1 + a2.y*w2 + a1.y*w3;

          const w = 0.55*(w1+w2+w3);
          p.x = p.x*(1-w) + ax*w;
          p.y = p.y*(1-w) + ay*w;
        }
        for (let i=0;i<P.beadCount;i++){
          const p = world.beads[i];
          const t = i/(P.beadCount-1);
          p.y += (H*0.05)*Math.sin(10*t);
        }
      }

      // hub page: place big reader and start with DNA already somewhat gathered
      if (mode === "hub_story"){
        bigTF.x = W*0.58;
        bigTF.y = H*0.54;
        bigTF.vx = 0; bigTF.vy = 0;

        // gently pre-wrap a mid region around the reader so it looks ‚Äúhubby‚Äù immediately
        const center = {x: bigTF.x, y: bigTF.y};
        const R0 = bigTF.radius * 1.10;
        const R1 = bigTF.radius * 3.8;

        for (let i=0;i<P.beadCount;i++){
          const t = i/(P.beadCount-1);
          const w = Math.exp(-Math.pow((t-0.52)/0.22,2));
          if (w < 0.10) continue;

          const angle = (i*0.36);
          const r = (R0 + (R1-R0)*(0.5+0.5*Math.sin(i*0.07))) * (0.6 + 0.5*w);
          const targetX = center.x + r*Math.cos(angle);
          const targetY = center.y + r*Math.sin(angle);

          world.beads[i].x = world.beads[i].x*(1-w) + targetX*w;
          world.beads[i].y = world.beads[i].y*(1-w) + targetY*w;
        }

        // extra readers drift in
        extraTFs = [];
        const count = 7;
        for (let i=0;i<count;i++){
          extraTFs.push({
            x: W*(0.12 + 0.76*Math.random()),
            y: H*(0.18 + 0.64*Math.random()),
            vx: 0, vy: 0,
            radius: 26 + 6*Math.random()
          });
        }
      }
    }

    function springForce(ax, ay, bx, by, rest, k){
      const dx=bx-ax, dy=by-ay;
      const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
      const f=k*(r-rest);
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function bendForce(p0,p1,p2,kB){
      const mx=0.5*(p0.x+p2.x);
      const my=0.5*(p0.y+p2.y);
      return {fx:kB*(mx-p1.x), fy:kB*(my-p1.y)};
    }
    function repelPair(ax, ay, bx, by, minDist, k){
      const dx=bx-ax, dy=by-ay;
      const r2=dx*dx+dy*dy+1e-6;
      const r=Math.sqrt(r2);
      if (r>=minDist) return {fx:0, fy:0};
      const overlap=minDist-r;
      const f=k*overlap;
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function softWalls(x,y,vx,vy){
      const W=canvas.width, H=canvas.height;
      const margin=70;
      const k=0.0018;
      if (x<margin) vx += k*(margin-x);
      if (x>W-margin) vx -= k*(x-(W-margin));
      if (y<margin) vy += k*(margin-y);
      if (y>H-margin) vy -= k*(y-(H-margin));
      return {vx,vy};
    }

    // "hub pull": keeps DNA gathered near the big reader
    function hubPullForce(p, tf, strength){
      const dx=tf.x - p.x;
      const dy=tf.y - p.y;
      const d=Math.sqrt(dx*dx+dy*dy)+1e-6;

      const attractR = tf.radius * 4.2;
      const repelR   = tf.radius * 1.10;

      let fx=0, fy=0;
      if (d < repelR){
        const push = (repelR - d) * (0.10 * strength);
        fx -= push * dx/d;
        fy -= push * dy/d;
      } else if (d < attractR){
        const s = (1 - d/attractR);
        const pull = (0.010 * strength) * s;
        fx += pull * dx;
        fy += pull * dy;
      }
      return {fx, fy};
    }

    function stepPolymer(){
      world.frame++;
      const n = P.beadCount;

      // springs
      for (let i=0;i<n-1;i++){
        const a=world.beads[i], b=world.beads[i+1];
        const f=springForce(a.x,a.y,b.x,b.y,P.restLen,P.kSpring);
        world.bvx[i] += f.fx; world.bvy[i] += f.fy;
        world.bvx[i+1] -= f.fx; world.bvy[i+1] -= f.fy;
      }
      // bending
      for (let i=1;i<n-1;i++){
        const f=bendForce(world.beads[i-1], world.beads[i], world.beads[i+1], P.kBend);
        world.bvx[i] += f.fx;
        world.bvy[i] += f.fy;
      }
      // self-avoidance
      const minBB = 2*P.beadR;
      for (let i=0;i<n;i++){
        const i0=Math.max(0,i-14);
        const i1=Math.min(n-1,i+14);
        for (let j=i0;j<=i1;j++){
          if (j===i) continue;
          if (Math.abs(i-j)<=1) continue;
          const a=world.beads[i], b=world.beads[j];
          const f=repelPair(a.x,a.y,b.x,b.y,minBB,0.55);
          world.bvx[i] -= f.fx; world.bvy[i] -= f.fy;
          world.bvx[j] += f.fx; world.bvy[j] += f.fy;
        }
      }

      // drag bead on act4
      if (mode === "act4" && draggingBead.active && draggingBead.idx >= 0){
        const i = draggingBead.idx;
        const b = world.beads[i];
        const dx = (lastPointer.x - b.x);
        const dy = (lastPointer.y - b.y);
        world.bvx[i] += beadDragK * dx;
        world.bvy[i] += beadDragK * dy;
      }

      // hub pull on hub page (THIS is what stops the chain ‚Äúrelaxing away‚Äù)
      if (mode === "hub_story"){
        const strength = 0.7; // strong enough to keep it clustered
        for (let i=0;i<n;i++){
          const p=world.beads[i];
          const f = hubPullForce(p, bigTF, strength);
          world.bvx[i] += f.fx;
          world.bvy[i] += f.fy;
        }
      }

      // Brownian wiggle
      let brown = 0.16;
      if (mode === "act4")     brown = 0.22;
      if (mode === "hub_story") brown = 0.006; // low so the hub stays

      for (let i=0;i<n;i++){
        world.bvx[i] += brown*randn();
        world.bvy[i] += brown*randn();
        world.bvx[i] *= P.damping;
        world.bvy[i] *= P.damping;

        world.beads[i].x += world.bvx[i];
        world.beads[i].y += world.bvy[i];

        const out=softWalls(world.beads[i].x, world.beads[i].y, world.bvx[i], world.bvy[i]);
        world.bvx[i]=out.vx; world.bvy[i]=out.vy;
      }

      // extra readers drift into the hub on hub page
      if (mode === "hub_story"){
        const W=canvas.width, H=canvas.height;
        const target = {x: bigTF.x, y: bigTF.y};
        for (const tf of extraTFs){
          tf.vx += 0.12*randn();
          tf.vy += 0.12*randn();

          // hungry drift toward ‚Äúmost sentences‚Äù
          tf.vx += 0.0019*(target.x - tf.x);
          tf.vy += 0.0019*(target.y - tf.y);

          tf.vx *= 0.88;
          tf.vy *= 0.88;
          tf.x += tf.vx;
          tf.y += tf.vy;

          if (tf.x<0) tf.x += W;
          if (tf.x>W) tf.x -= W;
          if (tf.y<0) tf.y += H;
          if (tf.y>H) tf.y -= H;
        }
      }
    }

    function drawPolymerAndTFs(){
      // chain line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      world.beads.forEach((p,i)=>{
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads
      for (const p of world.beads){
        glowCircle(p.x,p.y, 4.6, "rgba(255,255,255,0.52)", 15);
      }

      if (mode === "hub_story"){
        // hub glow
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        glowCircle(bigTF.x, bigTF.y, bigTF.radius*5.2, "rgba(255,120,200,0.018)", 170);
        glowCircle(bigTF.x, bigTF.y, bigTF.radius*2.8, "rgba(255,60,60,0.018)", 130);
        ctx.restore();

        glowCircle(bigTF.x, bigTF.y, bigTF.radius, "rgba(255,60,60,0.92)", 44);

        for (const tf of extraTFs){
          glowCircle(tf.x, tf.y, tf.radius, "rgba(255,60,60,0.55)", 28);
        }
      }
    }

    // ============================================================
    // Main tick
    // ============================================================
    function tick(){
      resizeCanvas();

      drawBackground();

      if (mode === "intro"){
        drawIntroFlowchart();
      } else if (mode === "dna" || mode === "locks"){
        drawDNAHelix();
      } else if (mode === "act4" || mode === "hub_story"){
        initActWorld(false);
        stepPolymer();
        drawPolymerAndTFs();
      }

      requestAnimationFrame(tick);
    }

    // ============================================================
    // Init / resize
    // ============================================================
    window.addEventListener("resize", () => {
      resizeCanvas();
      initActWorld(true);
    });

    resizeCanvas();
    applyAct(0);
    tick();
  </script>
</body>
</html>









































