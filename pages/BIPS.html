<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BIPS Explainer | Nishwal Gora</title>

  <link rel="stylesheet" href="../stylesheets/bips_style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body class="dark">

  <!-- Header / nav -->
  <header class="site-header">
    <div class="header-inner">
      <a class="brand" href="../index.html">Nishwal Gora</a>
      <nav class="site-nav">
        <ul class="nav-pill">
          <li><a href="../index.html">Home</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="cv.html">CV</a></li>
          <li><a href="about.html">About Me</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="more.html">More</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Main scene -->
  <main class="player">

    <!-- Canvas stage -->
    <section class="stage-wrap">
      <canvas id="stageCanvas"></canvas>

      <!-- HUD / controls (CLICKABLE) -->
      <div class="hud" id="hud">
        <div class="hud-title" id="hudTitle">DNA</div>
        <div class="hud-sub" id="hudSub">Use Next → to step through</div>

        <div class="hud-controls">
          <div class="row">
            <button id="backBtn" type="button" aria-label="Back">← Back</button>
            <button id="nextBtn" type="button" aria-label="Next">Next →</button>
          </div>

          <div class="row">
            <button id="resetBtn" type="button">Reset</button>
            <button id="spawnBtn" type="button">Spawn TF</button>
          </div>

          <label class="slider">
            <span>Stickiness</span>
            <input id="stickiness" type="range" min="0" max="100" value="45" />
            <span class="val" id="stickVal">0.45</span>
          </label>

          <label class="slider">
            <span>TF count</span>
            <input id="tfCount" type="range" min="5" max="80" value="35" />
            <span class="val" id="tfVal">35</span>
          </label>

          <div class="tiny" id="statsLine">bridges: 0 • bound TFs: 0</div>
          <div class="tiny">Drag: TFs (red) + chromatin beads (white). TUs are green.</div>
        </div>
      </div>
    </section>

    <!-- Text panel (slide content) -->
    <section class="panel">
      <article class="card">
        <h1 id="slideHeading">DNA</h1>
        <p id="slideText">
          DNA is a long molecule made from four “letters”: A, C, G, T.
          The order stores biological information.
        </p>

        <div class="legend">
          <div class="chip"><span class="dot white"></span> Chromatin (polymer)</div>
          <div class="chip"><span class="dot green"></span> TU / binding site</div>
          <div class="chip"><span class="dot red"></span> TF (sticky particle)</div>
        </div>

        <div class="hint" id="slideHint">Click Next →</div>
      </article>
    </section>

  </main>

  <footer class="footer">
    <div class="social-links">
      <a href="https://www.linkedin.com/in/nishwal-gora/" class="fa fa-linkedin" target="_blank" rel="noopener noreferrer"></a>
      <a href="https://github.com/Nishwal-G" class="fa fa-github" target="_blank" rel="noopener noreferrer"></a>
    </div>
  </footer>

  <script>
    // ============================================================
    // Slides (button controlled, not scroll)
    // ============================================================
    const SLIDES = [
      {
        key: "dna",
        title: "DNA",
        text: "DNA is a long molecule made from four “letters”: A, C, G, T. The order stores biological information.",
        hint: "Next: genes →",
        mode: "dna"
      },
      {
        key: "genes",
        title: "Genes",
        text: "A gene is a segment of DNA that can be read. Different cells turn different genes ON and OFF.",
        hint: "Next: packing →",
        mode: "dna"
      },
      {
        key: "chromatin",
        title: "Chromatin (DNA + proteins)",
        text: "When DNA is packaged with proteins it forms chromatin. Physically, chromatin behaves like a moving polymer chain.",
        hint: "Try dragging the chain.",
        mode: "chromatin"
      },
      {
        key: "tfs",
        title: "Transcription factors (TFs)",
        text: "TFs are sticky proteins that diffuse around and bind specific DNA sites (green beads). They can bind and unbind.",
        hint: "Try dragging TFs (red).",
        mode: "tfs"
      },
      {
        key: "bips",
        title: "BIPS: bridging-induced phase separation",
        text: "If a TF can bind two sites, it forms a bridge. Bridges pull chromatin together, increasing local density → more binding → clusters.",
        hint: "Turn up stickiness / TF count and watch clusters emerge.",
        mode: "bips"
      },
      {
        key: "takehome",
        title: "Take-home",
        text: "DNA isn’t only a code — it’s also a physical object. Folding + bridging can create hubs that may help cells ‘remember’ which genes to use.",
        hint: "You can keep playing with the sliders!",
        mode: "bips"
      }
    ];

    let slideIndex = 0;

    const slideHeading = document.getElementById("slideHeading");
    const slideText = document.getElementById("slideText");
    const slideHint = document.getElementById("slideHint");

    const hudTitle = document.getElementById("hudTitle");
    const hudSub = document.getElementById("hudSub");

    const backBtn = document.getElementById("backBtn");
    const nextBtn = document.getElementById("nextBtn");

    function applySlide(i) {
      slideIndex = Math.max(0, Math.min(SLIDES.length - 1, i));
      const s = SLIDES[slideIndex];

      slideHeading.textContent = s.title;
      slideText.textContent = s.text;
      slideHint.textContent = s.hint;

      hudTitle.textContent = s.key.toUpperCase();
      hudSub.textContent = "Use Next → to step through";

      // set simulation mode
      scene = s.mode;

      backBtn.disabled = (slideIndex === 0);
      nextBtn.disabled = (slideIndex === SLIDES.length - 1);
    }

    backBtn.addEventListener("click", () => applySlide(slideIndex - 1));
    nextBtn.addEventListener("click", () => applySlide(slideIndex + 1));

    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvasToDisplaySize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      return { w, h, dpr };
    }
    window.addEventListener("resize", resizeCanvasToDisplaySize);

    // ============================================================
    // UI controls (sliders were not movable before; this fixes it)
    // ============================================================
    const resetBtn = document.getElementById("resetBtn");
    const spawnBtn = document.getElementById("spawnBtn");
    const stickSlider = document.getElementById("stickiness");
    const stickVal = document.getElementById("stickVal");
    const tfCountSlider = document.getElementById("tfCount");
    const tfVal = document.getElementById("tfVal");
    const statsLine = document.getElementById("statsLine");

    // ============================================================
    // Params (longer chromatin + colours)
    // ============================================================
    const params = {
      stickiness: 0.45,
      tfTargetCount: 35,

      // longer chromatin
      beadCount: 110,
      restLen: 12,
      kSpring: 0.18,
      kBend: 0.012,
      damping: 0.92,
      brownianChain: 0.22,

      // TFs
      tfRadius: 7.5,
      brownianTF: 0.95,
      tfDamping: 0.94,

      // binding
      bindRadius: 16,
      baseBindRate: 0.020,
      baseUnbindRate: 0.004,

      // feedback
      feedbackRadius: 110,
      feedbackBoostMax: 3.2
    };

    function updateUI() {
      params.stickiness = Number(stickSlider.value) / 100;
      params.tfTargetCount = Number(tfCountSlider.value);
      stickVal.textContent = params.stickiness.toFixed(2);
      tfVal.textContent = params.tfTargetCount.toString();
    }
    stickSlider.addEventListener("input", updateUI);
    tfCountSlider.addEventListener("input", updateUI);
    updateUI();

    // ============================================================
    // RNG helpers
    // ============================================================
    function rand() { return Math.random(); }
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = rand();
      while (v === 0) v = rand();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // ============================================================
    // World state
    // ============================================================
    let scene = "dna"; // dna | chromatin | tfs | bips

    const world = {
      beads: [],   // {x,y,vx,vy,isTU}
      tfs: [],     // {x,y,vx,vy,bindA,bindB}
      bridges: []  // {a,b,tfIndex}
    };

    function spawnTF() {
      const W = canvas.width, H = canvas.height;
      world.tfs.push({
        x: W*(0.25 + 0.5*rand()),
        y: H*(0.20 + 0.6*rand()),
        vx: 0, vy: 0,
        bindA: null, bindB: null
      });
    }

    function initWorld() {
      resizeCanvasToDisplaySize();
      const W = canvas.width, H = canvas.height;

      world.beads = [];
      world.tfs = [];
      world.bridges = [];

      // Start polymer in a gentle zig-zag across the screen
      const startX = W * 0.12;
      const startY = H * 0.55;

      for (let i = 0; i < params.beadCount; i++) {
        const x = startX + i * params.restLen;
        const y = startY + (H * 0.06) * Math.sin(i * 0.25);

        // TUs = green sites (every ~10 beads)
        const isTU = (i % 10 === 0);

        world.beads.push({ x, y, vx: 0, vy: 0, isTU });
      }

      // Spawn TFs
      for (let i = 0; i < params.tfTargetCount; i++) spawnTF();
    }

    function maintainTFCount() {
      const target = params.tfTargetCount;
      while (world.tfs.length < target) spawnTF();
      while (world.tfs.length > target) world.tfs.pop();
    }

    resetBtn.addEventListener("click", initWorld);
    spawnBtn.addEventListener("click", spawnTF);

    // ============================================================
    // Mouse interactions: drag beads / TFs
    // ============================================================
    let mouse = { x: 0, y: 0, down: false };
    let grab = { type: null, index: -1, offx: 0, offy: 0 };

    function getMousePos(evt){
      const rect = canvas.getBoundingClientRect();
      const dpr = canvas.width / rect.width;
      return {
        x: (evt.clientX - rect.left) * dpr,
        y: (evt.clientY - rect.top) * dpr
      };
    }

    canvas.addEventListener("mousedown", (e) => {
      mouse.down = true;
      const p = getMousePos(e);
      mouse.x = p.x; mouse.y = p.y;

      if (!(scene === "chromatin" || scene === "tfs" || scene === "bips")) return;

      // Try grab TF first
      if (scene === "tfs" || scene === "bips") {
        for (let i=world.tfs.length-1; i>=0; i--){
          const tf = world.tfs[i];
          const dx = p.x - tf.x, dy = p.y - tf.y;
          if (dx*dx + dy*dy <= (params.tfRadius*2.6)**2) {
            grab.type = "tf"; grab.index = i;
            grab.offx = tf.x - p.x; grab.offy = tf.y - p.y;
            return;
          }
        }
      }

      // Grab bead
      for (let i=world.beads.length-1; i>=0; i--){
        const b = world.beads[i];
        const dx = p.x - b.x, dy = p.y - b.y;
        if (dx*dx + dy*dy <= (18)**2) {
          grab.type = "bead"; grab.index = i;
          grab.offx = b.x - p.x; grab.offy = b.y - p.y;
          return;
        }
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const p = getMousePos(e);
      mouse.x = p.x; mouse.y = p.y;

      if (!mouse.down || grab.type === null) return;

      if (grab.type === "bead") {
        const b = world.beads[grab.index];
        const tx = mouse.x + grab.offx;
        const ty = mouse.y + grab.offy;
        b.vx += 0.25 * (tx - b.x);
        b.vy += 0.25 * (ty - b.y);
      }

      if (grab.type === "tf") {
        const tf = world.tfs[grab.index];
        const tx = mouse.x + grab.offx;
        const ty = mouse.y + grab.offy;
        tf.vx += 0.22 * (tx - tf.x);
        tf.vy += 0.22 * (ty - tf.y);
      }
    });

    window.addEventListener("mouseup", () => {
      mouse.down = false;
      grab.type = null;
      grab.index = -1;
    });

    // ============================================================
    // Physics helpers
    // ============================================================
    function addBrownian(scale){ return scale * randn(); }

    function springForce(ax, ay, bx, by, restLen, k){
      const dx = bx - ax;
      const dy = by - ay;
      const r = Math.sqrt(dx*dx + dy*dy) + 1e-6;
      const f = k * (r - restLen);
      return { fx: f * dx/r, fy: f * dy/r };
    }

    function bendForce(p0, p1, p2, kB){
      const mx = 0.5*(p0.x + p2.x);
      const my = 0.5*(p0.y + p2.y);
      return { fx: kB*(mx - p1.x), fy: kB*(my - p1.y) };
    }

    // ============================================================
    // Binding + feedback
    // ============================================================
    function feedbackBoostAt(x,y){
      if (world.bridges.length === 0) return 1.0;

      let boost = 1.0;
      for (const br of world.bridges){
        const a = world.beads[br.a];
        const b = world.beads[br.b];
        const cx = 0.5*(a.x+b.x);
        const cy = 0.5*(a.y+b.y);
        const dx = x - cx, dy = y - cy;
        const d2 = dx*dx + dy*dy;
        const R = params.feedbackRadius;
        if (d2 < R*R){
          const t = 1.0 - Math.sqrt(d2)/(R);
          boost = Math.max(boost, 1.0 + t*(params.feedbackBoostMax - 1.0));
        }
      }
      return boost;
    }

    function tryBind(tfIndex){
      const tf = world.tfs[tfIndex];
      if (!(scene === "tfs" || scene === "bips")) return;

      const hasA = (tf.bindA !== null);
      const hasB = (tf.bindB !== null);
      if (hasA && hasB) return;

      // nearest TU (green bead)
      let best = { idx: null, d2: Infinity };
      for (let i=0; i<world.beads.length; i++){
        const bead = world.beads[i];
        if (!bead.isTU) continue;
        if (tf.bindA === i || tf.bindB === i) continue;

        const dx = bead.x - tf.x;
        const dy = bead.y - tf.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < best.d2) best = { idx: i, d2 };
      }
      if (best.idx === null) return;

      if (best.d2 > params.bindRadius * params.bindRadius) return;

      const localBoost = (scene === "bips") ? feedbackBoostAt(tf.x, tf.y) : 1.0;
      const pBind = params.baseBindRate * params.stickiness * localBoost;

      if (Math.random() < pBind) {
        if (!hasA) tf.bindA = best.idx;
        else tf.bindB = best.idx;

        // If 2-site bound and in BIPS mode, create a bridge
        if (scene === "bips" && tf.bindA !== null && tf.bindB !== null) {
          const a = Math.min(tf.bindA, tf.bindB);
          const b = Math.max(tf.bindA, tf.bindB);
          const exists = world.bridges.some(br => br.a === a && br.b === b);
          if (!exists) world.bridges.push({ a, b, tfIndex });
        }
      }
    }

    function tryUnbind(tfIndex){
      const tf = world.tfs[tfIndex];
      if (!(scene === "tfs" || scene === "bips")) return;

      const localBoost = (scene === "bips") ? feedbackBoostAt(tf.x, tf.y) : 1.0;
      const unbindRate = params.baseUnbindRate / Math.sqrt(localBoost);

      if (tf.bindA !== null && Math.random() < unbindRate) tf.bindA = null;
      if (tf.bindB !== null && Math.random() < unbindRate) tf.bindB = null;

      if (scene === "bips") {
        world.bridges = world.bridges.filter(br => {
          const t = world.tfs[br.tfIndex];
          return t && (t.bindA !== null && t.bindB !== null);
        });
      }
    }

    function applyBindingConstraints(){
      const tetherK = 0.18;
      for (const tf of world.tfs){
        if (tf.bindA !== null) {
          const b = world.beads[tf.bindA];
          tf.vx += tetherK * (b.x - tf.x);
          tf.vy += tetherK * (b.y - tf.y);
        }
        if (tf.bindB !== null) {
          const b = world.beads[tf.bindB];
          tf.vx += tetherK * (b.x - tf.x);
          tf.vy += tetherK * (b.y - tf.y);
        }
      }
    }

    function applyBridgeForces(){
      if (scene !== "bips") return;

      const kBridge = 0.06 + 0.20 * params.stickiness;
      const rest = params.restLen * 2.0;

      for (const br of world.bridges){
        const a = world.beads[br.a];
        const b = world.beads[br.b];
        const f = springForce(a.x,a.y,b.x,b.y, rest, kBridge);
        a.vx += f.fx; a.vy += f.fy;
        b.vx -= f.fx; b.vy -= f.fy;
      }
    }

    // ============================================================
    // Step physics
    // ============================================================
    function stepPhysics() {
      maintainTFCount();

      const polymerActive = (scene === "chromatin" || scene === "tfs" || scene === "bips");
      if (polymerActive) {
        // neighbour springs
        for (let i=0; i<world.beads.length-1; i++){
          const a = world.beads[i];
          const b = world.beads[i+1];
          const f = springForce(a.x,a.y,b.x,b.y, params.restLen, params.kSpring);
          a.vx += f.fx; a.vy += f.fy;
          b.vx -= f.fx; b.vy -= f.fy;
        }

        // bending
        for (let i=1; i<world.beads.length-1; i++){
          const f = bendForce(world.beads[i-1], world.beads[i], world.beads[i+1], params.kBend);
          world.beads[i].vx += f.fx;
          world.beads[i].vy += f.fy;
        }

        // integrate
        for (const b of world.beads){
          b.vx += addBrownian(params.brownianChain);
          b.vy += addBrownian(params.brownianChain);
          b.vx *= params.damping;
          b.vy *= params.damping;
          b.x += b.vx;
          b.y += b.vy;
        }

        // gentle confinement (otherwise long chain wanders)
        const W = canvas.width, H = canvas.height;
        const pull = 0.0012;
        for (const b of world.beads){
          b.vx += pull * (W*0.5 - b.x);
          b.vy += pull * (H*0.55 - b.y);
        }
      }

      const tfActive = (scene === "tfs" || scene === "bips");
      if (tfActive) {
        for (const tf of world.tfs){
          tf.vx += addBrownian(params.brownianTF);
          tf.vy += addBrownian(params.brownianTF);
          tf.vx *= params.tfDamping;
          tf.vy *= params.tfDamping;
          tf.x += tf.vx;
          tf.y += tf.vy;
        }

        // wrap bounds
        const W = canvas.width, H = canvas.height;
        for (const tf of world.tfs){
          if (tf.x < 0) tf.x += W;
          if (tf.x > W) tf.x -= W;
          if (tf.y < 0) tf.y += H;
          if (tf.y > H) tf.y -= H;
        }

        for (let i=0; i<world.tfs.length; i++){
          tryUnbind(i);
          tryBind(i);
        }

        applyBindingConstraints();
        applyBridgeForces();
      }
    }

    // ============================================================
    // Rendering (colours: white chain, green TUs, red TFs)
    // ============================================================
    function drawBackground() {
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // subtle noise/stars
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      for (let i=0;i<140;i++){
        const x = (i*97) % canvas.width;
        const y = (i*181) % canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }

    function glowCircle(x,y,r,rgba,blur=18){
      ctx.save();
      ctx.shadowColor = rgba;
      ctx.shadowBlur = blur;
      ctx.fillStyle = rgba;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawDensityGlow() {
      // faint fog where things are dense (cheap but nice)
      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      for (const b of world.beads){
        const a = b.isTU ? "rgba(0,255,140,0.020)" : "rgba(255,255,255,0.010)";
        glowCircle(b.x, b.y, b.isTU ? 20 : 14, a, 26);
      }

      for (const tf of world.tfs){
        glowCircle(tf.x, tf.y, 16, "rgba(255,60,60,0.010)", 24);
      }

      if (scene === "bips") {
        for (const br of world.bridges){
          const a = world.beads[br.a];
          const b = world.beads[br.b];
          const cx = 0.5*(a.x+b.x);
          const cy = 0.5*(a.y+b.y);
          glowCircle(cx, cy, 70, "rgba(255,255,255,0.020)", 45);
        }
      }

      ctx.restore();
    }

    function drawPolymer() {
      // chain
      ctx.save();
      ctx.lineWidth = 3.5;
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.shadowColor = "rgba(255,255,255,0.12)";
      ctx.shadowBlur = 16;

      ctx.beginPath();
      world.beads.forEach((p,i)=>{
        if (i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads
      for (const b of world.beads){
        if (b.isTU) {
          glowCircle(b.x, b.y, 6.8, "rgba(0,255,140,0.85)", 22); // TU green
        } else {
          glowCircle(b.x, b.y, 4.8, "rgba(255,255,255,0.45)", 14); // chromatin white
        }
      }
    }

    function drawTFs() {
      if (!(scene === "tfs" || scene === "bips")) return;

      for (const tf of world.tfs){
        const bound = (tf.bindA !== null || tf.bindB !== null);
        const col = bound ? "rgba(255,60,60,0.95)" : "rgba(255,60,60,0.75)";
        glowCircle(tf.x, tf.y, params.tfRadius, col, bound ? 28 : 18);
      }
    }

    function drawBridges() {
      if (scene !== "bips") return;

      ctx.save();
      ctx.strokeStyle = "rgba(255,60,60,0.85)";
      ctx.lineWidth = 2.2;
      ctx.shadowColor = "rgba(255,60,60,0.25)";
      ctx.shadowBlur = 16;

      for (const br of world.bridges){
        const a = world.beads[br.a];
        const b = world.beads[br.b];
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function updateStats() {
      let boundTFs = 0;
      for (const tf of world.tfs){
        if (tf.bindA !== null || tf.bindB !== null) boundTFs++;
      }
      statsLine.textContent = `bridges: ${world.bridges.length} • bound TFs: ${boundTFs}`;
    }

    // ============================================================
    // Main loop
    // ============================================================
    function tick() {
      resizeCanvasToDisplaySize();
      stepPhysics();
      updateStats();

      drawBackground();

      // DNA slides: keep it simple visually (optional)
      if (scene === "dna") {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.80)";
        ctx.font = "800 56px system-ui";
        ctx.fillText("A  C  G  T", canvas.width*0.35, canvas.height*0.52);
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "18px system-ui";
        ctx.fillText("DNA letters → information", canvas.width*0.36, canvas.height*0.58);
        ctx.restore();
      } else {
        drawDensityGlow();
        drawPolymer();
        drawTFs();
        drawBridges();
      }

      requestAnimationFrame(tick);
    }

    // Start
    initWorld();
    applySlide(0);
    tick();
  </script>
</body>
</html>



