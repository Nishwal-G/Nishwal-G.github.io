<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BIPS Explainer | Nishwal Gora</title>

  <!-- Your site styles (optional if you want shared global styles) -->
  <!-- <link rel="stylesheet" href="../stylesheets/global.css"> -->

  <!-- New page-specific stylesheet -->
  <link rel="stylesheet" href="../stylesheets/bips_style.css">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <div id="scroll-progress"></div>

  <!-- ===== Header (matches your existing pages) ===== -->
  <header class="site-header fade-in">
    <div class="header-inner">
      <a class="brand" href="../index.html">Nishwal Gora</a>
      <nav class="site-nav">
        <ul class="nav-pill">
          <li><a href="../index.html">Home</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="cv.html">CV</a></li>
          <li><a href="about.html">About Me</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="more.html">More</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- ===== Hero ===== -->
  <section class="hero fade-in">
    <h1 class="page-title">From DNA to Chromatin to BIPS</h1>
    <p class="subtitle">
      Scroll to climb the ladder from DNA to chromatin — then watch how “sticky” transcription factors can
      create clusters through positive feedback (Bridging-Induced Phase Separation).
    </p>
    <div class="hero-hint">Scroll ↓</div>
  </section>

  <!-- ===== Main scrollytelling container ===== -->
  <main class="story">
    <!-- LEFT: text steps -->
    <section class="steps" id="steps">
      <article class="step fade-in" data-scene="dna">
        <h2>1) DNA</h2>
        <p>
          DNA is a long molecule made from four “letters”: A, C, G, T.
          The order of these letters stores biological information.
        </p>
        <p class="mini">
          Interaction: hover the animation to see base-pairs.
        </p>
      </article>

      <article class="step fade-in" data-scene="genes">
        <h2>2) Genes</h2>
        <p>
          A gene is a segment of DNA that can be “read” to make RNA (and often proteins).
          Different cells use different genes.
        </p>
        <p class="mini">
          Idea: gene ON/OFF changes what the cell does.
        </p>
      </article>

      <article class="step fade-in" data-scene="packing">
        <h2>3) Packing problem</h2>
        <p>
          Human cells contain ~2 metres of DNA packed into a nucleus only a few microns wide.
          So DNA must fold and organise in 3D.
        </p>
      </article>

      <article class="step fade-in" data-scene="chromatin">
        <h2>4) Chromatin</h2>
        <p>
          Chromatin is DNA plus proteins. Physically, it behaves like a flexible polymer — a moving spaghetti-like chain
          that constantly jiggles due to thermal motion.
        </p>
        <p class="mini">Interaction: drag the chain slightly.</p>
      </article>

      <article class="step fade-in" data-scene="tfs">
        <h2>5) Transcription factors (TFs)</h2>
        <p>
          TFs are proteins that float around and bind certain DNA sites more strongly than others.
          Think: “sticky particles” that recognise specific beads on the polymer.
        </p>
        <p class="mini">Interaction: drag a TF onto the polymer to bind.</p>
      </article>

      <article class="step fade-in" data-scene="bips">
        <h2>6) BIPS: bridges → clusters</h2>
        <p>
          If a TF can bind <strong>two</strong> DNA sites at once, it makes a <strong>bridge</strong>.
          Bridges pull distant parts together, increasing local density — which makes more binding likely.
          That positive feedback can create clusters (hubs / factories).
        </p>
        <p class="mini">
          Watch: once a bridge forms, cluster growth becomes easier.
        </p>
      </article>

      <article class="step fade-in" data-scene="takehome">
        <h2>Take-home message</h2>
        <p>
          DNA isn’t just a code — it’s also a physical object. Its 3D folding can help decide which genes get used,
          and mechanisms like BIPS can create stable “hubs” that may support cellular memory.
        </p>
      </article>
    </section>

    <!-- RIGHT: sticky animation panel -->
    <aside class="viz fade-in">
      <div class="viz-top">
        <div class="viz-title" id="vizTitle">Scene: DNA</div>
        <div class="viz-controls">
          <button id="resetBtn" type="button">Reset</button>
        </div>
      </div>

      <div class="viz-body">
        <canvas id="bipsCanvas" width="1000" height="800"></canvas>
        <div class="tooltip" id="tooltip" aria-hidden="true"></div>
      </div>

      <div class="viz-caption" id="vizCaption">
        Scroll to progress. Try dragging objects in later scenes.
      </div>
    </aside>
  </main>

  <!-- ===== Footer ===== -->
  <footer class="fade-in">
    <div class="social-links">
      <a href="https://www.linkedin.com/in/nishwal-gora/" class="fa fa-linkedin" target="_blank" rel="noopener noreferrer"></a>
      <a href="https://github.com/Nishwal-G" class="fa fa-github" target="_blank" rel="noopener noreferrer"></a>
    </div>
  </footer>

  <!-- ===== Your existing scroll progress bar script ===== -->
  <script>
    window.addEventListener("scroll", () => {
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const progress = (scrollTop / scrollHeight) * 100;
      document.getElementById("scroll-progress").style.width = progress + "%";
    });
  </script>

  <!-- ===== Fade-in observer (your existing style) ===== -->
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add("visible");
            obs.unobserve(entry.target);
          }
        });
      }, { threshold: 0.1 });

      document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
    });
  </script>

  <!-- ===== Scrollytelling scene switching + canvas interactions ===== -->
  <script>
    const steps = Array.from(document.querySelectorAll(".step"));
    const vizTitle = document.getElementById("vizTitle");
    const vizCaption = document.getElementById("vizCaption");
    const canvas = document.getElementById("bipsCanvas");
    const ctx = canvas.getContext("2d");
    const tooltip = document.getElementById("tooltip");
    const resetBtn = document.getElementById("resetBtn");

    let currentScene = "dna";

    // --- simple scene state ---
    const state = {
      // chromatin chain points
      chain: [],
      chainGrab: null,

      // TF particle
      tf: { x: 820, y: 420, r: 22, grabbed: false, boundIndex: null },

      // BIPS: bridges
      bridges: [], // [{i, j}]
    };

    function initChain() {
      state.chain = [];
      const n = 26;
      for (let i = 0; i < n; i++) {
        state.chain.push({
          x: 160 + i * 24,
          y: 420 + 40 * Math.sin(i * 0.35),
          special: (i % 6 === 0), // “binding sites”
        });
      }
      state.chainGrab = null;
      state.tf.x = 820; state.tf.y = 420; state.tf.grabbed = false; state.tf.boundIndex = null;
      state.bridges = [];
    }
    initChain();

    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawBackground() {
      ctx.fillStyle = "#f6f6f6";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawDNA() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("DNA: a code + a molecule", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("Hover the ‘letters’ to see base-pairing (A–T, C–G).", 60, 130);

      // simple “letters” row
      const letters = ["A","C","G","T","A","T","C","G","A","C","T","G"];
      for (let i=0; i<letters.length; i++){
        const x = 80 + i*60, y = 220;
        ctx.fillStyle = "rgba(0,0,0,0.08)";
        ctx.fillRect(x-18, y-38, 46, 56);
        ctx.fillStyle = "#111";
        ctx.font = "30px system-ui";
        ctx.fillText(letters[i], x, y);
      }
    }

    function drawGenes() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("Genes: useful segments", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("A gene is a stretch of DNA that can be read.", 60, 130);

      // highlight segment
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.fillRect(80, 220, 820, 14);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(280, 210, 280, 34);
      ctx.fillStyle = "#111";
      ctx.font = "20px system-ui";
      ctx.fillText("gene", 395, 270);
    }

    function drawPacking() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("Packing: fitting DNA into the nucleus", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("Long chain → folded fibre → loops → compact structure.", 60, 130);

      // simple “zoom out” coils
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 4;
      for (let k=0;k<4;k++){
        ctx.beginPath();
        for (let i=0;i<200;i++){
          const x = 100 + i*4;
          const y = 260 + k*110 + 30*Math.sin(i*0.2);
          ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
    }

    function drawChromatin() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("Chromatin: a moving polymer", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("Drag the chain slightly — it’s a flexible 3D object.", 60, 130);

      drawChain();
    }

    function drawTFs() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("TFs: sticky particles that bind sites", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("Drag the TF onto a highlighted site to ‘bind’.", 60, 130);

      drawChain(true);
      drawTF();
    }

    function drawBIPS() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("BIPS: bridges create clusters (positive feedback)", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("Make a bridge: bind two sites → chain densifies → more bridges become likely.", 60, 130);

      // Slightly “pull” chain around existing bridges to hint densification
      applyBridgePull();
      drawChain(true);
      drawBridges();
      drawTF();

      // Visual feedback: “cluster region”
      if (state.bridges.length > 0) {
        ctx.fillStyle = "rgba(0,0,0,0.06)";
        ctx.fillRect(360, 300, 260, 260);
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.font = "18px system-ui";
        ctx.fillText("density ↑", 450, 340);
      }
    }

    function drawTakehome() {
      drawBackground();
      ctx.fillStyle = "#111";
      ctx.font = "34px system-ui";
      ctx.fillText("Take-home", 60, 90);
      ctx.font = "18px system-ui";
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillText("DNA is physical. 3D folding can shape regulation and stability.", 60, 130);
      ctx.fillText("BIPS is one physical route to hubs without TF–TF attraction.", 60, 160);
    }

    function drawChain(showSpecial=false) {
      // links
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      state.chain.forEach((p, idx) => {
        if (idx === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();

      // beads
      for (const p of state.chain) {
        ctx.beginPath();
        ctx.fillStyle = (showSpecial && p.special) ? "rgba(0,0,0,0.55)" : "rgba(0,0,0,0.18)";
        ctx.arc(p.x, p.y, p.special ? 10 : 8, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawTF() {
      const tf = state.tf;
      ctx.beginPath();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.arc(tf.x, tf.y, tf.r, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "16px system-ui";
      ctx.fillText("TF", tf.x - 12, tf.y + 6);
    }

    function drawBridges() {
      ctx.strokeStyle = "rgba(0,0,0,0.55)";
      ctx.lineWidth = 3;
      for (const b of state.bridges) {
        const p1 = state.chain[b.i];
        const p2 = state.chain[b.j];
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }

    function applyBridgePull() {
      // gentle pull of bridged points toward midpoints to suggest densification
      for (const b of state.bridges) {
        const p1 = state.chain[b.i];
        const p2 = state.chain[b.j];
        const mx = (p1.x + p2.x) / 2;
        const my = (p1.y + p2.y) / 2;
        p1.x += 0.02 * (mx - p1.x);
        p1.y += 0.02 * (my - p1.y);
        p2.x += 0.02 * (mx - p2.x);
        p2.y += 0.02 * (my - p2.y);
      }
    }

    function setScene(scene) {
      currentScene = scene;
      vizTitle.textContent = "Scene: " + scene.toUpperCase();

      if (scene === "dna") vizCaption.textContent = "Hover the letters to learn base pairing.";
      if (scene === "genes") vizCaption.textContent = "A gene is a segment that can be read.";
      if (scene === "packing") vizCaption.textContent = "Long chain → folded structure.";
      if (scene === "chromatin") vizCaption.textContent = "Drag the polymer: chromatin behaves like a flexible chain.";
      if (scene === "tfs") vizCaption.textContent = "Drag the TF onto a dark bead to bind.";
      if (scene === "bips") vizCaption.textContent = "In BIPS, bridges make clusters easier (positive feedback).";
      if (scene === "takehome") vizCaption.textContent = "Physical folding can influence stable cell states.";

      render();
    }

    function render() {
      if (currentScene === "dna") return drawDNA();
      if (currentScene === "genes") return drawGenes();
      if (currentScene === "packing") return drawPacking();
      if (currentScene === "chromatin") return drawChromatin();
      if (currentScene === "tfs") return drawTFs();
      if (currentScene === "bips") return drawBIPS();
      if (currentScene === "takehome") return drawTakehome();
    }

    // --- IntersectionObserver: activate scene based on scroll ---
    const obs = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          steps.forEach(s => s.dataset.active = "false");
          e.target.dataset.active = "true";
          setScene(e.target.dataset.scene);
        }
      });
    }, { threshold: 0.6 });
    steps.forEach(s => obs.observe(s));

    // --- Mouse interactions (drag chain + TF; show tooltip) ---
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
      return {x, y};
    }

    function dist(a,b) {
      const dx = a.x-b.x, dy = a.y-b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function nearestChainPoint(pos, maxD=22) {
      let best = { idx: -1, d: Infinity };
      state.chain.forEach((p, i) => {
        const d = dist(pos, p);
        if (d < best.d) best = { idx: i, d };
      });
      return best.d <= maxD ? best : null;
    }

    canvas.addEventListener("mousedown", (e) => {
      const pos = getMousePos(e);

      // TF drag only in tfs/bips scenes
      if ((currentScene === "tfs" || currentScene === "bips") && dist(pos, state.tf) <= state.tf.r + 6) {
        state.tf.grabbed = true;
        return;
      }

      // Chain drag in chromatin/tfs/bips
      if (currentScene === "chromatin" || currentScene === "tfs" || currentScene === "bips") {
        const near = nearestChainPoint(pos, 18);
        if (near) state.chainGrab = near.idx;
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const pos = getMousePos(e);

      // tooltip logic (DNA letters / special beads)
      tooltip.style.display = "none";

      if (currentScene === "dna") {
        // fake hover regions where letters drawn (simple)
        // (We keep it minimal; you can refine later)
        // No heavy math: just show tooltip if near the letter row
        if (pos.y > 170 && pos.y < 260) {
          tooltip.style.display = "block";
          tooltip.textContent = "Base pairing: A–T and C–G";
          tooltip.style.left = (e.clientX + 12) + "px";
          tooltip.style.top = (e.clientY + 12) + "px";
        }
      }

      if (state.tf.grabbed) {
        state.tf.x = pos.x;
        state.tf.y = pos.y;
        render();
        return;
      }

      if (state.chainGrab !== null) {
        const p = state.chain[state.chainGrab];
        p.x = pos.x;
        p.y = pos.y;
        render();
        return;
      }

      // hover special beads in TF scenes
      if (currentScene === "tfs" || currentScene === "bips") {
        const near = nearestChainPoint(pos, 16);
        if (near && state.chain[near.idx].special) {
          tooltip.style.display = "block";
          tooltip.textContent = "High-affinity binding site";
          tooltip.style.left = (e.clientX + 12) + "px";
          tooltip.style.top = (e.clientY + 12) + "px";
        }
      }
    });

    window.addEventListener("mouseup", () => {
      // drop TF: bind if near a special site
      if (state.tf.grabbed) {
        state.tf.grabbed = false;

        if (currentScene === "tfs" || currentScene === "bips") {
          const near = nearestChainPoint(state.tf, 28);
          if (near && state.chain[near.idx].special) {
            // bind to this bead
            state.tf.boundIndex = near.idx;
            state.tf.x = state.chain[near.idx].x + 0;
            state.tf.y = state.chain[near.idx].y - 34;

            // in BIPS: if already bound once, create a bridge on second bind
            if (currentScene === "bips") {
              // If no bridge yet, prompt a second “bind”
              if (state.bridges.length === 0) {
                // Create a bridge to another special bead (nearest other special)
                let j = -1, best = Infinity;
                for (let k=0;k<state.chain.length;k++){
                  if (k !== near.idx && state.chain[k].special) {
                    const d = Math.abs(k - near.idx);
                    if (d < best) { best = d; j = k; }
                  }
                }
                if (j >= 0) state.bridges.push({ i: near.idx, j });
              }
            }
          }
        }
        render();
      }

      state.chainGrab = null;
    });

    resetBtn.addEventListener("click", () => {
      initChain();
      render();
    });

    render();
  </script>
</body>
</html>
