<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DNA → Chromatin → Clusters (BIPS story) | Nishwal Gora</title>

  <style>
    :root{
      --bg:#050507;
      --border:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.72);
      --maxw:1100px;

      --green: rgba(0,255,140,0.95);
      --greenDim: rgba(0,255,140,0.28);
      --red: rgba(255,60,60,0.92);
      --redDim: rgba(255,60,60,0.55);
      --pink: rgba(255,120,200,0.70);
      --amber: rgba(255,180,80,0.95);
      --purple: rgba(190,120,255,0.95);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }

    .page{
      min-height:100vh;
      padding:14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:14px;
    }

    /* Text panel above canvas */
    .textPanel{
      width:min(var(--maxw),100%);
      border:1px solid var(--border);
      border-radius:18px;
      background:rgba(0,0,0,0.46);
      backdrop-filter: blur(12px);
      box-shadow:0 20px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .textInner{ padding:16px; }
    .kicker{
      font-weight:900;
      letter-spacing:0.3px;
      font-size:12px;
      color:rgba(255,255,255,0.70);
      text-transform:uppercase;
      margin-bottom:8px;
    }
    .sceneTitle{
      margin:0;
      font-weight:950;
      letter-spacing:-0.3px;
      font-size: clamp(20px, 2.2vw, 28px);
      line-height:1.1;
    }
    .sceneSub{
      margin-top:8px;
      color:var(--muted);
      font-size:14px;
      line-height:1.55;
    }
    .story{
      margin-top:12px;
      color:rgba(255,255,255,0.80);
      font-size:15px;
      line-height:1.72;
    }
    .story p{ margin:10px 0 0 0; }

    .controls{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      align-items:center;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .pill{
      border:1px solid var(--border);
      background:rgba(0,0,0,0.38);
      color:rgba(255,255,255,0.90);
      padding:9px 14px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      backdrop-filter: blur(10px);
      user-select:none;
    }
    .pill:hover{ background:rgba(255,255,255,0.10); }
    .pill.strong{ background:rgba(255,255,255,0.12); }
    .pill.ghost{ background:rgba(255,255,255,0.04); }
    .pill:disabled{ opacity:0.35; cursor:default; }

    /* Canvas */
    .stage{
      width:min(var(--maxw),100%);
      height:min(62vh,720px);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      overflow:hidden;
      background:rgba(0,0,0,0.25);
      position:relative;
    }
    #stageCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    .legend{
      position:absolute;
      left:12px;
      bottom:12px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:16px;
      background:rgba(0,0,0,0.32);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,0.70);
      font-size:12px;
      display:flex;
      gap:10px;
      align-items:center;
      pointer-events:none;

      opacity:0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .legend.show{ opacity:1; transform: translateY(0); }
    .dot{ width:9px; height:9px; border-radius:50%; display:inline-block; margin-right:6px; }
    .dot.white{ background:rgba(255,255,255,0.85); }
    .dot.green{ background:var(--green); }
    .dot.red{ background:var(--red); }
    .dot.pink{ background:var(--pink); }
    .dot.amber{ background:var(--amber); }

    @media (max-width:860px){
      .stage{ height:52vh; }
    }
  </style>
</head>

<body>
  <div class="page">
    <section class="textPanel">
      <div class="textInner">
        <div class="kicker" id="kicker">Act 1 of 8</div>
        <h1 class="sceneTitle" id="sceneTitle">Act 1 — How do cells know who they are?</h1>
        <div class="sceneSub" id="sceneSub">Click the labels on the DNA. Then press Next.</div>
        <div class="story" id="story"></div>

        <div class="controls">
          <button class="pill ghost" id="prevBtn" type="button">← Prev</button>
          <button class="pill ghost" id="resetBtn" type="button">↻ Reset</button>
          <button class="pill strong" id="nextBtn" type="button">Next →</button>
        </div>
      </div>
    </section>

    <section class="stage">
      <canvas id="stageCanvas"></canvas>
      <div class="legend" id="legend">
        <span><span class="dot.white dot"></span>DNA / chromatin</span>
        <span><span class="dot.green dot"></span>gene region</span>
        <span><span class="dot.red dot"></span>TF (reader)</span>
        <span><span class="dot.pink dot"></span>cluster</span>
        <span><span class="dot.amber dot"></span>locked</span>
      </div>
    </section>
  </div>

  <script>
    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
      return {w:canvas.width, h:canvas.height};
    }
    window.addEventListener("resize", () => { resizeCanvas(); rebuildClickables(); initAct(true); });

    // RNG helpers
    function randn(){
      let u=0,v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    // Draw helpers
    function drawBackground(){
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      for (let i=0;i<140;i++){
        const x=(i*97)%canvas.width;
        const y=(i*181)%canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }
    function glowCircle(x,y,r,color,blur){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    function roundRect(x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // ============================================================
    // UI
    // ============================================================
    const UI = {
      kicker: document.getElementById("kicker"),
      title: document.getElementById("sceneTitle"),
      sub: document.getElementById("sceneSub"),
      story: document.getElementById("story"),
      prev: document.getElementById("prevBtn"),
      next: document.getElementById("nextBtn"),
      reset: document.getElementById("resetBtn"),
      legend: document.getElementById("legend"),
    };

    // ============================================================
    // Acts 1–8 (FULL)
    // ============================================================
    let act = 1;
    let highlight = null; // "basepair" | "gene" | "locked" | null

    const ACTS = {
      1: {
        title: "Act 1 — How do cells know who they are?",
        sub: "Your DNA is (almost) the same in every cell. Identity = which genes are being read.",
        story: `
          <p>
            Every cell in your body contains the same DNA “instruction book”.
            But a <strong>skin cell</strong> behaves differently from a <strong>red blood cell</strong>.
          </p>
          <p>
            Why? Because different cells read different parts of the instruction book.
            A cell’s identity is mostly about which <strong>genes</strong> are ON and which are OFF.
          </p>
          <p>
            Click the labels on the helix to learn what <strong>base pairs</strong> and a <strong>gene</strong> are.
          </p>
        `,
        mode: "dna"
      },
      2: {
        title: "Act 2 — DNA is a code (an alphabet)",
        sub: "DNA uses four letters A, C, G, T. Base pairs are the “rungs” of the ladder.",
        story: `
          <p>
            DNA is written using four chemical “letters”: <strong>A, C, G, T</strong>.
            The order of these letters stores information — like a long message.
          </p>
          <p>
            DNA comes in two strands twisted together: a <strong>double helix</strong>.
            The two strands are joined by pairs of letters called <strong>base pairs</strong>:
            A pairs with T, and C pairs with G.
          </p>
          <p>
            Click <strong>Base pairs</strong> to highlight the rungs, and click <strong>Gene</strong> to highlight a “sentence” in the DNA message.
          </p>
        `,
        mode: "dna"
      },
      3: {
        title: "Act 3 — Epigenetics (locking chapters)",
        sub: "Cells can chemically ‘lock’ regions, making them harder to read.",
        story: `
          <p>
            Cells can keep their identity using <strong>epigenetics</strong>.
            This is like putting sticky notes and locks on parts of the instruction book:
            some regions become easy to access (open), others become hard to access (closed).
          </p>
          <p>
            In this cartoon, locked DNA regions glow <span style="color: var(--amber); font-weight:900;">amber</span>.
            Click <strong>Locked</strong> to see what “closed” regions look like.
          </p>
        `,
        mode: "epi"
      },
      4: {
        title: "Act 4 — Zoom out: chromatin folds and compacts",
        sub: "Now we stop drawing the helix. We just show a long polymer that folds and gets smaller.",
        story: `
          <p>
            DNA is incredibly long (about 2 metres in a human cell), but it must fit inside a tiny nucleus.
            So it wraps around proteins and folds into <strong>chromatin</strong>.
          </p>
          <p>
            Here we show chromatin as a long “string” (a polymer).
            Watch it fold and compact over time — it gets smaller and denser.
          </p>
        `,
        mode: "act4_compaction"
      },
      5: {
        title: "Act 5 — Transcription factors (TFs) wander and search",
        sub: "TFs are proteins that drift randomly, like pollen in water.",
        story: `
          <p>
            Genes are “read” by proteins. A famous class is <strong>transcription factors</strong> (TFs).
            They move around randomly and bump into DNA/chromatin.
          </p>
          <p>
            Here the red TF particles are just wandering — no special attraction yet.
          </p>
        `,
        mode: "act5_free_tfs"
      },
      6: {
        title: "Act 6 — Zoom in: one big TF pulls two parts of DNA together",
        sub: "A big ‘sticky reader’ can act like a clip that brings two segments close.",
        story: `
          <p>
            Now we zoom into one local region.
            Imagine a TF that behaves like a <strong>sticky clip</strong>:
            it can grab two parts of the DNA/chromatin and bring them closer.
          </p>
          <p>
            In this cartoon, a large red TF bead sits on the right.
            The polymer is pulled toward it from two sides, wrapping around it.
          </p>
        `,
        mode: "act6_big_tf_wrap"
      },
      7: {
        title: "Act 7 — Positive feedback: more TFs join the same cluster",
        sub: "Once one cluster forms, it becomes a bigger target and recruits more TFs.",
        story: `
          <p>
            Once a cluster exists, it becomes a “busy” place.
            Wandering TFs are more likely to hit it and stick around.
          </p>
          <p>
            Watch more big TFs slowly drift toward the same cluster region.
          </p>
        `,
        mode: "act7_recruit_more"
      },
      8: {
        title: "Act 8 — Many clusters across the polymer",
        sub: "Final picture: one long polymer with several hubs (like factories) along it.",
        story: `
          <p>
            Zoom out again.
            Across a long chromosome, you might have several hotspots where reading happens more often
            and many quiet regions where little happens.
          </p>
          <p>
            Here we show a polymer with ~5–6 clusters along its length.
          </p>
        `,
        mode: "act8_many_clusters"
      }
    };

    function applyAct(){
      act = clamp(act, 1, 8);
      const A = ACTS[act];

      UI.kicker.textContent = `Act ${act} of 8`;
      UI.title.textContent = A.title;
      UI.sub.textContent = A.sub;
      UI.story.innerHTML = A.story;

      UI.prev.disabled = (act === 1);
      UI.next.disabled = (act === 8);

      // Legend visible from act 2 onward (fine everywhere)
      UI.legend.classList.toggle("show", true);

      // Only Acts 1–3 use highlights
      highlight = null;

      initAct(true);
      rebuildClickables();
    }

    UI.prev.addEventListener("click", () => { act--; applyAct(); });
    UI.next.addEventListener("click", () => { act++; applyAct(); });
    UI.reset.addEventListener("click", () => { initAct(true); rebuildClickables(); });

    // ============================================================
    // Clickable labels (Acts 1–3)
    // ============================================================
    const clickables = []; // {id,x,y,w,h}
    function clearClickables(){ clickables.length = 0; }

    function mouseToCanvas(e){
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left);
      const sy = (e.clientY - rect.top);
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: sx * scaleX, y: sy * scaleY };
    }

    canvas.addEventListener("click", (e) => {
      if (act > 3) return;
      const p = mouseToCanvas(e);
      for (let i=clickables.length-1;i>=0;i--){
        const c = clickables[i];
        if (p.x>=c.x && p.x<=c.x+c.w && p.y>=c.y && p.y<=c.y+c.h){
          if (c.id === "basepairs") highlight = (highlight==="basepair") ? null : "basepair";
          if (c.id === "gene") highlight = (highlight==="gene") ? null : "gene";
          if (c.id === "locked") highlight = (highlight==="locked") ? null : "locked";
          break;
        }
      }
    });

    function drawLabelWithArrow(label, xText, yText, xTo, yTo, color, id){
      ctx.save();
      ctx.font = "950 16px system-ui"; // bigger & bolder labels
      const padX = 12, padY = 8;
      const textW = ctx.measureText(label).width;
      const w = textW + 2*padX;
      const h = 32;

      const rx = xText;
      const ry = yText;

      // arrow
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.70;
      ctx.beginPath();
      ctx.moveTo(rx + w*0.5, ry + h);
      ctx.lineTo(xTo, yTo);
      ctx.stroke();

      // pill
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = "rgba(0,0,0,0.40)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      roundRect(rx, ry, w, h, 999, true, true);

      // text
      ctx.fillStyle = color;
      ctx.fillText(label, rx + padX, ry + 22);

      ctx.restore();

      clickables.push({id, x:rx, y:ry, w, h});
    }

    function rebuildClickables(){
      clearClickables();
      // They get rebuilt inside drawDNAHelix each frame too, but clearing here keeps it tidy.
    }

    // ============================================================
    // Act 1–3: DNA helix drawing
    // ============================================================
    function drawDNAHelix(mode){
      const W = canvas.width, H = canvas.height;
      const cx = W * 0.52;
      const cy = H * 0.56;
      const amp = H * 0.14;
      const pitch = W * 0.022;
      const turns = 44;
      const tNow = performance.now() * 0.0016;

      const geneStart = 15;
      const geneEnd   = 24;

      const lockSegments = [
        { a: 7,  b: 12 },
        { a: 28, b: 33 }
      ];
      function isLocked(i){
        for (const seg of lockSegments){
          if (i>=seg.a && i<=seg.b) return true;
        }
        return false;
      }

      // helix
      for (let i=0;i<turns;i++){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);

        const inGene = (i>=geneStart && i<=geneEnd);
        const locked = isLocked(i);

        // rung styling
        let rungColor = "rgba(255,255,255,0.20)";
        let rungWidth = 2.0;

        if (highlight === "gene" && inGene){ rungColor = "rgba(0,255,140,0.92)"; rungWidth = 3.2; }
        else if (highlight === "basepair" && (i%4===0)){ rungColor = "rgba(255,255,255,0.92)"; rungWidth = 3.2; }

        if (mode === "epi" && locked){
          rungColor = (highlight === "locked") ? "rgba(255,180,80,0.90)" : "rgba(255,180,80,0.45)";
          rungWidth = (highlight === "locked") ? 3.0 : 2.2;
        }

        ctx.save();
        ctx.strokeStyle = rungColor;
        ctx.lineWidth = rungWidth;
        ctx.beginPath();
        ctx.moveTo(x,y1);
        ctx.lineTo(x,y2);
        ctx.stroke();
        ctx.restore();

        // backbones
        let backboneColor = "rgba(255,255,255,0.55)";
        if (highlight === "gene" && inGene) backboneColor = "rgba(0,255,140,0.65)";
        if (mode === "epi" && locked) backboneColor = "rgba(255,180,80,0.55)";

        glowCircle(x, y1, 5.0, backboneColor, 18);
        glowCircle(x, y2, 5.0, backboneColor, 18);

        // epigenetic "lock plates" more visible: amber translucent blocks
        if (mode === "epi" && locked){
          ctx.save();
          ctx.globalAlpha = (highlight === "locked") ? 0.65 : 0.45;
          ctx.fillStyle = "rgba(255,180,80,0.20)";
          ctx.strokeStyle = "rgba(255,180,80,0.35)";
          ctx.lineWidth = 1.8;
          const cx2 = x;
          const cy2 = 0.5*(y1+y2);
          roundRect(cx2-14, cy2-22, 28, 44, 14, true, true);
          ctx.restore();
        }
      }

      // clickable labels + arrows
      clearClickables();

      const baseIdx = 16;
      const geneIdx = 20;
      const lockIdx = 9;

      function helixPoint(i){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);
        return { x, y: 0.5*(y1+y2) };
      }

      const bp = helixPoint(baseIdx);
      const gn = helixPoint(geneIdx);
      const lk = helixPoint(lockIdx);

      const white = "rgba(255,255,255,0.92)";
      const green = "rgba(0,255,140,0.92)";
      const amber = "rgba(255,180,80,0.92)";

      drawLabelWithArrow("Base pairs", W*0.10, H*0.28, bp.x, bp.y, white, "basepairs");
      drawLabelWithArrow("Gene",      W*0.74, H*0.76, gn.x, gn.y, green, "gene");
      if (mode === "epi"){
        drawLabelWithArrow("Locked",   W*0.09, H*0.74, lk.x, lk.y, amber, "locked");
      }
    }

    // ============================================================
    // Acts 4–8: simplified animations (NO previous polymer code)
    // ============================================================

    // Act 4: a polymer line that folds and compacts
    const A4 = {
      pts: [], v: [],
      init(){
        const W=canvas.width, H=canvas.height;
        const N=260;
        this.pts = [];
        this.v = new Array(N).fill(0).map(_=>({vx:0,vy:0}));
        const x0=W*0.10, y0=H*0.55;
        const dx=(W*0.80)/(N-1);
        for (let i=0;i<N;i++){
          this.pts.push({x:x0+i*dx, y:y0 + H*0.10*Math.sin(i*0.18)});
        }
        this.t = 0;
      },
      step(){
        const N=this.pts.length;
        const rest=7.2;
        const k=0.10;
        const damp=0.92;
        const brown=0.55;

        // gentle global "compaction" pull to centre increases over time
        this.t += 1;
        const W=canvas.width, H=canvas.height;
        const cx=W*0.55, cy=H*0.55;
        const compact = Math.min(0.004 + this.t*0.000003, 0.012);

        // springs
        for (let i=0;i<N-1;i++){
          const a=this.pts[i], b=this.pts[i+1];
          const dx=b.x-a.x, dy=b.y-a.y;
          const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
          const f=k*(r-rest);
          const fx=f*dx/r, fy=f*dy/r;
          this.v[i].vx += fx; this.v[i].vy += fy;
          this.v[i+1].vx -= fx; this.v[i+1].vy -= fy;
        }

        // mild bending / smoothing
        for (let i=1;i<N-1;i++){
          const p0=this.pts[i-1], p1=this.pts[i], p2=this.pts[i+1];
          const mx=0.5*(p0.x+p2.x), my=0.5*(p0.y+p2.y);
          this.v[i].vx += 0.004*(mx-p1.x);
          this.v[i].vy += 0.004*(my-p1.y);
        }

        // compaction pull (acts like "folding over itself" visually)
        for (let i=0;i<N;i++){
          const p=this.pts[i];
          this.v[i].vx += compact*(cx - p.x);
          this.v[i].vy += compact*(cy - p.y);
        }

        // integrate
        for (let i=0;i<N;i++){
          this.v[i].vx += brown*randn();
          this.v[i].vy += brown*randn();
          this.v[i].vx *= damp;
          this.v[i].vy *= damp;

          this.pts[i].x += this.v[i].vx;
          this.pts[i].y += this.v[i].vy;

          // soft walls
          const margin=60, kw=0.002;
          if (this.pts[i].x < margin) this.v[i].vx += kw*(margin - this.pts[i].x);
          if (this.pts[i].x > W-margin) this.v[i].vx -= kw*(this.pts[i].x - (W-margin));
          if (this.pts[i].y < margin) this.v[i].vy += kw*(margin - this.pts[i].y);
          if (this.pts[i].y > H-margin) this.v[i].vy -= kw*(this.pts[i].y - (H-margin));
        }
      },
      draw(){
        // glow density near centre
        const W=canvas.width, H=canvas.height;
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        glowCircle(W*0.55,H*0.55, 120, "rgba(255,120,200,0.018)", 150);
        ctx.restore();

        // line
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.25)";
        ctx.lineWidth=3.2;
        ctx.beginPath();
        for (let i=0;i<this.pts.length;i++){
          const p=this.pts[i];
          if (i===0) ctx.moveTo(p.x,p.y);
          else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
        ctx.restore();

        // beads
        for (const p of this.pts){
          glowCircle(p.x,p.y, 3.8, "rgba(255,255,255,0.50)", 14);
        }
      }
    };

    // Act 5: free TFs drifting (keep simple)
    const A5 = {
      tfs: [],
      init(){
        const W=canvas.width, H=canvas.height;
        this.tfs = [];
        for (let i=0;i<28;i++){
          this.tfs.push({
            x: W*(0.20 + 0.60*Math.random()),
            y: H*(0.20 + 0.60*Math.random()),
            vx:0, vy:0
          });
        }
      },
      step(){
        const W=canvas.width, H=canvas.height;
        for (const tf of this.tfs){
          tf.vx += 0.60*randn();
          tf.vy += 0.60*randn();
          tf.vx *= 0.94;
          tf.vy *= 0.94;
          tf.x += tf.vx;
          tf.y += tf.vy;
          // wrap
          if (tf.x<0) tf.x += W;
          if (tf.x>W) tf.x -= W;
          if (tf.y<0) tf.y += H;
          if (tf.y>H) tf.y -= H;
        }
      },
      draw(){
        // subtle “chromatin haze” background only
        const W=canvas.width, H=canvas.height;
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        glowCircle(W*0.50,H*0.55, 140, "rgba(255,255,255,0.012)", 180);
        ctx.restore();

        for (const tf of this.tfs){
          glowCircle(tf.x, tf.y, 7.0, "rgba(255,60,60,0.80)", 24);
        }
      }
    };

    // Act 6: Zoomed in — big TF bead pulling polymer from two sides, wrapping around it
    const A6 = {
      pts: [], v: [],
      big: {x:0,y:0},
      init(){
        const W=canvas.width, H=canvas.height;
        this.big = { x: W*0.72, y: H*0.55 };

        const N=160;
        this.pts = [];
        this.v = new Array(N).fill(0).map(_=>({vx:0,vy:0}));

        // Make a "U-shaped" chain coming in from left, going past the TF, leaving to left-ish
        const x0=W*0.12, y0=H*0.55;
        const span=W*0.60;
        for (let i=0;i<N;i++){
          const t=i/(N-1);
          const x = x0 + span*t;
          const y = y0 + H*0.18*Math.sin(t*Math.PI); // arch
          this.pts.push({x,y});
        }
        this.t=0;
      },
      step(){
        this.t++;
        const N=this.pts.length;
        const rest=6.8;
        const k=0.13;
        const damp=0.90;
        const brown=0.40;

        // springs
        for (let i=0;i<N-1;i++){
          const a=this.pts[i], b=this.pts[i+1];
          const dx=b.x-a.x, dy=b.y-a.y;
          const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
          const f=k*(r-rest);
          const fx=f*dx/r, fy=f*dy/r;
          this.v[i].vx += fx; this.v[i].vy += fy;
          this.v[i+1].vx -= fx; this.v[i+1].vy -= fy;
        }

        // smooth bending
        for (let i=1;i<N-1;i++){
          const p0=this.pts[i-1], p1=this.pts[i], p2=this.pts[i+1];
          const mx=0.5*(p0.x+p2.x), my=0.5*(p0.y+p2.y);
          this.v[i].vx += 0.006*(mx-p1.x);
          this.v[i].vy += 0.006*(my-p1.y);
        }

        // big TF "attractor": pulls nearby chain segments in
        const pull=0.010;
        const R=180;
        for (let i=0;i<N;i++){
          const p=this.pts[i];
          const dx=this.big.x - p.x;
          const dy=this.big.y - p.y;
          const d=Math.sqrt(dx*dx+dy*dy)+1e-6;
          if (d<R){
            const s = (1 - d/R);
            this.v[i].vx += pull*s*dx;
            this.v[i].vy += pull*s*dy;
          }
        }

        // excluded volume around big TF so chain wraps around not through
        const hardR = 62;
        for (let i=0;i<N;i++){
          const p=this.pts[i];
          const dx=p.x - this.big.x;
          const dy=p.y - this.big.y;
          const d=Math.sqrt(dx*dx+dy*dy)+1e-6;
          if (d < hardR){
            const push = (hardR - d)*0.08;
            this.v[i].vx += push*dx/d;
            this.v[i].vy += push*dy/d;
          }
        }

        // integrate
        const W=canvas.width, H=canvas.height;
        for (let i=0;i<N;i++){
          this.v[i].vx += brown*randn();
          this.v[i].vy += brown*randn();
          this.v[i].vx *= damp;
          this.v[i].vy *= damp;
          this.pts[i].x += this.v[i].vx;
          this.pts[i].y += this.v[i].vy;

          // soft walls
          const margin=50, kw=0.0022;
          if (this.pts[i].x < margin) this.v[i].vx += kw*(margin - this.pts[i].x);
          if (this.pts[i].x > W-margin) this.v[i].vx -= kw*(this.pts[i].x - (W-margin));
          if (this.pts[i].y < margin) this.v[i].vy += kw*(margin - this.pts[i].y);
          if (this.pts[i].y > H-margin) this.v[i].vy -= kw*(this.pts[i].y - (H-margin));
        }
      },
      draw(){
        // big TF glow
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        glowCircle(this.big.x,this.big.y, 130, "rgba(255,60,60,0.020)", 180);
        glowCircle(this.big.x,this.big.y, 78, "rgba(255,120,200,0.030)", 120);
        ctx.restore();

        // chain
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.25)";
        ctx.lineWidth=3.4;
        ctx.beginPath();
        for (let i=0;i<this.pts.length;i++){
          const p=this.pts[i];
          if (i===0) ctx.moveTo(p.x,p.y);
          else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
        ctx.restore();

        // beads
        for (const p of this.pts){
          glowCircle(p.x,p.y, 4.0, "rgba(255,255,255,0.55)", 16);
        }

        // big TF bead (solid)
        glowCircle(this.big.x,this.big.y, 46, "rgba(255,60,60,0.92)", 40);
        ctx.save();
        ctx.fillStyle="rgba(0,0,0,0.65)";
        ctx.font="900 14px system-ui";
        ctx.fillText("TF", this.big.x-12, this.big.y+5);
        ctx.restore();
      }
    };

    // Act 7: More big TFs drift toward the main cluster (focus on one cluster)
    const A7 = {
      pts: [], v: [],
      bigs: [],
      anchor: {x:0,y:0},
      init(){
        const W=canvas.width, H=canvas.height;
        this.anchor = { x: W*0.70, y: H*0.55 };

        // polymer already wrapped-ish around anchor
        const N=170;
        this.pts = [];
        this.v = new Array(N).fill(0).map(_=>({vx:0,vy:0}));
        const x0=W*0.12, y0=H*0.55;
        const span=W*0.62;
        for (let i=0;i<N;i++){
          const t=i/(N-1);
          const x = x0 + span*t;
          const y = y0 + H*0.20*Math.sin(t*Math.PI);
          this.pts.push({x,y});
        }

        // big TFs: start scattered, then slowly migrate to anchor
        this.bigs = [];
        const count=6;
        for (let i=0;i<count;i++){
          this.bigs.push({
            x: W*(0.20 + 0.60*Math.random()),
            y: H*(0.20 + 0.60*Math.random()),
            vx:0, vy:0,
            arrived: false
          });
        }
        this.t=0;
      },
      step(){
        this.t++;
        const N=this.pts.length;
        const rest=6.8;
        const k=0.13;
        const damp=0.90;
        const brown=0.38;

        // polymer springs + bend
        for (let i=0;i<N-1;i++){
          const a=this.pts[i], b=this.pts[i+1];
          const dx=b.x-a.x, dy=b.y-a.y;
          const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
          const f=k*(r-rest);
          const fx=f*dx/r, fy=f*dy/r;
          this.v[i].vx += fx; this.v[i].vy += fy;
          this.v[i+1].vx -= fx; this.v[i+1].vy -= fy;
        }
        for (let i=1;i<N-1;i++){
          const p0=this.pts[i-1], p1=this.pts[i], p2=this.pts[i+1];
          const mx=0.5*(p0.x+p2.x), my=0.5*(p0.y+p2.y);
          this.v[i].vx += 0.006*(mx-p1.x);
          this.v[i].vy += 0.006*(my-p1.y);
        }

        // anchor attraction & exclusion (cluster region)
        const pull=0.010;
        const R=190;
        const hardR=65;
        for (let i=0;i<N;i++){
          const p=this.pts[i];
          const dx=this.anchor.x - p.x;
          const dy=this.anchor.y - p.y;
          const d=Math.sqrt(dx*dx+dy*dy)+1e-6;
          if (d<R){
            const s=(1-d/R);
            this.v[i].vx += pull*s*dx;
            this.v[i].vy += pull*s*dy;
          }
          if (d<hardR){
            const push=(hardR-d)*0.08;
            this.v[i].vx += push*(p.x-this.anchor.x)/d;
            this.v[i].vy += push*(p.y-this.anchor.y)/d;
          }
        }

        // integrate polymer
        const W=canvas.width, H=canvas.height;
        for (let i=0;i<N;i++){
          this.v[i].vx += brown*randn();
          this.v[i].vy += brown*randn();
          this.v[i].vx *= damp;
          this.v[i].vy *= damp;
          this.pts[i].x += this.v[i].vx;
          this.pts[i].y += this.v[i].vy;

          const margin=50, kw=0.0022;
          if (this.pts[i].x < margin) this.v[i].vx += kw*(margin - this.pts[i].x);
          if (this.pts[i].x > W-margin) this.v[i].vx -= kw*(this.pts[i].x - (W-margin));
          if (this.pts[i].y < margin) this.v[i].vy += kw*(margin - this.pts[i].y);
          if (this.pts[i].y > H-margin) this.v[i].vy -= kw*(this.pts[i].y - (H-margin));
        }

        // big TFs drift to anchor slowly (more & more “join”)
        const drift = 0.0012;
        for (const tf of this.bigs){
          tf.vx += 0.40*randn();
          tf.vy += 0.40*randn();

          // “recruitment”: after some time, bias increases
          const recruit = Math.min(0.001 + this.t*0.0000025, 0.0038);
          tf.vx += recruit*(this.anchor.x - tf.x);
          tf.vy += recruit*(this.anchor.y - tf.y);

          tf.vx *= 0.92;
          tf.vy *= 0.92;
          tf.x += tf.vx;
          tf.y += tf.vy;

          // keep in bounds
          if (tf.x<0) tf.x += W;
          if (tf.x>W) tf.x -= W;
          if (tf.y<0) tf.y += H;
          if (tf.y>H) tf.y -= H;
        }
      },
      draw(){
        // cluster glow
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        glowCircle(this.anchor.x,this.anchor.y, 150, "rgba(255,120,200,0.020)", 190);
        glowCircle(this.anchor.x,this.anchor.y, 90,  "rgba(255,60,60,0.020)", 150);
        ctx.restore();

        // polymer
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.25)";
        ctx.lineWidth=3.4;
        ctx.beginPath();
        for (let i=0;i<this.pts.length;i++){
          const p=this.pts[i];
          if (i===0) ctx.moveTo(p.x,p.y);
          else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
        ctx.restore();
        for (const p of this.pts){
          glowCircle(p.x,p.y, 4.0, "rgba(255,255,255,0.55)", 16);
        }

        // big TFs
        for (const tf of this.bigs){
          glowCircle(tf.x, tf.y, 34, "rgba(255,60,60,0.82)", 36);
        }
        // anchor TF (central)
        glowCircle(this.anchor.x,this.anchor.y, 44, "rgba(255,60,60,0.95)", 42);
      }
    };

    // Act 8: one polymer with many clusters (5–6)
    const A8 = {
      pts: [], v: [],
      hubs: [],
      init(){
        const W=canvas.width, H=canvas.height;
        const N=260;
        this.pts = [];
        this.v = new Array(N).fill(0).map(_=>({vx:0,vy:0}));
        const x0=W*0.08, y0=H*0.55;
        const dx=(W*0.84)/(N-1);
        for (let i=0;i<N;i++){
          this.pts.push({x:x0+i*dx, y:y0 + H*0.12*Math.sin(i*0.16)});
        }
        // 6 hubs spaced along
        this.hubs = [
          {x:W*0.20,y:H*0.40},
          {x:W*0.35,y:H*0.62},
          {x:W*0.48,y:H*0.47},
          {x:W*0.60,y:H*0.68},
          {x:W*0.73,y:H*0.44},
          {x:W*0.84,y:H*0.58}
        ];
        this.t=0;
      },
      step(){
        this.t++;
        const N=this.pts.length;
        const rest=7.0;
        const k=0.11;
        const damp=0.92;
        const brown=0.42;

        // springs
        for (let i=0;i<N-1;i++){
          const a=this.pts[i], b=this.pts[i+1];
          const dx=b.x-a.x, dy=b.y-a.y;
          const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
          const f=k*(r-rest);
          const fx=f*dx/r, fy=f*dy/r;
          this.v[i].vx += fx; this.v[i].vy += fy;
          this.v[i+1].vx -= fx; this.v[i+1].vy -= fy;
        }
        // bend smoothing
        for (let i=1;i<N-1;i++){
          const p0=this.pts[i-1], p1=this.pts[i], p2=this.pts[i+1];
          const mx=0.5*(p0.x+p2.x), my=0.5*(p0.y+p2.y);
          this.v[i].vx += 0.004*(mx-p1.x);
          this.v[i].vy += 0.004*(my-p1.y);
        }

        // pull each bead to nearest hub a bit (creates 5–6 clusters along)
        const pull = 0.0042;
        const R = 170;
        for (let i=0;i<N;i++){
          const p=this.pts[i];
          let best={d2:Infinity,h:this.hubs[0]};
          for (const h of this.hubs){
            const dx=h.x-p.x, dy=h.y-p.y;
            const d2=dx*dx+dy*dy;
            if (d2<best.d2) best={d2,h};
          }
          const d=Math.sqrt(best.d2)+1e-6;
          if (d<R){
            const s=(1-d/R);
            this.v[i].vx += pull*s*(best.h.x - p.x);
            this.v[i].vy += pull*s*(best.h.y - p.y);
          }
        }

        // integrate
        const W=canvas.width, H=canvas.height;
        for (let i=0;i<N;i++){
          this.v[i].vx += brown*randn();
          this.v[i].vy += brown*randn();
          this.v[i].vx *= damp;
          this.v[i].vy *= damp;
          this.pts[i].x += this.v[i].vx;
          this.pts[i].y += this.v[i].vy;

          const margin=55, kw=0.002;
          if (this.pts[i].x < margin) this.v[i].vx += kw*(margin - this.pts[i].x);
          if (this.pts[i].x > W-margin) this.v[i].vx -= kw*(this.pts[i].x - (W-margin));
          if (this.pts[i].y < margin) this.v[i].vy += kw*(margin - this.pts[i].y);
          if (this.pts[i].y > H-margin) this.v[i].vy -= kw*(this.pts[i].y - (H-margin));
        }
      },
      draw(){
        // hub glows
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        for (const h of this.hubs){
          glowCircle(h.x,h.y, 95, "rgba(255,120,200,0.018)", 140);
          glowCircle(h.x,h.y, 58, "rgba(255,60,60,0.016)", 120);
        }
        ctx.restore();

        // polymer
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.24)";
        ctx.lineWidth=3.2;
        ctx.beginPath();
        for (let i=0;i<this.pts.length;i++){
          const p=this.pts[i];
          if (i===0) ctx.moveTo(p.x,p.y);
          else ctx.lineTo(p.x,p.y);
        }
        ctx.stroke();
        ctx.restore();

        // beads
        for (const p of this.pts){
          glowCircle(p.x,p.y, 3.8, "rgba(255,255,255,0.50)", 14);
        }

        // draw “cluster beads” (big TF-like blobs) at hubs
        for (const h of this.hubs){
          glowCircle(h.x,h.y, 18, "rgba(255,60,60,0.80)", 30);
        }
      }
    };

    function initAct(force){
      const mode = ACTS[act].mode;
      if (mode === "dna" || mode === "epi"){
        // nothing persistent needed
        return;
      }
      if (mode === "act4_compaction") A4.init();
      if (mode === "act5_free_tfs") A5.init();
      if (mode === "act6_big_tf_wrap") A6.init();
      if (mode === "act7_recruit_more") A7.init();
      if (mode === "act8_many_clusters") A8.init();
    }

    function stepAndDraw(){
      drawBackground();

      const mode = ACTS[act].mode;

      if (mode === "dna"){
        drawDNAHelix("dna");
        return;
      }
      if (mode === "epi"){
        drawDNAHelix("epi");
        return;
      }

      if (mode === "act4_compaction"){
        A4.step(); A4.draw();
        return;
      }
      if (mode === "act5_free_tfs"){
        A5.step(); A5.draw();
        return;
      }
      if (mode === "act6_big_tf_wrap"){
        A6.step(); A6.draw();
        return;
      }
      if (mode === "act7_recruit_more"){
        A7.step(); A7.draw();
        return;
      }
      if (mode === "act8_many_clusters"){
        A8.step(); A8.draw();
        return;
      }
    }

    function tick(){
      resizeCanvas();
      stepAndDraw();
      requestAnimationFrame(tick);
    }

    // Start
    resizeCanvas();
    applyAct();
    tick();
  </script>
</body>
</html>












