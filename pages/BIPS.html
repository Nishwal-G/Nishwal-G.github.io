<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BIPS Explainer | Nishwal Gora</title>

  <link rel="stylesheet" href="../stylesheets/bips_style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body class="dark">

  <!-- Top progress bar -->
  <div id="scroll-progress"></div>

  <!-- Header / nav (kept consistent with your site) -->
  <header class="site-header">
    <div class="header-inner">
      <a class="brand" href="../index.html">Nishwal Gora</a>
      <nav class="site-nav">
        <ul class="nav-pill">
          <li><a href="../index.html">Home</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="cv.html">CV</a></li>
          <li><a href="about.html">About Me</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="more.html">More</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Fixed “stage” (visual stays in center; slides change it) -->
  <div class="stage" aria-hidden="true">
    <canvas id="stageCanvas" width="1400" height="900"></canvas>

    <!-- Optional: tiny HUD -->
    <div class="hud">
      <div class="hud-title" id="hudTitle">DNA</div>
      <div class="hud-sub" id="hudSub">Scroll to build the story</div>
    </div>
  </div>

  <!-- Fullscreen slide deck -->
  <main class="deck" id="deck">

    <section class="slide" data-scene="dna">
      <div class="slide-inner">
        <h1>DNA</h1>
        <p>
          DNA is a long molecule made from four “letters”: A, C, G, T.
          The order stores biological information.
        </p>
        <p class="hint">Scroll ↓</p>
      </div>
    </section>

    <section class="slide" data-scene="genes">
      <div class="slide-inner">
        <h1>Genes</h1>
        <p>
          A gene is a segment of DNA that can be “read” to make RNA (and often proteins).
          Different cells use different genes.
        </p>
      </div>
    </section>

    <section class="slide" data-scene="packing">
      <div class="slide-inner">
        <h1>The packing problem</h1>
        <p>
          Human cells contain ~2 metres of DNA packed into a nucleus only a few microns wide.
          DNA must fold and organise in 3D.
        </p>
      </div>
    </section>

    <section class="slide" data-scene="chromatin">
      <div class="slide-inner">
        <h1>Chromatin</h1>
        <p>
          Chromatin is DNA + proteins. Physically it behaves like a flexible polymer — a moving chain.
        </p>
        <p class="mini">Try: click & drag the chain (in the visual).</p>
      </div>
    </section>

    <section class="slide" data-scene="tfs">
      <div class="slide-inner">
        <h1>Transcription factors</h1>
        <p>
          TFs are proteins that float around and bind specific DNA sites.
          Think: sticky particles that recognise certain beads.
        </p>
        <p class="mini">Try: drag a TF onto a special site.</p>
      </div>
    </section>

    <section class="slide" data-scene="bips">
      <div class="slide-inner">
        <h1>BIPS</h1>
        <p>
          If a TF can bind two sites at once, it makes a <strong>bridge</strong>.
          Bridges pull DNA together, increasing local density → more binding → clusters.
        </p>
        <p class="mini">This is positive feedback in 3D.</p>
      </div>
    </section>

    <section class="slide" data-scene="takehome">
      <div class="slide-inner">
        <h1>Take-home</h1>
        <p>
          DNA isn’t only a code — it’s also a physical object. Its folding can influence regulation,
          and mechanisms like BIPS can create hubs that may support cellular memory.
        </p>
        <p class="hint">End</p>
      </div>
    </section>

  </main>

  <footer class="footer">
    <div class="social-links">
      <a href="https://www.linkedin.com/in/nishwal-gora/" class="fa fa-linkedin" target="_blank" rel="noopener noreferrer"></a>
      <a href="https://github.com/Nishwal-G" class="fa fa-github" target="_blank" rel="noopener noreferrer"></a>
    </div>
  </footer>

  <script>
    // =========================
    // Scroll progress bar
    // =========================
    window.addEventListener("scroll", () => {
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const progress = (scrollTop / scrollHeight) * 100;
      document.getElementById("scroll-progress").style.width = progress + "%";
    });

    // =========================
    // PowerPoint feel: detect current slide + update stage
    // =========================
    const slides = Array.from(document.querySelectorAll(".slide"));
    const hudTitle = document.getElementById("hudTitle");
    const hudSub = document.getElementById("hudSub");

    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    let scene = "dna";

    // --- Simple “morph parameters” per scene (we animate between them) ---
    const targets = {
      dna:      { zoom: 1.35, chain: 0.0, tfs: 0.0, bridges: 0.0 },
      genes:    { zoom: 1.20, chain: 0.0, tfs: 0.0, bridges: 0.0 },
      packing:  { zoom: 0.95, chain: 0.2, tfs: 0.0, bridges: 0.0 },
      chromatin:{ zoom: 0.75, chain: 1.0, tfs: 0.0, bridges: 0.0 },
      tfs:      { zoom: 0.70, chain: 1.0, tfs: 1.0, bridges: 0.0 },
      bips:     { zoom: 0.62, chain: 1.0, tfs: 1.0, bridges: 1.0 },
      takehome: { zoom: 0.62, chain: 1.0, tfs: 0.8, bridges: 1.0 },
    };

    // current animated state (eases toward target)
    let anim = { zoom: 1.35, chain: 0.0, tfs: 0.0, bridges: 0.0 };

    // chain points
    const state = {
      chain: [],
      chainGrab: null,
      tf: { x: 1050, y: 520, r: 26, grabbed: false, boundIndex: null },
      bridges: []
    };

    function initChain() {
      state.chain = [];
      const n = 28;
      for (let i = 0; i < n; i++) {
        state.chain.push({
          x: 360 + i * 26,
          y: 520 + 55 * Math.sin(i * 0.32),
          special: (i % 6 === 0)
        });
      }
      state.chainGrab = null;
      state.tf.x = 1050; state.tf.y = 520; state.tf.grabbed = false; state.tf.boundIndex = null;
      state.bridges = [];
    }
    initChain();

    function lerp(a,b,t){ return a + (b-a)*t; }

    function draw() {
      // ease anim → target
      const tgt = targets[scene] || targets.dna;
      anim.zoom    = lerp(anim.zoom, tgt.zoom, 0.07);
      anim.chain   = lerp(anim.chain, tgt.chain, 0.07);
      anim.tfs     = lerp(anim.tfs, tgt.tfs, 0.07);
      anim.bridges = lerp(anim.bridges, tgt.bridges, 0.07);

      // background
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // subtle stars/noise (cheap and pretty)
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      for (let i=0;i<140;i++){
        const x = (i*97) % canvas.width;
        const y = (i*181) % canvas.height;
        ctx.fillRect(x,y,2,2);
      }

      // transform “zoom”
      ctx.save();
      const cx = canvas.width/2, cy = canvas.height/2;
      ctx.translate(cx, cy);
      ctx.scale(anim.zoom, anim.zoom);
      ctx.translate(-cx, -cy);

      // draw DNA “letters” (fade out as chain fades in)
      const dnaAlpha = 1.0 - anim.chain;
      if (dnaAlpha > 0.02) drawDNA(dnaAlpha);

      // draw chain (fade in)
      if (anim.chain > 0.02) drawChain(anim.chain);

      // TFs appear
      if (anim.tfs > 0.02) drawTF(anim.tfs);

      // bridges appear
      if (anim.bridges > 0.02) drawBridges(anim.bridges);

      ctx.restore();

      // Title text on canvas (glowy)
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "700 36px system-ui";
      ctx.fillText("Build-up animation", 40, 70);
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "18px system-ui";
      ctx.fillText("Scroll → the visual morphs like a slide deck", 40, 105);

      requestAnimationFrame(draw);
    }

    function glowStroke(alpha, w){
      ctx.shadowColor = "rgba(255,255,255,0.25)";
      ctx.shadowBlur = 18;
      ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
      ctx.lineWidth = w;
    }
    function glowFill(alpha){
      ctx.shadowColor = "rgba(255,255,255,0.18)";
      ctx.shadowBlur = 18;
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    }

    function drawDNA(alpha){
      // letters row
      const letters = ["A","C","G","T","A","T","C","G","A","C","T","G"];
      ctx.font = "700 46px system-ui";
      for (let i=0;i<letters.length;i++){
        const x = 220 + i*82;
        const y = 470;
        glowFill(0.10*alpha);
        ctx.fillRect(x-26, y-60, 62, 76);
        glowFill(0.85*alpha);
        ctx.fillText(letters[i], x, y);
      }

      // pairing hint
      ctx.shadowBlur = 0;
      ctx.fillStyle = `rgba(255,255,255,${0.55*alpha})`;
      ctx.font = "20px system-ui";
      ctx.fillText("A pairs with T • C pairs with G", 420, 560);
    }

    function drawChain(alpha){
      // links
      glowStroke(0.35*alpha, 6);
      ctx.beginPath();
      state.chain.forEach((p, idx) => {
        if (idx === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();

      // beads
      state.chain.forEach(p => {
        ctx.beginPath();
        const a = p.special ? 0.70*alpha : 0.35*alpha;
        glowFill(a);
        ctx.arc(p.x, p.y, p.special ? 12 : 9, 0, Math.PI*2);
        ctx.fill();
      });
    }

    function drawTF(alpha){
      const tf = state.tf;
      glowFill(0.75*alpha);
      ctx.beginPath();
      ctx.arc(tf.x, tf.y, tf.r, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = `rgba(0,0,0,${0.7*alpha})`;
      ctx.font = "700 18px system-ui";
      ctx.fillText("TF", tf.x - 14, tf.y + 7);
    }

    function drawBridges(alpha){
      glowStroke(0.65*alpha, 3.5);
      for (const b of state.bridges) {
        const p1 = state.chain[b.i];
        const p2 = state.chain[b.j];
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      // cluster glow region
      if (state.bridges.length > 0) {
        ctx.shadowBlur = 40;
        ctx.fillStyle = `rgba(255,255,255,${0.05*alpha})`;
        ctx.fillRect(560, 390, 320, 320);
        ctx.shadowBlur = 0;
        ctx.fillStyle = `rgba(255,255,255,${0.6*alpha})`;
        ctx.font = "18px system-ui";
        ctx.fillText("density ↑ → more binding", 605, 425);
      }
    }

    // Slide observer
    const io = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          scene = e.target.dataset.scene;
          hudTitle.textContent = scene.toUpperCase();
          hudSub.textContent = "Scroll to build the story";
        }
      });
    }, { threshold: 0.6 });

    slides.forEach(s => io.observe(s));

    // Minimal interactions: drag chain + TF when relevant
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
      return {x,y};
    }
    function dist(a,b){
      const dx=a.x-b.x, dy=a.y-b.y;
      return Math.sqrt(dx*dx+dy*dy);
    }
    function nearestPoint(pos, maxD=22){
      let best = {idx:-1, d:Infinity};
      state.chain.forEach((p,i)=>{
        const d = dist(pos,p);
        if (d < best.d) best = {idx:i, d};
      });
      return best.d <= maxD ? best : null;
    }

    canvas.addEventListener("mousedown",(e)=>{
      const pos=getMousePos(e);

      // drag TF in tfs/bips scenes
      if ((scene==="tfs"||scene==="bips") && dist(pos, state.tf) <= state.tf.r+8){
        state.tf.grabbed=true;
        return;
      }

      // drag chain in chromatin+
      if (scene==="chromatin"||scene==="tfs"||scene==="bips"){
        const near=nearestPoint(pos, 18);
        if (near) state.chainGrab=near.idx;
      }
    });

    canvas.addEventListener("mousemove",(e)=>{
      const pos=getMousePos(e);
      if (state.tf.grabbed){
        state.tf.x=pos.x; state.tf.y=pos.y;
      }
      if (state.chainGrab !== null){
        const p=state.chain[state.chainGrab];
        p.x=pos.x; p.y=pos.y;
      }
    });

    window.addEventListener("mouseup",()=>{
      if (state.tf.grabbed){
        state.tf.grabbed=false;
        if (scene==="tfs"||scene==="bips"){
          const near = nearestPoint(state.tf, 30);
          if (near && state.chain[near.idx].special){
            state.tf.boundIndex = near.idx;
            state.tf.x = state.chain[near.idx].x;
            state.tf.y = state.chain[near.idx].y - 45;

            // In BIPS: add a bridge the first time you bind
            if (scene==="bips" && state.bridges.length===0){
              let j=-1, best=Infinity;
              for (let k=0;k<state.chain.length;k++){
                if (k!==near.idx && state.chain[k].special){
                  const d=Math.abs(k-near.idx);
                  if (d<best){best=d; j=k;}
                }
              }
              if (j>=0) state.bridges.push({i: near.idx, j});
            }
          }
        }
      }
      state.chainGrab=null;
    });

    // Reset button via HUD click (optional)
    document.addEventListener("keydown",(e)=>{
      if (e.key.toLowerCase()==="r"){
        initChain();
      }
    });

    draw();
  </script>
</body>
</html>

