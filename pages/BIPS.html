<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How do cells remember who they are? | DNA ‚Üí Chromatin ‚Üí BIPS</title>

  <style>
    :root{
      --bg: #050507;
      --panel: rgba(0,0,0,0.55);
      --panel2: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);

      --green: rgba(0,255,140,0.95);
      --greenDim: rgba(0,255,140,0.45);
      --red: rgba(255,60,60,0.92);
      --redDim: rgba(255,60,60,0.55);
      --pink: rgba(255,120,200,0.70);
      --purple: rgba(190,120,255,0.92);

      --maxw: 1100px;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }

    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .page{
      min-height: 100vh;
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
    }

    /* TEXT AREA (ABOVE CANVAS) */
    .textPanel{
      width: min(var(--maxw), 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: rgba(0,0,0,0.46);
      backdrop-filter: blur(12px);
      box-shadow: 0 20px 80px rgba(0,0,0,0.55);
      overflow: hidden;
    }

    .textInner{
      padding: 16px 16px 14px 16px;
    }

    .kicker{
      font-weight: 900;
      letter-spacing: 0.3px;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .titleRow{
      display:flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .sceneTitle{
      font-weight: 950;
      letter-spacing: -0.3px;
      font-size: clamp(20px, 2.2vw, 28px);
      margin: 0;
      line-height: 1.1;
    }

    .sceneSub{
      margin-top: 8px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.55;
    }

    .storyText{
      margin-top: 12px;
      color: rgba(255,255,255,0.78);
      font-size: 15px;
      line-height: 1.72;
    }

    .storyText p{
      margin: 10px 0 0 0;
    }

    /* Big clickable glossary-like words */
    .bigClick{
      display:inline-block;
      padding: 4px 10px;
      margin: 0 2px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      font-weight: 950;
      letter-spacing: 0.2px;
      text-transform: uppercase;
      font-size: 13px;
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      user-select:none;
      transform: translateY(-1px);
    }
    .bigClick:hover{
      background: rgba(255,255,255,0.11);
    }
    .bigClick.green{ border-color: rgba(0,255,140,0.30); color: var(--green); }
    .bigClick.purple{ border-color: rgba(190,120,255,0.35); color: var(--purple); }
    .bigClick.white{ border-color: rgba(255,255,255,0.20); color: rgba(255,255,255,0.92); }

    /* Controls right aligned inside text panel */
    .controls{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .pill{
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.38);
      color: rgba(255,255,255,0.90);
      padding: 9px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 900;
      font-size: 13px;
      backdrop-filter: blur(10px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      user-select:none;
    }
    .pill:hover{ background: rgba(255,255,255,0.10); }
    .pill.strong{ background: rgba(255,255,255,0.12); }
    .pill.ghost{ background: rgba(255,255,255,0.04); }
    .pill:disabled{ opacity: 0.35; cursor: default; }

    /* CANVAS PANEL */
    .stage{
      width: min(var(--maxw), 100%);
      height: min(62vh, 720px);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      overflow: hidden;
      background: rgba(0,0,0,0.25);
      position: relative;
    }

    #stageCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    .legend{
      position:absolute;
      left: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(0,0,0,0.32);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.70);
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;

      opacity: 0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .legend.show{ opacity: 1; transform: translateY(0); }

    .dot{
      display:inline-block;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .dot.white{ background: rgba(255,255,255,0.85); }
    .dot.green{ background: var(--green); }
    .dot.red{ background: var(--red); }
    .dot.pink{ background: var(--pink); }
    .dot.purple{ background: var(--purple); }

    @media (max-width: 860px){
      .stage{ height: 52vh; }
    }
  </style>
</head>

<body>
  <div class="page">
    <!-- TEXT ABOVE CANVAS -->
    <section class="textPanel" aria-label="Story text">
      <div class="textInner">
        <div class="kicker" id="kicker">Interactive story (8 acts)</div>

        <div class="titleRow">
          <h1 class="sceneTitle" id="sceneTitle">Opening ‚Äî How do cells remember who they are?</h1>
        </div>

        <div class="sceneSub" id="sceneSub">
          Read the story, then look at the animation underneath. Use Next / Prev to move through the acts.
        </div>

        <div class="storyText" id="storyText"></div>

        <div class="controls">
          <button class="pill ghost" id="prevBtn" type="button">‚Üê Prev</button>
          <button class="pill ghost" id="resetBtn" type="button" title="Reset this act">‚Üª Reset</button>
          <button class="pill strong" id="nextBtn" type="button">Next ‚Üí</button>
        </div>
      </div>
    </section>

    <!-- CANVAS -->
    <section class="stage" aria-label="Animation canvas">
      <canvas id="stageCanvas"></canvas>

      <div class="legend" id="legend">
        <span class="dot white"></span> chromatin (DNA packed as a chain)
        <span class="dot green"></span> gene / active region
        <span class="dot red"></span> TF (reader)
        <span class="dot pink"></span> hub / factory
        <span class="dot purple"></span> locked DNA
      </div>
    </section>
  </div>

  <script>
    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      return { w: canvas.width, h: canvas.height, dpr };
    }
    window.addEventListener("resize", () => {
      resizeCanvas();
      rebuildClickables = true;
      initActWorld(true);
    });

    // ============================================================
    // UI
    // ============================================================
    const sceneTitle = document.getElementById("sceneTitle");
    const sceneSub   = document.getElementById("sceneSub");
    const storyText  = document.getElementById("storyText");
    const kicker     = document.getElementById("kicker");

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");

    const legend = document.getElementById("legend");

    // RNG helpers
    function randn() {
      let u=0, v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    // ============================================================
    // Clickable words (in text) + clickable labels (on DNA)
    // ============================================================
    let highlight = null; // "basepair" | "gene" | "epi" | null

    function bigWord(label, cssClass, onClickId){
      return `<span class="bigClick ${cssClass}" data-click="${onClickId}">${label}</span>`;
    }

    document.addEventListener("click", (e) => {
      const el = e.target.closest("[data-click]");
      if (!el) return;
      const id = el.getAttribute("data-click");
      if (id === "basepair") highlight = (highlight === "basepair") ? null : "basepair";
      if (id === "gene") highlight = (highlight === "gene") ? null : "gene";
      if (id === "epi") highlight = (highlight === "epi") ? null : "epi";
    });

    // ============================================================
    // Acts definition (richer text, beginner-friendly)
    // ============================================================
    let actIndex = 0;
    let mode = "dna"; // dna | epi | chromatin | act5 | act6 | act7 | act8

    const ACTS = [
      {
        mode: "dna",
        title: "Opening ‚Äî How do cells remember who they are?",
        sub: "This story starts with a mystery: almost every cell in your body has the same DNA ‚Äî so how can cells be so different?",
        html: `
          <p>
            Imagine a huge school where every student is given the <strong>same</strong> instruction book on day one.
            Somehow, one student becomes a chef, another becomes an engineer, another becomes an artist ‚Äî all from the same book.
          </p>
          <p>
            Your body is like that. A skin cell, a neuron, and a red blood cell usually contain the same DNA.
            But they behave differently because they <em>use different parts</em> of the DNA.
            The big question is: <strong>how do cells keep track of which parts to use?</strong>
          </p>
          <p>
            To answer that, we first need to understand what DNA is ‚Äî both as a <strong>code</strong> and as a <strong>physical object</strong>.
            In the animation, you‚Äôre looking at DNA as a twisted ladder called a <strong>double helix</strong>.
            Click ${bigWord("BASE PAIR", "white", "basepair")} and ${bigWord("GENE", "green", "gene")} when you see them to learn what they mean.
          </p>
        `,
        showLegend: false
      },
      {
        mode: "dna",
        title: "Act 1 ‚Äî What is DNA?",
        sub: "DNA is information written in a 4-letter alphabet. The order matters ‚Äî like letters in a word.",
        html: `
          <p>
            DNA is like a long message written using just <strong>four letters</strong>: A, C, G, and T.
            That might sound too simple ‚Äî but even with 26 letters you can write every book ever written.
            With four letters, life writes the instructions to build and run a cell.
          </p>
          <p>
            DNA is shaped like a twisted ladder. The rails are the backbone. The rungs are pairs of letters.
            Those rungs are called ${bigWord("BASE PAIRS", "white", "basepair")}.
            A pairs with T, and C pairs with G ‚Äî like matching puzzle pieces.
          </p>
          <p>
            The key idea: DNA is not just ‚Äústuff‚Äù. It is a <strong>sequence</strong>. The order of base pairs is the message.
            If you change the order, you change the meaning (like changing letters in a sentence).
          </p>
        `,
        showLegend: false
      },
      {
        mode: "dna",
        title: "Act 2 ‚Äî What is a gene?",
        sub: "If base pairs are the letters, genes are meaningful ‚Äúsentences‚Äù that the cell can copy and use.",
        html: `
          <p>
            If ${bigWord("BASE PAIRS", "white", "basepair")} are the letters of the DNA alphabet, then a
            ${bigWord("GENE", "green", "gene")} is like a <strong>sentence</strong> (or a recipe) inside the giant DNA book.
          </p>
          <p>
            When a cell ‚Äúreads‚Äù a gene, it first makes an RNA copy.
            That RNA can then help build a protein (a working molecule) ‚Äî like turning a recipe into an actual meal.
          </p>
          <p>
            Different cell types read different genes. That is a big part of why a skin cell acts like skin
            and a neuron acts like a neuron.
          </p>
        `,
        showLegend: false
      },
      {
        mode: "epi",
        title: "Act 3 ‚Äî Epigenetics: keeping the wrong pages closed",
        sub: "Cells use chemical marks to make some DNA regions harder to access ‚Äî like locking chapters of a book.",
        html: `
          <p>
            Cells don‚Äôt want to read every gene all the time. A skin cell doesn‚Äôt need to act like a neuron.
            So cells use ${bigWord("EPIGENETICS", "purple", "epi")} ‚Äî chemical marks and packaging changes ‚Äî
            to make some regions of DNA <strong>harder to access</strong>.
          </p>
          <p>
            Think of it like sticky notes and padlocks on a textbook: some chapters are easy to open, others are ‚Äúlocked‚Äù.
            In the animation, locked regions are shown in <span style="color: rgba(190,120,255,0.95); font-weight:900;">purple</span>.
            Click ${bigWord("EPIGENETICS", "purple", "epi")} or the ‚ÄúLocked region‚Äù label to highlight them.
          </p>
          <p>
            This is one way cells keep their identity stable when they divide. But it‚Äôs not the whole story.
            Next we‚Äôll use a surprising idea: DNA also has <strong>physics</strong> ‚Äî it moves, bends, and folds.
          </p>
        `,
        showLegend: false
      },
      {
        mode: "chromatin",
        title: "Act 4 ‚Äî DNA is not a straight line: it folds into chromatin",
        sub: "DNA is incredibly long, so it packs into the nucleus by folding. We can model it as a moving polymer chain.",
        html: `
          <p>
            Here‚Äôs a mind-blowing fact: if you stretched out the DNA in a single human cell, it would be about <strong>2 metres</strong> long.
            But the nucleus is tiny ‚Äî only a few micrometres wide.
          </p>
          <p>
            So DNA is packaged into ${bigWord("CHROMATIN", "white", "basepair")}: DNA plus proteins, folded into a 3D structure.
            Physicists often model chromatin as a flexible chain (a <strong>polymer</strong>) made of connected beads.
          </p>
          <p>
            In this cartoon, each bead represents a huge chunk of DNA ‚Äî think <strong>millions of base pairs</strong> per bead.
            Press ‚Üª Reset any time from now on to replay an act.
          </p>
        `,
        showLegend: true
      },
      {
        mode: "act5",
        title: "Act 5 ‚Äî Who reads genes? Transcription factors",
        sub: "Proteins called transcription factors (TFs) float around randomly. Sometimes they stick to gene regions.",
        html: `
          <p>
            To ‚Äúread‚Äù genes, cells use proteins called <strong>transcription factors</strong> (TFs).
            In the nucleus they float around, jiggling and drifting randomly ‚Äî like pollen grains in water.
          </p>
          <p>
            Some parts of chromatin are special (gene-regulatory regions). We mark those as
            <span style="color: rgba(0,255,140,0.95); font-weight:900;">green</span>.
            TFs are shown as <span style="color: rgba(255,60,60,0.92); font-weight:900;">red</span> particles.
          </p>
          <p>
            In this act, TFs mostly wander. They only have a <em>gentle</em> preference for green sites ‚Äî
            so you see the ‚Äúsearch‚Äù process rather than instant sticking.
          </p>
        `,
        showLegend: true
      },
      {
        mode: "act6",
        title: "Act 6 ‚Äî Why folding matters: one cluster gets read more",
        sub: "If two gene regions are close together, TFs bump into them more and gather there ‚Äî while isolated genes get less attention.",
        html: `
          <p>
            Now the key physical idea: if two gene regions are brought close together (by folding),
            they form a denser ‚Äúneighbourhood‚Äù. TFs bump into that neighbourhood more often, so more TFs gather there.
          </p>
          <p>
            Watch what happens: two green zones are pulled together into one cluster.
            A third green zone stays more isolated ‚Äî it still exists, but it gets fewer TF visits.
          </p>
          <p>
            This gives a simple intuition: <strong>3D organisation can bias which genes are read</strong>,
            even before you talk about complicated biochemistry.
          </p>
        `,
        showLegend: true
      },
      {
        mode: "act7",
        title: "Act 7 ‚Äî BIPS: bridges can create clusters (and leave some genes unread)",
        sub: "Bridging-induced attraction can create multiple hubs ‚Äî but not every gene has to be ‚Äòsticky‚Äô in the same way.",
        html: `
          <p>
            One proposed physical mechanism is ‚Äúbridging‚Äù: a TF can effectively connect nearby chromatin segments.
            When bridges form, chromatin gets pulled together into hubs. Hubs then attract even more TFs.
            This feedback can create clusters ‚Äî a bit like how crowds form around something interesting.
          </p>
          <p>
            In this animation, you will see <strong>2‚Äì3 hubs</strong> form across the chain.
            But some green regions are deliberately made ‚Äúless sticky‚Äù, so they remain relatively quiet ‚Äî
            they are like genes that exist but are not being strongly read right now.
          </p>
        `,
        showLegend: true
      },
      {
        mode: "act8",
        title: "Act 8 ‚Äî The big picture: transcription factories",
        sub: "A final cartoon: active ‚Äòfactories‚Äô where genes are being read, and quieter regions elsewhere.",
        html: `
          <p>
            Many researchers think gene activity can be organised into ‚Äútranscription factories‚Äù:
            places where gene regions and TFs are concentrated, making it easier to keep genes active.
          </p>
          <p>
            Here we show a static ‚Äúsnapshot‚Äù: a few bright hubs packed with TFs (active reading),
            and large quiet regions with few TFs (little reading).
          </p>
          <p>
            This gives a possible route to <strong>cellular memory</strong>:
            if the 3D structure tends to re-form the same hubs, a cell might more easily keep the same genes ON over time.
          </p>
        `,
        showLegend: true
      }
    ];

    function applyAct(i){
      actIndex = clamp(i, 0, ACTS.length - 1);
      const A = ACTS[actIndex];

      mode = A.mode;
      highlight = null;

      kicker.textContent = `Act ${actIndex + 1} of ${ACTS.length}`;
      sceneTitle.textContent = A.title;
      sceneSub.textContent = A.sub;
      storyText.innerHTML = A.html;

      prevBtn.disabled = (actIndex === 0);
      nextBtn.disabled = (actIndex === ACTS.length - 1);
      resetBtn.style.display = (actIndex >= 3) ? "inline-flex" : "none";

      if (A.showLegend) legend.classList.add("show");
      else legend.classList.remove("show");

      rebuildClickables = true;
      initActWorld(true);
    }

    prevBtn.addEventListener("click", () => applyAct(actIndex - 1));
    nextBtn.addEventListener("click", () => applyAct(actIndex + 1));
    resetBtn.addEventListener("click", () => initActWorld(true));

    // ============================================================
    // Clickable labels drawn on DNA (canvas)
    // ============================================================
    let rebuildClickables = true;
    const clickables = []; // {id, x,y,w,h}
    function clearClickables(){ clickables.length = 0; }
    function addClickable(id, x, y, w, h){ clickables.push({id, x, y, w, h}); }

    function mouseToCanvas(e){
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left);
      const sy = (e.clientY - rect.top);
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: sx * scaleX, y: sy * scaleY };
    }

    canvas.addEventListener("click", (e) => {
      if (!(mode === "dna" || mode === "epi")) return;
      const p = mouseToCanvas(e);
      for (let i = clickables.length - 1; i >= 0; i--) {
        const c = clickables[i];
        if (p.x >= c.x && p.x <= c.x + c.w && p.y >= c.y && p.y <= c.y + c.h) {
          if (c.id === "basepairs") highlight = (highlight === "basepair") ? null : "basepair";
          if (c.id === "gene") highlight = (highlight === "gene") ? null : "gene";
          if (c.id === "locked") highlight = (highlight === "epi") ? null : "epi";
          break;
        }
      }
    });

    function roundRect(x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawLabelWithArrow(label, xText, yText, xTo, yTo, color, id){
      ctx.save();
      ctx.font = "900 14px system-ui";
      const padX = 10;
      const textW = ctx.measureText(label).width;
      const w = textW + 2*padX;
      const h = 28;

      // Arrow
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.70;
      ctx.beginPath();
      ctx.moveTo(xText + w*0.5, yText + h);
      ctx.lineTo(xTo, yTo);
      ctx.stroke();

      // Pill
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(0,0,0,0.40)";
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      roundRect(xText, yText, w, h, 999, true, true);

      ctx.fillStyle = color;
      ctx.fillText(label, xText + padX, yText + 19);
      ctx.restore();

      addClickable(id, xText, yText, w, h);
    }

    // ============================================================
    // Drawing helpers
    // ============================================================
    function drawBackground(){
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(255,255,255,0.035)";
      for (let i=0;i<140;i++){
        const x=(i*97)%canvas.width;
        const y=(i*181)%canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }

    function glowCircle(x,y,r,color,blur=18){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // ============================================================
    // DNA helix (acts 0‚Äì3)
    // ============================================================
    function drawDNAHelix(){
      const W = canvas.width, H = canvas.height;
      const cx = W * 0.52;
      const cy = H * 0.56;
      const amp = H * 0.14;
      const pitch = W * 0.022;
      const turns = 44;
      const tNow = performance.now() * 0.0016;

      const baseHi = (highlight === "basepair");
      const geneHi = (highlight === "gene");
      const epiHi  = (highlight === "epi");

      const geneStart = 15;
      const geneEnd   = 24;

      const lockSegments = [
        { a: 7,  b: 12 },
        { a: 28, b: 33 }
      ];

      function isLocked(i){
        for (const seg of lockSegments){
          if (i >= seg.a && i <= seg.b) return true;
        }
        return false;
      }

      // Purple ‚Äúlocked‚Äù curtains behind locked segments
      if (mode === "epi") {
        ctx.save();
        ctx.globalAlpha = epiHi ? 0.26 : 0.18;
        ctx.fillStyle = "rgba(170, 90, 255, 1)";
        const x0 = cx - (turns*pitch)/2;
        for (const seg of lockSegments){
          const xa = x0 + seg.a*pitch - pitch*0.6;
          const xb = x0 + seg.b*pitch + pitch*0.6;
          roundRect(xa, cy - amp*1.35, (xb-xa), amp*2.7, 16, true, false);
        }
        ctx.restore();
      }

      for (let i=0;i<turns;i++){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);

        const inGene = (i>=geneStart && i<=geneEnd);
        const locked = isLocked(i);

        // rung styling
        let rungColor = "rgba(255,255,255,0.20)";
        let rungWidth = 2.0;

        if (geneHi && inGene) { rungColor = "rgba(0,255,140,0.92)"; rungWidth = 3.0; }
        else if (baseHi && (i%4===0)) { rungColor = "rgba(255,255,255,0.92)"; rungWidth = 3.0; }

        if (mode === "epi" && locked) {
          rungColor = epiHi ? "rgba(230, 200, 255, 0.95)" : "rgba(230, 200, 255, 0.55)";
          rungWidth = epiHi ? 3.0 : 2.2;
        }

        ctx.save();
        ctx.strokeStyle = rungColor;
        ctx.lineWidth = rungWidth;
        ctx.beginPath();
        ctx.moveTo(x,y1);
        ctx.lineTo(x,y2);
        ctx.stroke();
        ctx.restore();

        // backbones
        let backboneColor = "rgba(255,255,255,0.55)";
        if (geneHi && inGene) backboneColor = "rgba(0,255,140,0.65)";
        if (mode === "epi" && locked) backboneColor = epiHi ? "rgba(190, 120, 255, 0.80)" : "rgba(190, 120, 255, 0.50)";

        glowCircle(x, y1, 5.0, backboneColor, 18);
        glowCircle(x, y2, 5.0, backboneColor, 18);

        if (mode === "epi" && locked && (i % 3 === 0)) {
          ctx.save();
          ctx.font = "900 14px system-ui";
          ctx.fillStyle = epiHi ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.70)";
          ctx.shadowColor = "rgba(190,120,255,0.55)";
          ctx.shadowBlur = 16;
          ctx.fillText("üîí", x - 7, (0.5*(y1+y2)) + 5);
          ctx.restore();
        }
      }

      // clickable labels
      if (rebuildClickables) { clearClickables(); rebuildClickables = false; }

      const baseIdx = 16, geneIdx = 20, lockIdx = 9;
      function helixPoint(i){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);
        return { x, y: 0.5*(y1+y2) };
      }

      const bp = helixPoint(baseIdx);
      const gn = helixPoint(geneIdx);
      const lk = helixPoint(lockIdx);

      const white = "rgba(255,255,255,0.92)";
      const green = "rgba(0,255,140,0.92)";
      const purple = "rgba(190,120,255,0.95)";

      drawLabelWithArrow("Base pairs", W*0.08, H*0.26, bp.x, bp.y, white, "basepairs");
      drawLabelWithArrow("Gene",      W*0.74, H*0.78, gn.x, gn.y, green, "gene");

      if (mode === "epi") {
        drawLabelWithArrow("Locked region", W*0.08, H*0.74, lk.x, lk.y, purple, "locked");
      }
    }

    // ============================================================
    // Polymer / TF worlds (acts 4‚Äì7) + static scene (act 8)
    // ============================================================
    const world = {
      initialised: false,
      beads: [],
      bvx: [],
      bvy: [],
      // gene sites exist; stickiness can differ per act
      isGene: [],
      geneSticky: [],
      tfs: [],
      hubs: [],
      bipsOn: false,
      frame: 0
    };

    const P = {
      beadCount: 230,
      restLen: 9,
      kSpring: 0.18,
      kBend: 0.010,
      damping: 0.92,
      brownian: 0.14,
      beadR: 4.6,
      repelK: 0.55,

      tfCount: 44,
      tfR: 6.5,
      tfBrown: 0.50,
      tfDamp: 0.93,

      bindR: 18,
      bindPull: 0.050,

      // ‚Äúhow sticky‚Äù TFs are to genes differs by act
      geneAttract: 0.0,
      hubAttract: 0.0,

      // hub pull on polymer differs by act
      hubPullAll: 0.0,
      hubPullGene: 0.0
    };

    function initActWorld(force=false){
      const polymerModes = ["chromatin","act5","act6","act7"];
      if (!polymerModes.includes(mode)) return;

      if (world.initialised && !force) return;

      world.initialised = true;
      world.frame = 0;
      resizeCanvas();

      const W = canvas.width, H = canvas.height;

      // polymer
      world.beads = [];
      world.bvx = new Array(P.beadCount).fill(0);
      world.bvy = new Array(P.beadCount).fill(0);
      world.isGene = new Array(P.beadCount).fill(false);
      world.geneSticky = new Array(P.beadCount).fill(false);

      const startX = W * 0.06;
      const midY = H * 0.58;

      for (let i=0;i<P.beadCount;i++){
        const x = startX + i*P.restLen;
        const y = midY + (H*0.05)*Math.sin(i*0.18);
        world.beads.push({x,y});
      }

      // 3 gene regions (green)
      const centers = [
        Math.floor(P.beadCount * 0.26),
        Math.floor(P.beadCount * 0.52),
        Math.floor(P.beadCount * 0.78)
      ];
      for (const c of centers){
        for (let j=-6;j<=6;j++){
          const idx = c + j;
          if (idx>=0 && idx<P.beadCount) world.isGene[idx] = true;
        }
      }

      // Default: all gene beads sticky, unless we override later
      for (let i=0;i<P.beadCount;i++){
        world.geneSticky[i] = world.isGene[i];
      }

      // hubs: positions in space
      world.hubs = [
        { x: W*0.34, y: H*0.50 },
        { x: W*0.56, y: H*0.64 },
        { x: W*0.74, y: H*0.46 }
      ];

      // TFs (only if act >= 5)
      world.tfs = [];
      if (mode === "act5" || mode === "act6" || mode === "act7") {
        for (let i=0;i<P.tfCount;i++){
          world.tfs.push({
            x: W*(0.20 + 0.60*Math.random()),
            y: H*(0.18 + 0.64*Math.random()),
            vx: 0,
            vy: 0,
            boundTo: null
          });
        }
      }

      // Configure per act (make animations distinct)
      if (mode === "chromatin") {
        world.bipsOn = false;
        P.geneAttract = 0.0;
        P.hubAttract = 0.0;
        P.hubPullAll = 0.0;
        P.hubPullGene = 0.0;
      }

      if (mode === "act5") {
        world.bipsOn = false;
        // gentle attraction, lots of wandering
        P.geneAttract = 0.010;
        P.hubAttract = 0.0;
        P.hubPullAll = 0.0;
        P.hubPullGene = 0.0;
      }

      if (mode === "act6") {
        world.bipsOn = false;

        // two gene zones get pulled together (clustered), third stays isolated
        // we do this by placing 2 hubs near each other + stronger pull on gene beads for those hubs only
        world.hubs = [
          { x: W*0.52, y: H*0.52 }, // hub A
          { x: W*0.58, y: H*0.55 }, // hub B (close to A)
          { x: W*0.80, y: H*0.38 }  // hub C far away (weak)
        ];

        P.geneAttract = 0.018;  // TFs start to gather (not instant)
        P.hubAttract = 0.012;   // TF bias toward hubs (makes congregation visible)
        P.hubPullAll = 0.0011;  // polymer gently pulled
        P.hubPullGene = 0.0046; // genes pulled more strongly
      }

      if (mode === "act7") {
        world.bipsOn = true;

        // 2‚Äì3 clusters form, but some green regions are "non-sticky" (unread)
        // We'll pick one gene region to be mostly non-sticky:
        // e.g. the middle region (around 0.52) stays green but doesn't attract TFs much.
        const midCenter = Math.floor(P.beadCount * 0.52);

        for (let i=0;i<P.beadCount;i++){
          if (!world.isGene[i]) continue;

          // if within mid gene band, make it non-sticky
          if (Math.abs(i - midCenter) <= 7) {
            world.geneSticky[i] = false; // still green, but doesn't ‚Äúgrab‚Äù
          } else {
            world.geneSticky[i] = true;
          }
        }

        // three hubs in different places ‚Üí 2‚Äì3 clusters
        world.hubs = [
          { x: W*0.32, y: H*0.54 },
          { x: W*0.56, y: H*0.66 },
          { x: W*0.78, y: H*0.44 }
        ];

        P.geneAttract = 0.020;
        P.hubAttract = 0.014;
        P.hubPullAll = 0.0017;
        P.hubPullGene = 0.0052;
      }
    }

    function springForce(ax, ay, bx, by, rest, k){
      const dx=bx-ax, dy=by-ay;
      const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
      const f=k*(r-rest);
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function bendForce(p0,p1,p2,kB){
      const mx=0.5*(p0.x+p2.x);
      const my=0.5*(p0.y+p2.y);
      return {fx:kB*(mx-p1.x), fy:kB*(my-p1.y)};
    }
    function repelPair(ax, ay, bx, by, minDist, k){
      const dx=bx-ax, dy=by-ay;
      const r2=dx*dx+dy*dy+1e-6;
      const r=Math.sqrt(r2);
      if (r>=minDist) return {fx:0, fy:0};
      const overlap=minDist-r;
      const f=k*overlap;
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function softWalls(x,y,vx,vy){
      const W=canvas.width, H=canvas.height;
      const margin=70;
      const k=0.0018;
      if (x<margin) vx += k*(margin-x);
      if (x>W-margin) vx -= k*(x-(W-margin));
      if (y<margin) vy += k*(margin-y);
      if (y>H-margin) vy -= k*(y-(H-margin));
      return {vx,vy};
    }

    function stepPolymerAndTFs(){
      const n = P.beadCount;

      // springs
      for (let i=0;i<n-1;i++){
        const a=world.beads[i], b=world.beads[i+1];
        const f=springForce(a.x,a.y,b.x,b.y,P.restLen,P.kSpring);
        world.bvx[i] += f.fx; world.bvy[i] += f.fy;
        world.bvx[i+1] -= f.fx; world.bvy[i+1] -= f.fy;
      }

      // bending
      for (let i=1;i<n-1;i++){
        const f=bendForce(world.beads[i-1], world.beads[i], world.beads[i+1], P.kBend);
        world.bvx[i] += f.fx;
        world.bvy[i] += f.fy;
      }

      // excluded volume (local)
      const minBB = 2*P.beadR;
      for (let i=0;i<n;i++){
        const i0=Math.max(0,i-14);
        const i1=Math.min(n-1,i+14);
        for (let j=i0;j<=i1;j++){
          if (j===i) continue;
          if (Math.abs(i-j)<=1) continue;
          const a=world.beads[i], b=world.beads[j];
          const f=repelPair(a.x,a.y,b.x,b.y,minBB,0.55);
          world.bvx[i] -= f.fx; world.bvy[i] -= f.fy;
          world.bvx[j] += f.fx; world.bvy[j] += f.fy;
        }
      }

      // hub pull (only for acts 6 and 7)
      if (mode === "act6" || mode === "act7") {
        for (let i=0;i<n;i++){
          const p=world.beads[i];

          // choose a "target hub" depending on which gene region we're in (for act6)
          let h = world.hubs[0];

          if (mode === "act6") {
            // map each gene region to a hub: first gene -> hub0, second -> hub1, third -> hub2 (far)
            const idxA = Math.floor(n * 0.26);
            const idxB = Math.floor(n * 0.52);
            const idxC = Math.floor(n * 0.78);
            if (Math.abs(i-idxA) < 30) h = world.hubs[0];
            else if (Math.abs(i-idxB) < 30) h = world.hubs[1];
            else if (Math.abs(i-idxC) < 30) h = world.hubs[2];
            else {
              // non-gene beads: mild pull to nearest hub
              let best = {d2: Infinity, h: world.hubs[0]};
              for (const hh of world.hubs){
                const dx=hh.x-p.x, dy=hh.y-p.y;
                const d2=dx*dx+dy*dy;
                if (d2<best.d2) best={d2, h:hh};
              }
              h = best.h;
            }
          } else {
            // act7: nearest hub
            let best = {d2: Infinity, h: world.hubs[0]};
            for (const hh of world.hubs){
              const dx=hh.x-p.x, dy=hh.y-p.y;
              const d2=dx*dx+dy*dy;
              if (d2<best.d2) best={d2, h:hh};
            }
            h = best.h;
          }

          const dx=h.x-p.x, dy=h.y-p.y;
          world.bvx[i] += P.hubPullAll*dx;
          world.bvy[i] += P.hubPullAll*dy;

          // extra pull if gene (or sticky gene depending on act)
          if (world.isGene[i]) {
            world.bvx[i] += P.hubPullGene*dx;
            world.bvy[i] += P.hubPullGene*dy;
          }
        }
      }

      // integrate polymer
      for (let i=0;i<n;i++){
        world.bvx[i] += P.brownian*randn();
        world.bvy[i] += P.brownian*randn();
        world.bvx[i] *= P.damping;
        world.bvy[i] *= P.damping;
        world.beads[i].x += world.bvx[i];
        world.beads[i].y += world.bvy[i];

        const out=softWalls(world.beads[i].x, world.beads[i].y, world.bvx[i], world.bvy[i]);
        world.bvx[i]=out.vx; world.bvy[i]=out.vy;
      }

      // TFs only act5‚Äì7
      if (!(mode === "act5" || mode === "act6" || mode === "act7")) return;

      // nearest gene (but only sticky genes attract strongly)
      function nearestGene(tf){
        let best = {idx: null, d2: Infinity};
        for (let i=0;i<n;i++){
          if (!world.isGene[i]) continue;
          const p=world.beads[i];
          const dx=p.x-tf.x, dy=p.y-tf.y;
          const d2=dx*dx+dy*dy;
          if (d2<best.d2) best={idx:i, d2};
        }
        return best;
      }

      for (const tf of world.tfs){
        // Brownian wandering first (so they don't instantly collapse)
        tf.vx += P.tfBrown*randn();
        tf.vy += P.tfBrown*randn();
        tf.vx *= P.tfDamp;
        tf.vy *= P.tfDamp;

        // Mild attraction to gene if sticky
        const g = nearestGene(tf);
        if (g.idx !== null){
          const bead = world.beads[g.idx];
          const dx=bead.x-tf.x, dy=bead.y-tf.y;

          const sticky = world.geneSticky[g.idx]; // act7 has green-but-not-sticky
          const attract = sticky ? P.geneAttract : (P.geneAttract * 0.15);

          tf.vx += attract*dx;
          tf.vy += attract*dy;

          // hub bias (acts 6 and 7)
          if (mode === "act6" || mode === "act7") {
            let best = {d2: Infinity, h: world.hubs[0]};
            for (const h of world.hubs){
              const hx=h.x-tf.x, hy=h.y-tf.y;
              const d2=hx*hx+hy*hy;
              if (d2<best.d2) best={d2, h};
            }
            tf.vx += P.hubAttract*(best.h.x - tf.x);
            tf.vy += P.hubAttract*(best.h.y - tf.y);
          }

          // Binding: only if near a sticky gene site (so "unread" genes remain)
          const R2 = P.bindR*P.bindR;
          if (tf.boundTo === null && sticky && g.d2 < R2){
            const pBind = (mode === "act5") ? 0.020 : (mode === "act6" ? 0.060 : 0.070);
            if (Math.random() < pBind) tf.boundTo = g.idx;
          } else if (tf.boundTo !== null) {
            const pUnbind = (mode === "act5") ? 0.020 : 0.010;
            if (Math.random() < pUnbind) tf.boundTo = null;
          }
        }

        // If bound, tether a bit
        if (tf.boundTo !== null){
          const bead = world.beads[tf.boundTo];
          tf.vx += P.bindPull*(bead.x - tf.x);
          tf.vy += P.bindPull*(bead.y - tf.y);
        }

        tf.x += tf.vx;
        tf.y += tf.vy;

        // wrap bounds
        const W=canvas.width, H=canvas.height;
        if (tf.x<0) tf.x += W;
        if (tf.x>W) tf.x -= W;
        if (tf.y<0) tf.y += H;
        if (tf.y>H) tf.y -= H;
      }
    }

    function drawPolymerScene(){
      // Hubs glow (acts 6 and 7)
      if (mode === "act6" || mode === "act7"){
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        for (const h of world.hubs){
          glowCircle(h.x, h.y, 80, "rgba(255,120,200,0.018)", 110);
        }
        ctx.restore();
      }

      // polymer line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      world.beads.forEach((p,i)=>{
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads
      for (let i=0;i<world.beads.length;i++){
        const p=world.beads[i];
        if (world.isGene[i]){
          // green always, but dim if non-sticky (act7 ‚Äúunread‚Äù genes)
          const sticky = world.geneSticky[i];
          const col = sticky ? "rgba(0,255,140,0.95)" : "rgba(0,255,140,0.35)";
          const blur = sticky ? 28 : 18;
          glowCircle(p.x,p.y, 6.4, col, blur);
        } else {
          glowCircle(p.x,p.y, 4.8, "rgba(255,255,255,0.55)", 16);
        }
      }

      // TFs (acts 5‚Äì7)
      if (mode === "act5" || mode === "act6" || mode === "act7"){
        for (const tf of world.tfs){
          const bound = (tf.boundTo !== null);
          const col = bound ? "rgba(255,60,60,0.95)" : "rgba(255,60,60,0.62)";
          const blur = bound ? 34 : 20;
          glowCircle(tf.x, tf.y, 6.5, col, blur);
        }
      }
    }

    // ============================================================
    // Act 8: static ‚Äúfactory snapshot‚Äù
    // ============================================================
    function drawStaticFactorySnapshot(){
      const W = canvas.width, H = canvas.height;

      // Draw a soft ‚Äúchromatin cloud‚Äù curve
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 4.0;
      ctx.shadowColor = "rgba(255,255,255,0.12)";
      ctx.shadowBlur = 18;

      ctx.beginPath();
      const pts = 220;
      for (let i=0;i<pts;i++){
        const t = i/(pts-1);
        const x = W*(0.10 + 0.80*t);
        const y = H*(0.55 + 0.16*Math.sin(6*t) + 0.06*Math.sin(17*t));
        if (i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      // Factory hubs (pink glows)
      const hubs = [
        {x: W*0.30, y: H*0.52},
        {x: W*0.56, y: H*0.62},
        {x: W*0.74, y: H*0.44}
      ];

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (const h of hubs){
        glowCircle(h.x, h.y, 110, "rgba(255,120,200,0.025)", 140);
        glowCircle(h.x, h.y, 60, "rgba(255,120,200,0.045)", 90);
      }
      ctx.restore();

      // Gene beads: some bright (active), some dim (quiet)
      const geneSpots = [
        {x: W*0.28, y: H*0.52, active:true},
        {x: W*0.31, y: H*0.54, active:true},
        {x: W*0.55, y: H*0.61, active:true},
        {x: W*0.58, y: H*0.63, active:true},
        {x: W*0.76, y: H*0.45, active:true},

        {x: W*0.18, y: H*0.50, active:false},
        {x: W*0.44, y: H*0.40, active:false},
        {x: W*0.88, y: H*0.58, active:false}
      ];

      for (const g of geneSpots){
        const col = g.active ? "rgba(0,255,140,0.95)" : "rgba(0,255,140,0.25)";
        const blur = g.active ? 34 : 18;
        glowCircle(g.x, g.y, 8, col, blur);
      }

      // TFs: concentrated near hubs, sparse elsewhere
      function scatterAround(cx, cy, n, spread){
        for (let i=0;i<n;i++){
          const x = cx + spread*randn();
          const y = cy + spread*randn();
          glowCircle(x,y, 6.2, "rgba(255,60,60,0.85)", 24);
        }
      }

      scatterAround(hubs[0].x, hubs[0].y, 24, 28);
      scatterAround(hubs[1].x, hubs[1].y, 22, 28);
      scatterAround(hubs[2].x, hubs[2].y, 18, 26);

      // a few wandering TFs
      for (let i=0;i<10;i++){
        const x = W*(0.15 + 0.70*Math.random());
        const y = H*(0.25 + 0.55*Math.random());
        glowCircle(x,y, 6.0, "rgba(255,60,60,0.35)", 18);
      }

      // Labels
      ctx.save();
      ctx.font = "900 16px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillText("Transcription factories (hubs)", 18, 32);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.fillText("Bright hubs: many TFs + active genes ‚Ä¢ Dim green: genes present but quiet", 18, 54);
      ctx.restore();
    }

    // ============================================================
    // Main animation loop
    // ============================================================
    function tick(){
      resizeCanvas();
      drawBackground();

      // DNA / epigenetics
      if (mode === "dna" || mode === "epi"){
        rebuildClickables = true;
        if (rebuildClickables) { clearClickables(); rebuildClickables = false; }
        drawDNAHelix();
      }
      // polymer acts
      else if (mode === "chromatin" || mode === "act5" || mode === "act6" || mode === "act7"){
        initActWorld(false);
        stepPolymerAndTFs();
        drawPolymerScene();
      }
      // static snapshot
      else if (mode === "act8"){
        drawStaticFactorySnapshot();
      }

      requestAnimationFrame(tick);
    }

    // ============================================================
    // Start
    // ============================================================
    resizeCanvas();
    applyAct(0);
    tick();
  </script>
</body>
</html>










