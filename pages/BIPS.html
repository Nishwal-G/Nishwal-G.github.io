<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BIPS Explainer | Nishwal Gora</title>
  <link rel="stylesheet" href="../stylesheets/bips_style.css" />
</head>

<body class="dark">

  <!-- Header -->
  <header class="site-header">
    <div class="header-inner">
      <a class="brand" href="../index.html">Nishwal Gora</a>
      <nav class="site-nav">
        <ul class="nav-pill">
          <li><a href="../index.html">Home</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="cv.html">CV</a></li>
          <li><a href="about.html">About Me</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="more.html">More</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Fullscreen stage -->
  <main class="stage">
    <canvas id="stageCanvas"></canvas>

    <!-- Minimal caption (changes per slide) -->
    <div class="caption">
      <div class="cap-title" id="capTitle">DNA</div>
      <div class="cap-text" id="capText">DNA is a double helix made from A, C, G, T.</div>
    </div>

    <!-- Controls (ONLY visible on TF/BIPS slides) -->
    <div class="controls" id="controls">
      <div class="control-row">
        <label class="slider">
          <span>Stickiness</span>
          <input id="stickiness" type="range" min="0" max="100" value="45" />
          <span class="val" id="stickVal">0.45</span>
        </label>
      </div>

      <div class="control-row">
        <label class="slider">
          <span>TF count</span>
          <input id="tfCount" type="range" min="5" max="80" value="35" />
          <span class="val" id="tfVal">35</span>
        </label>
      </div>

      <div class="control-row small">
        <span id="statsLine">bridges: 0 • bound TFs: 0 • clusters: 0</span>
      </div>

      <div class="control-row">
        <button id="resetBtn" type="button">Reset</button>
        <button id="spawnBtn" type="button">Spawn TF</button>
      </div>
    </div>

    <!-- Bottom navigation -->
    <button class="next" id="nextBtn" type="button">Next →</button>
  </main>

  <script>
    // ============================================================
    // Slide sequence (minimal text)
    // ============================================================
    const SLIDES = [
      {
        key: "dna",
        title: "DNA",
        text: "DNA is a double helix made from A, C, G, T.",
        mode: "dna"
      },
      {
        key: "genes",
        title: "Genes",
        text: "A gene is a short stretch of DNA you can “read”.",
        mode: "genes"
      },
      {
        key: "chromatin",
        title: "Chromatin",
        text: "DNA + proteins behaves like a flexible polymer. Drag it.",
        mode: "chromatin"
      },
      {
        key: "tfs",
        title: "Transcription factors",
        text: "TFs (red) diffuse and bind TU sites (green).",
        mode: "tfs"
      },
      {
        key: "bips",
        title: "BIPS",
        text: "Two-site binding makes bridges → local density → clusters.",
        mode: "bips"
      }
    ];

    let slideIndex = 0;
    let scene = SLIDES[0].mode;

    const capTitle = document.getElementById("capTitle");
    const capText  = document.getElementById("capText");
    const nextBtn  = document.getElementById("nextBtn");
    const controls = document.getElementById("controls");

    function applySlide(i){
      slideIndex = (i + SLIDES.length) % SLIDES.length;
      const s = SLIDES[slideIndex];
      scene = s.mode;

      capTitle.textContent = s.title;
      capText.textContent  = s.text;

      // Only show controls on TF/BIPS slides
      const show = (scene === "tfs" || scene === "bips");
      controls.classList.toggle("show", show);

      // If we enter TF/BIPS, ensure we have TFs, and show TU sites
      if (scene === "tfs" || scene === "bips") {
        world.showTUs = true;
        world.showTFs = true;
      } else if (scene === "chromatin") {
        world.showTUs = false;
        world.showTFs = false;
      } else {
        world.showTUs = false;
        world.showTFs = false;
      }
    }

    nextBtn.addEventListener("click", () => applySlide(slideIndex + 1));

    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvasToDisplaySize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
    }
    window.addEventListener("resize", resizeCanvasToDisplaySize);

    // ============================================================
    // UI controls
    // ============================================================
    const resetBtn = document.getElementById("resetBtn");
    const spawnBtn = document.getElementById("spawnBtn");
    const stickSlider = document.getElementById("stickiness");
    const stickVal = document.getElementById("stickVal");
    const tfCountSlider = document.getElementById("tfCount");
    const tfVal = document.getElementById("tfVal");
    const statsLine = document.getElementById("statsLine");

    const params = {
      stickiness: 0.45,
      tfTargetCount: 35,

      // Polymer (long)
      beadCount: 140,
      restLen: 10,
      kSpring: 0.18,
      kBend: 0.012,
      damping: 0.93,
      brownianChain: 0.18,

      // Excluded volume (IMPORTANT)
      beadRadius: 4.8,
      kRepel: 0.45,

      // TF
      tfRadius: 7.0,
      brownianTF: 0.95,
      tfDamping: 0.94,

      // TF repulsion (prevents piling into one blob)
      tfRepelRadius: 9.0,
      kRepelTF: 0.35,

      // binding
      bindRadius: 15,
      baseBindRate: 0.020,
      baseUnbindRate: 0.004,

      // BIPS feedback (kept moderate!)
      feedbackRadius: 100,
      feedbackBoostMax: 2.4,

      // LAMMPS-like ON/OFF switching (prevents one mega hub)
      switchEveryFrames: 90,   // ~1.5s at 60fps
      switchFrac: 0.02         // flip 2% per switch event
    };

    function updateUI(){
      params.stickiness = Number(stickSlider.value) / 100;
      params.tfTargetCount = Number(tfCountSlider.value);
      stickVal.textContent = params.stickiness.toFixed(2);
      tfVal.textContent = params.tfTargetCount.toString();
    }
    stickSlider.addEventListener("input", updateUI);
    tfCountSlider.addEventListener("input", updateUI);
    updateUI();

    // ============================================================
    // RNG
    // ============================================================
    function rand(){ return Math.random(); }
    function randn(){
      let u=0,v=0;
      while(u===0) u=rand();
      while(v===0) v=rand();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    // ============================================================
    // World
    // ============================================================
    const world = {
      beads: [],   // {x,y,vx,vy,isTU}
      tfs: [],     // {x,y,vx,vy,bindA,bindB,on}
      bridges: [],
      showTUs: false,
      showTFs: false,
      frame: 0
    };

    function spawnTF(){
      const W = canvas.width, H = canvas.height;
      world.tfs.push({
        x: W*(0.25 + 0.5*rand()),
        y: H*(0.25 + 0.5*rand()),
        vx: 0, vy: 0,
        bindA: null, bindB: null,
        on: true
      });
    }

    function initWorld(){
      resizeCanvasToDisplaySize();
      const W = canvas.width, H = canvas.height;
      world.beads = [];
      world.tfs = [];
      world.bridges = [];
      world.frame = 0;

      // long polymer across the screen
      const startX = W*0.08;
      const midY = H*0.55;

      for (let i=0; i<params.beadCount; i++){
        const x = startX + i*params.restLen;
        const y = midY + (H*0.05)*Math.sin(i*0.20);
        const isTU = (i % 12 === 0); // only visible later
        world.beads.push({ x,y,vx:0,vy:0,isTU });
      }

      for (let i=0; i<params.tfTargetCount; i++) spawnTF();
    }

    resetBtn.addEventListener("click", initWorld);
    spawnBtn.addEventListener("click", spawnTF);

    function maintainTFCount(){
      const target = params.tfTargetCount;
      while(world.tfs.length < target) spawnTF();
      while(world.tfs.length > target) world.tfs.pop();
    }

    // ============================================================
    // Mouse drag (only for chromatin+)
    // ============================================================
    let mouse = {x:0,y:0,down:false};
    let grab = {type:null,index:-1,offx:0,offy:0};

    function getMousePos(evt){
      const rect = canvas.getBoundingClientRect();
      const dpr = canvas.width / rect.width;
      return { x:(evt.clientX-rect.left)*dpr, y:(evt.clientY-rect.top)*dpr };
    }

    canvas.addEventListener("mousedown", (e)=>{
      mouse.down = true;
      const p = getMousePos(e);
      mouse.x=p.x; mouse.y=p.y;

      if (!(scene==="chromatin" || scene==="tfs" || scene==="bips")) return;

      // grab TF first (only if TFs visible)
      if (world.showTFs){
        for (let i=world.tfs.length-1; i>=0; i--){
          const tf = world.tfs[i];
          const dx=p.x-tf.x, dy=p.y-tf.y;
          if (dx*dx+dy*dy <= (params.tfRadius*2.6)**2){
            grab.type="tf"; grab.index=i;
            grab.offx=tf.x-p.x; grab.offy=tf.y-p.y;
            return;
          }
        }
      }

      // grab bead
      for (let i=world.beads.length-1; i>=0; i--){
        const b = world.beads[i];
        const dx=p.x-b.x, dy=p.y-b.y;
        if (dx*dx+dy*dy <= (18)**2){
          grab.type="bead"; grab.index=i;
          grab.offx=b.x-p.x; grab.offy=b.y-p.y;
          return;
        }
      }
    });

    canvas.addEventListener("mousemove", (e)=>{
      const p=getMousePos(e);
      mouse.x=p.x; mouse.y=p.y;
      if(!mouse.down || grab.type===null) return;

      if(grab.type==="bead"){
        const b=world.beads[grab.index];
        const tx=mouse.x+grab.offx, ty=mouse.y+grab.offy;
        b.vx += 0.25*(tx-b.x);
        b.vy += 0.25*(ty-b.y);
      }
      if(grab.type==="tf"){
        const tf=world.tfs[grab.index];
        const tx=mouse.x+grab.offx, ty=mouse.y+grab.offy;
        tf.vx += 0.22*(tx-tf.x);
        tf.vy += 0.22*(ty-tf.y);
      }
    });

    window.addEventListener("mouseup", ()=>{
      mouse.down=false; grab.type=null; grab.index=-1;
    });

    // ============================================================
    // Forces
    // ============================================================
    function springForce(ax,ay,bx,by,rest,k){
      const dx=bx-ax, dy=by-ay;
      const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
      const f=k*(r-rest);
      return {fx:f*dx/r, fy:f*dy/r};
    }

    function bendForce(p0,p1,p2,kB){
      const mx=0.5*(p0.x+p2.x);
      const my=0.5*(p0.y+p2.y);
      return {fx:kB*(mx-p1.x), fy:kB*(my-p1.y)};
    }

    function repelPair(ax,ay,bx,by,minDist,k){
      const dx=bx-ax, dy=by-ay;
      const r2=dx*dx+dy*dy+1e-6;
      const r=Math.sqrt(r2);
      if(r>=minDist) return {fx:0,fy:0};
      const overlap=(minDist-r);
      const f=k*overlap;
      return {fx:f*dx/r, fy:f*dy/r};
    }

    function softWalls(p){
      // keeps things inside without "sucking to centre"
      const W=canvas.width, H=canvas.height;
      const margin=60;
      const k=0.0018;

      if (p.x < margin) p.vx += k*(margin - p.x);
      if (p.x > W - margin) p.vx -= k*(p.x - (W - margin));
      if (p.y < margin) p.vy += k*(margin - p.y);
      if (p.y > H - margin) p.vy -= k*(p.y - (H - margin));
    }

    // ============================================================
    // BIPS feedback (saturating)
    // ============================================================
    function feedbackBoostAt(x,y){
      if (world.bridges.length===0) return 1.0;
      let sum=0.0;
      const R=params.feedbackRadius;

      for (const br of world.bridges){
        const a=world.beads[br.a], b=world.beads[br.b];
        const cx=0.5*(a.x+b.x), cy=0.5*(a.y+b.y);
        const dx=x-cx, dy=y-cy;
        const d=Math.sqrt(dx*dx+dy*dy);
        if (d<R) sum += (1.0 - d/R);
      }
      const sat = 1.0 - Math.exp(-sum);
      return 1.0 + (params.feedbackBoostMax - 1.0)*sat;
    }

    function tryBind(i){
      const tf = world.tfs[i];
      if (!(scene==="tfs" || scene==="bips")) return;
      if (!tf.on) return;

      const hasA = (tf.bindA!==null);
      const hasB = (tf.bindB!==null);
      if (hasA && hasB) return;

      // nearest TU
      let best={idx:null,d2:Infinity};
      for (let j=0;j<world.beads.length;j++){
        const bead=world.beads[j];
        if (!bead.isTU) continue;
        if (tf.bindA===j || tf.bindB===j) continue;
        const dx=bead.x-tf.x, dy=bead.y-tf.y;
        const d2=dx*dx+dy*dy;
        if (d2<best.d2) best={idx:j,d2};
      }
      if (best.idx===null) return;
      if (best.d2 > params.bindRadius*params.bindRadius) return;

      const localBoost = (scene==="bips") ? feedbackBoostAt(tf.x,tf.y) : 1.0;
      const pBind = params.baseBindRate * params.stickiness * localBoost;

      if (rand() < pBind){
        if (!hasA) tf.bindA = best.idx;
        else tf.bindB = best.idx;

        if (scene==="bips" && tf.bindA!==null && tf.bindB!==null){
          const a=Math.min(tf.bindA,tf.bindB);
          const b=Math.max(tf.bindA,tf.bindB);
          const exists = world.bridges.some(br=>br.a===a && br.b===b);
          if (!exists) world.bridges.push({a,b,tfIndex:i});
        }
      }
    }

    function tryUnbind(i){
      const tf=world.tfs[i];
      if (!(scene==="tfs" || scene==="bips")) return;

      const unbind = params.baseUnbindRate * (tf.on ? 1.0 : 3.0);
      if (tf.bindA!==null && rand()<unbind) tf.bindA=null;
      if (tf.bindB!==null && rand()<unbind) tf.bindB=null;

      if (scene==="bips"){
        world.bridges = world.bridges.filter(br=>{
          const t = world.tfs[br.tfIndex];
          return t && t.bindA!==null && t.bindB!==null;
        });
      }
    }

    function applyBindingConstraints(){
      const tetherK=0.16;
      for (const tf of world.tfs){
        if (tf.bindA!==null){
          const b=world.beads[tf.bindA];
          tf.vx += tetherK*(b.x-tf.x);
          tf.vy += tetherK*(b.y-tf.y);
        }
        if (tf.bindB!==null){
          const b=world.beads[tf.bindB];
          tf.vx += tetherK*(b.x-tf.x);
          tf.vy += tetherK*(b.y-tf.y);
        }
      }
    }

    function applyBridgeForces(){
      if (scene!=="bips") return;
      const kBridge = 0.05 + 0.16*params.stickiness;
      const rest = params.restLen*2.0;

      for (const br of world.bridges){
        const a=world.beads[br.a], b=world.beads[br.b];
        const f=springForce(a.x,a.y,b.x,b.y,rest,kBridge);
        a.vx += f.fx; a.vy += f.fy;
        b.vx -= f.fx; b.vy -= f.fy;
      }
    }

    function switchTFs(){
      // LAMMPS-like ON/OFF flipping prevents permanent single mega-cluster
      for (const tf of world.tfs){
        if (rand() < params.switchFrac){
          tf.on = !tf.on;
          if (!tf.on){
            tf.bindA=null; tf.bindB=null;
          }
        }
      }
    }

    // ============================================================
    // Step
    // ============================================================
    function step(){
      world.frame++;
      resizeCanvasToDisplaySize();

      const polymerActive = (scene==="chromatin" || scene==="tfs" || scene==="bips");
      const tfActive = (scene==="tfs" || scene==="bips");

      if (polymerActive){
        // springs
        for (let i=0;i<world.beads.length-1;i++){
          const a=world.beads[i], b=world.beads[i+1];
          const f=springForce(a.x,a.y,b.x,b.y,params.restLen,params.kSpring);
          a.vx += f.fx; a.vy += f.fy;
          b.vx -= f.fx; b.vy -= f.fy;
        }

        // bending
        for (let i=1;i<world.beads.length-1;i++){
          const f=bendForce(world.beads[i-1],world.beads[i],world.beads[i+1],params.kBend);
          world.beads[i].vx += f.fx;
          world.beads[i].vy += f.fy;
        }

        // excluded volume (local window for speed)
        const minBB = 2*params.beadRadius;
        for (let i=0;i<world.beads.length;i++){
          const i0=Math.max(0,i-14);
          const i1=Math.min(world.beads.length-1,i+14);
          for (let j=i0;j<=i1;j++){
            if (j===i) continue;
            if (Math.abs(i-j)<=1) continue;
            const a=world.beads[i], b=world.beads[j];
            const f=repelPair(a.x,a.y,b.x,b.y,minBB,params.kRepel);
            a.vx -= f.fx; a.vy -= f.fy;
            b.vx += f.fx; b.vy += f.fy;
          }
        }

        // integrate beads
        for (const b of world.beads){
          b.vx += params.brownianChain*randn();
          b.vy += params.brownianChain*randn();
          b.vx *= params.damping;
          b.vy *= params.damping;
          b.x += b.vx; b.y += b.vy;
          softWalls(b);
        }
      }

      if (tfActive && world.showTFs){
        maintainTFCount();

        // TF diffusion
        for (const tf of world.tfs){
          tf.vx += params.brownianTF*randn();
          tf.vy += params.brownianTF*randn();
          tf.vx *= params.tfDamping;
          tf.vy *= params.tfDamping;
          tf.x += tf.vx; tf.y += tf.vy;
          softWalls(tf);
        }

        // TF-TF repulsion
        const minTT = 2*params.tfRepelRadius;
        for (let i=0;i<world.tfs.length;i++){
          for (let j=i+1;j<world.tfs.length;j++){
            const a=world.tfs[i], b=world.tfs[j];
            const f=repelPair(a.x,a.y,b.x,b.y,minTT,params.kRepelTF);
            a.vx -= f.fx; a.vy -= f.fy;
            b.vx += f.fx; b.vy += f.fy;
          }
        }

        // binding kinetics
        for (let i=0;i<world.tfs.length;i++){
          tryUnbind(i);
          tryBind(i);
        }

        applyBindingConstraints();
        applyBridgeForces();

        // ON/OFF switching (LAMMPS-like)
        if (scene==="bips" && (world.frame % params.switchEveryFrames === 0)){
          switchTFs();
        }
      }

      render();
      requestAnimationFrame(step);
    }

    // ============================================================
    // Rendering
    // ============================================================
    function clearBG(){
      ctx.fillStyle="#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function glow(x,y,r,fill,blur=18){
      ctx.save();
      ctx.shadowColor=fill;
      ctx.shadowBlur=blur;
      ctx.fillStyle=fill;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // DNA helix + gene highlight
    function drawDNA(highlight=false){
      const W=canvas.width, H=canvas.height;
      const cx=W*0.50, cy=H*0.55;
      const amp=H*0.10;
      const pitch=W*0.020;
      const turns=36;

      // segment to highlight for "genes"
      const hi0 = 12, hi1 = 18;

      for (let i=0;i<turns;i++){
        const t = i*0.55 + world.frame*0.02;
        const x = cx - (turns*pitch)/2 + i*pitch;

        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);

        // base-pair ladder
        const isHi = highlight && (i>=hi0 && i<=hi1);

        ctx.save();
        ctx.strokeStyle = isHi ? "rgba(0,255,140,0.95)" : "rgba(255,255,255,0.28)";
        ctx.lineWidth = isHi ? 3.0 : 2.0;
        ctx.beginPath();
        ctx.moveTo(x,y1);
        ctx.lineTo(x,y2);
        ctx.stroke();
        ctx.restore();

        // backbones
        glow(x,y1, 4.8, "rgba(255,255,255,0.65)", 18);
        glow(x,y2, 4.8, "rgba(255,255,255,0.65)", 18);
      }

      // subtle helix guides
      ctx.save();
      ctx.strokeStyle="rgba(255,255,255,0.12)";
      ctx.lineWidth=2;
      ctx.beginPath();
      for (let i=0;i<turns;i++){
        const t=i*0.55 + world.frame*0.02;
        const x=cx-(turns*pitch)/2 + i*pitch;
        const y=cy + amp*Math.sin(t);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.beginPath();
      for (let i=0;i<turns;i++){
        const t=i*0.55 + world.frame*0.02 + Math.PI;
        const x=cx-(turns*pitch)/2 + i*pitch;
        const y=cy + amp*Math.sin(t);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawPolymer(){
      // chain
      ctx.save();
      ctx.strokeStyle="rgba(255,255,255,0.30)";
      ctx.lineWidth=3.0;
      ctx.beginPath();
      world.beads.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
      ctx.stroke();
      ctx.restore();

      // beads
      for (const b of world.beads){
        if (b.isTU && world.showTUs){
          glow(b.x,b.y,6.5,"rgba(0,255,140,0.95)",26);
        } else {
          glow(b.x,b.y,4.8,"rgba(255,255,255,0.55)",16);
        }
      }
    }

    function drawTFs(){
      if (!world.showTFs) return;
      for (const tf of world.tfs){
        const bound = (tf.bindA!==null || tf.bindB!==null);
        const on = tf.on;
        const col = on
          ? (bound ? "rgba(255,60,60,0.95)" : "rgba(255,60,60,0.75)")
          : "rgba(255,60,60,0.25)";
        glow(tf.x,tf.y,params.tfRadius,col, bound?28:18);
      }
    }

    function drawBridges(){
      if (scene!=="bips") return;
      ctx.save();
      ctx.strokeStyle="rgba(255,60,60,0.80)";
      ctx.lineWidth=2.0;
      for (const br of world.bridges){
        const a=world.beads[br.a], b=world.beads[br.b];
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function countClusters(){
      // very cheap “cluster” estimate: number of distinct bridge centers separated by >R
      if (world.bridges.length===0) return 0;
      const centers=[];
      for (const br of world.bridges){
        const a=world.beads[br.a], b=world.beads[br.b];
        centers.push({x:0.5*(a.x+b.x), y:0.5*(a.y+b.y)});
      }
      const R=70;
      const used=new Array(centers.length).fill(false);
      let clusters=0;
      for (let i=0;i<centers.length;i++){
        if(used[i]) continue;
        clusters++;
        used[i]=true;
        for (let j=i+1;j<centers.length;j++){
          const dx=centers[j].x-centers[i].x, dy=centers[j].y-centers[i].y;
          if(dx*dx+dy*dy < R*R) used[j]=true;
        }
      }
      return clusters;
    }

    function updateStats(){
      let boundTF=0;
      for (const tf of world.tfs){
        if (tf.bindA!==null || tf.bindB!==null) boundTF++;
      }
      const clusters = countClusters();
      statsLine.textContent = `bridges: ${world.bridges.length} • bound TFs: ${boundTF} • clusters: ${clusters}`;
    }

    function render(){
      clearBG();

      if (scene==="dna"){
        drawDNA(false);
        return;
      }
      if (scene==="genes"){
        drawDNA(true);
        return;
      }

      drawPolymer();
      drawTFs();
      drawBridges();

      if (scene==="tfs" || scene==="bips") updateStats();
    }

    // Start
    initWorld();
    applySlide(0);
    step();
  </script>
</body>
</html>




