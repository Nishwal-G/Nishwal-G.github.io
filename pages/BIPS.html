<!-- =========================
     FILE: pages/BIPS.html
     Copy-paste this ENTIRE file.
     Includes CSS link + ALL JS inline (no separate JS files).
     Put the CSS below into: stylesheets/bips_style.css
========================= -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DNA → Chromatin → BIPS | Nishwal Gora</title>
  <link rel="stylesheet" href="../stylesheets/bips_style.css" />
</head>

<body class="dark">

  <!-- Header / nav consistent with your site -->
  <header class="site-header">
    <div class="header-inner">
      <a class="brand" href="../index.html">Nishwal Gora</a>
      <nav class="site-nav">
        <ul class="nav-pill">
          <li><a href="../index.html">Home</a></li>
          <li><a href="projects.html">Projects</a></li>
          <li><a href="cv.html">CV</a></li>
          <li><a href="about.html">About Me</a></li>
          <li><a href="contact.html">Contact</a></li>
          <li><a href="more.html">More</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Fullscreen stage -->
  <main class="stage">
    <canvas id="stageCanvas"></canvas>

    <!-- Minimal overlay (canvas-first) -->
    <div class="overlay">

      <!-- Top-left -->
      <div class="overlay-top">
        <div class="title" id="sceneTitle">DNA</div>

        <div class="actions">
          <button class="pill" id="termBasePair" type="button">base-pair</button>
          <button class="pill" id="termGene" type="button">gene</button>

          <span class="sep"></span>

          <button class="pill strong" id="nextBtn" type="button">Next →</button>
        </div>
      </div>

      <!-- Tiny tooltip (only when a term is clicked) -->
      <div class="tooltip" id="tooltip" aria-live="polite">
        <div class="tooltip-title" id="tipTitle">Base pair</div>
        <div class="tooltip-text" id="tipText">
          A “rung” connecting the two DNA strands (A–T or C–G).
        </div>
        <button class="tipClose" id="tipClose" type="button" aria-label="Close">✕</button>
      </div>

      <!-- Bottom-left BIPS controls (only in chromatin scene) -->
      <div class="bipsControls" id="bipsControls">
        <button class="pill" id="playBtn" type="button">▶ Play BIPS</button>
        <button class="pill" id="resetBtn" type="button">Reset</button>
        <button class="pill" id="backBtn" type="button">← Back</button>
      </div>

      <!-- Optional: tiny legend in chromatin scene -->
      <div class="legend" id="legend">
        <span class="dot white"></span> chromatin
        <span class="dot red"></span> TU (hotspot)
      </div>

    </div>
  </main>

  <script>
    // ============================================================
    // Minimal interactive explainer (all-in-one, no external JS)
    // Scenes:
    //   - dna: double helix (click base-pair / gene to highlight)
    //   - chromatin: long polymer (calm motion), shows "Play BIPS"
    //   - bips: same polymer, pulled into 2–3 clusters around hotspots
    // ============================================================

    // ---------- DOM ----------
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    const sceneTitle = document.getElementById("sceneTitle");
    const termBasePair = document.getElementById("termBasePair");
    const termGene = document.getElementById("termGene");
    const nextBtn = document.getElementById("nextBtn");

    const tooltip = document.getElementById("tooltip");
    const tipTitle = document.getElementById("tipTitle");
    const tipText = document.getElementById("tipText");
    const tipClose = document.getElementById("tipClose");

    const bipsControls = document.getElementById("bipsControls");
    const playBtn = document.getElementById("playBtn");
    const resetBtn = document.getElementById("resetBtn");
    const backBtn = document.getElementById("backBtn");
    const legend = document.getElementById("legend");

    // ---------- State ----------
    let scene = "dna";          // "dna" | "chromatin" | "bips"
    let highlight = null;       // null | "basepair" | "gene"

    // ---------- Canvas resize ----------
    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }
    window.addEventListener("resize", resizeCanvas);

    // ---------- Tooltip helpers ----------
    function showTip(title, text) {
      tipTitle.textContent = title;
      tipText.textContent = text;
      tooltip.classList.add("show");
    }
    function hideTip() {
      tooltip.classList.remove("show");
    }
    tipClose.addEventListener("click", hideTip);

    // ---------- Scene switching ----------
    function setScene(s) {
      scene = s;
      highlight = null;
      hideTip();

      if (scene === "dna") {
        sceneTitle.textContent = "DNA";
        termBasePair.disabled = false;
        termGene.disabled = false;
        nextBtn.textContent = "Next →";
        bipsControls.classList.remove("show");
        legend.classList.remove("show");
      } else if (scene === "chromatin") {
        sceneTitle.textContent = "Chromatin";
        termBasePair.disabled = true;
        termGene.disabled = true;
        nextBtn.textContent = "↺ DNA";
        bipsControls.classList.add("show");
        legend.classList.add("show");
      } else if (scene === "bips") {
        sceneTitle.textContent = "BIPS";
        termBasePair.disabled = true;
        termGene.disabled = true;
        nextBtn.textContent = "↺ DNA";
        bipsControls.classList.add("show");
        legend.classList.add("show");
      }
    }

    // Buttons
    nextBtn.addEventListener("click", () => {
      if (scene === "dna") setScene("chromatin");
      else setScene("dna");
    });
    backBtn.addEventListener("click", () => setScene("dna"));

    // DNA term toggles
    termBasePair.addEventListener("click", () => {
      highlight = (highlight === "basepair") ? null : "basepair";
      hideTip();
      if (highlight === "basepair") {
        showTip("Base pair", "A “rung” connecting the two DNA strands (A–T or C–G).");
      }
    });
    termGene.addEventListener("click", () => {
      highlight = (highlight === "gene") ? null : "gene";
      hideTip();
      if (highlight === "gene") {
        showTip("Gene", "A stretch of DNA that can be read to make RNA (and often proteins).");
      }
    });

    // ---------- RNG ----------
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    // ============================================================
    // DNA double helix (canvas)
    // ============================================================
    function drawBackground() {
      ctx.fillStyle = "#050507";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // subtle specks
      ctx.fillStyle = "rgba(255,255,255,0.035)";
      for (let i = 0; i < 140; i++) {
        const x = (i * 97) % canvas.width;
        const y = (i * 181) % canvas.height;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    function glow(x, y, r, color, blur = 18) {
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawDNA() {
      const W = canvas.width, H = canvas.height;

      // helix geometry
      const cx = W * 0.52;
      const cy = H * 0.56;
      const amp = H * 0.14;
      const pitch = W * 0.022;
      const turns = 44;

      // highlight choices
      const baseHi = (highlight === "basepair");
      const geneHi = (highlight === "gene");
      const geneStart = 15;
      const geneEnd = 24;

      const tNow = performance.now() * 0.0016;

      // helix ladder
      for (let i = 0; i < turns; i++) {
        const t = i * 0.55 + tNow;
        const x = cx - (turns * pitch) / 2 + i * pitch;

        const y1 = cy + amp * Math.sin(t);
        const y2 = cy + amp * Math.sin(t + Math.PI);

        const inGene = (i >= geneStart && i <= geneEnd);

        const highlightRung = (baseHi && (i % 4 === 0)) || (geneHi && inGene);

        const rungColor =
          geneHi && inGene ? "rgba(0,255,140,0.90)" :
          baseHi && (i % 4 === 0) ? "rgba(255,255,255,0.90)" :
          "rgba(255,255,255,0.20)";

        ctx.save();
        ctx.strokeStyle = rungColor;
        ctx.lineWidth = highlightRung ? 3.0 : 2.0;
        ctx.beginPath();
        ctx.moveTo(x, y1);
        ctx.lineTo(x, y2);
        ctx.stroke();
        ctx.restore();

        // backbone nodes
        const backboneColor = (geneHi && inGene) ? "rgba(0,255,140,0.65)" : "rgba(255,255,255,0.55)";
        glow(x, y1, 5.0, backboneColor, 18);
        glow(x, y2, 5.0, backboneColor, 18);
      }

      // small arrows/labels (subtle, not blocking)
      // (These are visual-only; interaction is via the top-left buttons)
      ctx.save();
      ctx.font = "600 14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2;

      // Base pair label
      const bx = W * 0.16, by = H * 0.34;
      ctx.fillText("base pair", bx, by);
      ctx.beginPath(); ctx.moveTo(bx + 10, by + 6); ctx.lineTo(W * 0.36, H * 0.46); ctx.stroke();

      // Gene label
      const gx = W * 0.70, gy = H * 0.76;
      ctx.fillText("gene", gx, gy);
      ctx.strokeStyle = "rgba(0,255,140,0.18)";
      ctx.beginPath(); ctx.moveTo(gx + 6, gy + 6); ctx.lineTo(W * 0.60, H * 0.60); ctx.stroke();

      ctx.restore();
    }

    // ============================================================
    // Chromatin polymer + BIPS clusters (canvas)
    // ============================================================
    const world = {
      beads: [],
      vx: [],
      vy: [],
      isHot: [],
      frame: 0,
      playing: false,
      centers: []
    };

    const params = {
      beadCount: 180,
      restLen: 10,

      kSpring: 0.18,
      kBend: 0.010,
      damping: 0.92,
      brownian: 0.15,

      beadRadius: 4.7,
      kRepel: 0.55,

      // BIPS: gentle pull to 3 centers + stronger pull for hotspots
      kClusterPull: 0.0028,
      kHotPull: 0.0068
    };

    function initPolymer() {
      resizeCanvas();
      const W = canvas.width, H = canvas.height;

      world.frame = 0;
      world.playing = false;

      world.beads = [];
      world.vx = new Array(params.beadCount).fill(0);
      world.vy = new Array(params.beadCount).fill(0);
      world.isHot = new Array(params.beadCount).fill(false);

      // long polymer across the screen
      const startX = W * 0.08;
      const midY = H * 0.58;

      for (let i = 0; i < params.beadCount; i++) {
        const x = startX + i * params.restLen;
        const y = midY + (H * 0.05) * Math.sin(i * 0.20);
        world.beads.push({ x, y });
      }

      // hotspots (TUs) - RED
      const bands = [
        Math.floor(params.beadCount * 0.25),
        Math.floor(params.beadCount * 0.52),
        Math.floor(params.beadCount * 0.78)
      ];
      for (const c of bands) {
        for (let j = -3; j <= 3; j++) {
          const idx = c + j;
          if (idx >= 0 && idx < params.beadCount) world.isHot[idx] = true;
        }
      }

      // cluster centers (fixed) - 3
      world.centers = [
        { x: W * 0.34, y: H * 0.50 },
        { x: W * 0.56, y: H * 0.62 },
        { x: W * 0.72, y: H * 0.46 }
      ];
    }

    function springForce(ax, ay, bx, by, rest, k) {
      const dx = bx - ax, dy = by - ay;
      const r = Math.sqrt(dx * dx + dy * dy) + 1e-6;
      const f = k * (r - rest);
      return { fx: f * dx / r, fy: f * dy / r };
    }

    function bendForce(p0, p1, p2, kB) {
      const mx = 0.5 * (p0.x + p2.x);
      const my = 0.5 * (p0.y + p2.y);
      return { fx: kB * (mx - p1.x), fy: kB * (my - p1.y) };
    }

    function repelPair(ax, ay, bx, by, minDist, k) {
      const dx = bx - ax, dy = by - ay;
      const r2 = dx * dx + dy * dy + 1e-6;
      const r = Math.sqrt(r2);
      if (r >= minDist) return { fx: 0, fy: 0 };
      const overlap = (minDist - r);
      const f = k * overlap;
      return { fx: f * dx / r, fy: f * dy / r };
    }

    function softWalls(x, y, vx, vy) {
      const W = canvas.width, H = canvas.height;
      const margin = 70;
      const k = 0.0018;

      if (x < margin) vx += k * (margin - x);
      if (x > W - margin) vx -= k * (x - (W - margin));
      if (y < margin) vy += k * (margin - y);
      if (y > H - margin) vy -= k * (y - (H - margin));

      return { vx, vy };
    }

    function stepPolymer() {
      const n = params.beadCount;
      world.frame++;

      // springs (neighbors)
      for (let i = 0; i < n - 1; i++) {
        const a = world.beads[i], b = world.beads[i + 1];
        const f = springForce(a.x, a.y, b.x, b.y, params.restLen, params.kSpring);
        world.vx[i] += f.fx; world.vy[i] += f.fy;
        world.vx[i + 1] -= f.fx; world.vy[i + 1] -= f.fy;
      }

      // bending
      for (let i = 1; i < n - 1; i++) {
        const f = bendForce(world.beads[i - 1], world.beads[i], world.beads[i + 1], params.kBend);
        world.vx[i] += f.fx;
        world.vy[i] += f.fy;
      }

      // excluded volume (local)
      const minBB = 2 * params.beadRadius;
      for (let i = 0; i < n; i++) {
        const i0 = Math.max(0, i - 14);
        const i1 = Math.min(n - 1, i + 14);
        for (let j = i0; j <= i1; j++) {
          if (j === i) continue;
          if (Math.abs(i - j) <= 1) continue;
          const a = world.beads[i], b = world.beads[j];
          const f = repelPair(a.x, a.y, b.x, b.y, minBB, params.kRepel);
          world.vx[i] -= f.fx; world.vy[i] -= f.fy;
          world.vx[j] += f.fx; world.vy[j] += f.fy;
        }
      }

      // BIPS pulling (only when playing)
      if (scene === "bips" && world.playing) {
        for (let i = 0; i < n; i++) {
          const p = world.beads[i];

          // nearest center
          let best = { d2: Infinity, c: world.centers[0] };
          for (const c of world.centers) {
            const dx = c.x - p.x, dy = c.y - p.y;
            const d2 = dx * dx + dy * dy;
            if (d2 < best.d2) best = { d2, c };
          }
          const c = best.c;
          const dx = c.x - p.x, dy = c.y - p.y;

          // gentle pull for all
          world.vx[i] += params.kClusterPull * dx;
          world.vy[i] += params.kClusterPull * dy;

          // stronger pull for hotspots
          if (world.isHot[i]) {
            world.vx[i] += params.kHotPull * dx;
            world.vy[i] += params.kHotPull * dy;
          }
        }
      }

      // integrate
      for (let i = 0; i < n; i++) {
        world.vx[i] += params.brownian * randn();
        world.vy[i] += params.brownian * randn();

        world.vx[i] *= params.damping;
        world.vy[i] *= params.damping;

        world.beads[i].x += world.vx[i];
        world.beads[i].y += world.vy[i];

        const out = softWalls(world.beads[i].x, world.beads[i].y, world.vx[i], world.vy[i]);
        world.vx[i] = out.vx;
        world.vy[i] = out.vy;
      }
    }

    function drawPolymer() {
      // chain
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.26)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      world.beads.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads (white) and hotspots (red)
      for (let i = 0; i < world.beads.length; i++) {
        const p = world.beads[i];
        if (world.isHot[i]) {
          glow(p.x, p.y, 6.8, "rgba(255,60,60,0.95)", 30);
        } else {
          glow(p.x, p.y, 4.8, "rgba(255,255,255,0.55)", 16);
        }
      }

      // subtle cluster fog
      if (scene === "bips") {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        for (const c of world.centers) {
          glow(c.x, c.y, 52, "rgba(255,255,255,0.014)", 70);
        }
        ctx.restore();
      }
    }

    // ============================================================
    // Controls for polymer scene
    // ============================================================
    playBtn.addEventListener("click", () => {
      if (scene !== "chromatin" && scene !== "bips") return;
      setScene("bips");
      world.playing = true;
    });

    resetBtn.addEventListener("click", () => {
      initPolymer();
      setScene("chromatin");
    });

    // ============================================================
    // Main loop
    // ============================================================
    function tick() {
      resizeCanvas();
      drawBackground();

      if (scene === "dna") {
        drawDNA();
      } else {
        stepPolymer();
        drawPolymer();
      }

      requestAnimationFrame(tick);
    }

    // Start
    resizeCanvas();
    initPolymer();
    setScene("dna");
    tick();
  </script>

</body>
</html>






