<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DNA ‚Üí Chromatin ‚Üí BIPS (Interactive story)</title>

  <style>
    :root{
      --bg: #050507;
      --panel: rgba(0,0,0,0.55);
      --panel2: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);

      --green: rgba(0,255,140,0.95);
      --greenDim: rgba(0,255,140,0.35);
      --red: rgba(255,60,60,0.92);
      --redDim: rgba(255,60,60,0.55);
      --pink: rgba(255,120,200,0.70);
      --purple: rgba(190,120,255,0.92);

      --maxw: 1100px;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }

    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .page{
      min-height: 100vh;
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
    }

    /* TEXT AREA (ABOVE CANVAS) */
    .textPanel{
      width: min(var(--maxw), 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: rgba(0,0,0,0.46);
      backdrop-filter: blur(12px);
      box-shadow: 0 20px 80px rgba(0,0,0,0.55);
      overflow: hidden;
    }

    .textInner{
      padding: 16px 16px 14px 16px;
    }

    .kicker{
      font-weight: 900;
      letter-spacing: 0.3px;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .titleRow{
      display:flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .sceneTitle{
      font-weight: 950;
      letter-spacing: -0.3px;
      font-size: clamp(20px, 2.2vw, 28px);
      margin: 0;
      line-height: 1.1;
    }

    .sceneSub{
      margin-top: 8px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.55;
    }

    .storyText{
      margin-top: 12px;
      color: rgba(255,255,255,0.78);
      font-size: 15px;
      line-height: 1.72;
    }
    .storyText p{ margin: 10px 0 0 0; }

    /* Buttons row */
    .controls{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .leftControls, .rightControls{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .pill{
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.38);
      color: rgba(255,255,255,0.90);
      padding: 9px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 900;
      font-size: 13px;
      backdrop-filter: blur(10px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      user-select:none;
    }
    .pill:hover{ background: rgba(255,255,255,0.10); }
    .pill.strong{ background: rgba(255,255,255,0.12); }
    .pill.ghost{ background: rgba(255,255,255,0.04); }
    .pill:disabled{ opacity: 0.35; cursor: default; }

    .pill.green{
      border-color: rgba(0,255,140,0.30);
      color: var(--green);
    }
    .pill.white{
      border-color: rgba(255,255,255,0.20);
      color: rgba(255,255,255,0.92);
    }
    .pill.purple{
      border-color: rgba(190,120,255,0.35);
      color: var(--purple);
    }

    .pill.toggled{
      background: rgba(255,255,255,0.14);
    }

    /* CANVAS PANEL */
    .stage{
      width: min(var(--maxw), 100%);
      height: min(62vh, 720px);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      overflow: hidden;
      background: rgba(0,0,0,0.25);
      position: relative;
    }

    #stageCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    .legend{
      position:absolute;
      left: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(0,0,0,0.32);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.70);
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;

      opacity: 0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .legend.show{ opacity: 1; transform: translateY(0); }

    .dot{
      display:inline-block;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .dot.white{ background: rgba(255,255,255,0.85); }
    .dot.green{ background: var(--green); }
    .dot.red{ background: var(--red); }
    .dot.pink{ background: var(--pink); }
    .dot.purple{ background: var(--purple); }

    @media (max-width: 860px){
      .stage{ height: 52vh; }
      .controls{ justify-content: flex-start; }
    }
  </style>
</head>

<body>
  <div class="page">

    <!-- TEXT ABOVE CANVAS -->
    <section class="textPanel" aria-label="Story text">
      <div class="textInner">
        <div class="kicker" id="kicker">Interactive story (8 acts)</div>

        <div class="titleRow">
          <h1 class="sceneTitle" id="sceneTitle">Loading‚Ä¶</h1>
        </div>

        <div class="sceneSub" id="sceneSub"></div>
        <div class="storyText" id="storyText"></div>

        <div class="controls">
          <div class="leftControls" id="leftControls">
            <!-- Act-specific concept buttons appear here -->
            <button class="pill white" id="btnBasePair" type="button" style="display:none;">Base pairs</button>
            <button class="pill green" id="btnGene" type="button" style="display:none;">Gene</button>
            <button class="pill purple" id="btnEpi" type="button" style="display:none;">Epigenetics</button>
          </div>

          <div class="rightControls">
            <button class="pill ghost" id="prevBtn" type="button">‚Üê Prev</button>
            <button class="pill ghost" id="resetBtn" type="button" title="Reset this act" style="display:none;">‚Üª Reset</button>
            <button class="pill strong" id="nextBtn" type="button">Next ‚Üí</button>
          </div>
        </div>
      </div>
    </section>

    <!-- CANVAS -->
    <section class="stage" aria-label="Animation canvas">
      <canvas id="stageCanvas"></canvas>

      <div class="legend" id="legend">
        <span class="dot white"></span> chromatin (DNA packed as a chain)
        <span class="dot green"></span> gene region
        <span class="dot red"></span> TF (reader)
        <span class="dot pink"></span> dense hub
        <span class="dot purple"></span> locked DNA
      </div>
    </section>
  </div>

  <script>
    // ============================
    // Assets (your files)
    // Put these in: ../assets/who_am_I_cell.png and ../assets/bips.png
    // ============================
    const ASSET_BASE = "../assets/";
    const IMG_WHO = ASSET_BASE + "who_am_I_cell.png";
    const IMG_BIPS = ASSET_BASE + "bips.png";

    // ============================
    // Canvas setup
    // ============================
    const canvas = document.getElementById("stageCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      return { w: canvas.width, h: canvas.height, dpr };
    }
    window.addEventListener("resize", () => {
      resizeCanvas();
      initActWorld(true);
    });

    // ============================
    // UI
    // ============================
    const sceneTitle = document.getElementById("sceneTitle");
    const sceneSub   = document.getElementById("sceneSub");
    const storyText  = document.getElementById("storyText");
    const kicker     = document.getElementById("kicker");

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const legend = document.getElementById("legend");

    const btnBasePair = document.getElementById("btnBasePair");
    const btnGene = document.getElementById("btnGene");
    const btnEpi = document.getElementById("btnEpi");

    // ============================
    // Helpers
    // ============================
    function randn() {
      let u=0, v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    function drawBackground(){
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(255,255,255,0.035)";
      for (let i=0;i<140;i++){
        const x=(i*97)%canvas.width;
        const y=(i*181)%canvas.height;
        ctx.fillRect(x,y,2,2);
      }
    }

    function glowCircle(x,y,r,color,blur=18){
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function fitImageCover(img){
      const W = canvas.width, H = canvas.height;
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      if (!iw || !ih) return;

      const scale = Math.max(W/iw, H/ih);
      const w = iw*scale;
      const h = ih*scale;
      const x = (W - w)/2;
      const y = (H - h)/2;
      ctx.drawImage(img, x, y, w, h);
    }

    // ============================
    // Images preload
    // ============================
    const whoImg = new Image();
    const bipsImg = new Image();
    let whoReady = false, bipsReady = false;

    whoImg.onload = () => { whoReady = true; };
    bipsImg.onload = () => { bipsReady = true; };
    whoImg.src = IMG_WHO;
    bipsImg.src = IMG_BIPS;

    // ============================
    // Highlight toggles (for DNA acts)
    // ============================
    let highlight = null; // "basepair" | "gene" | "epi" | null

    function setToggle(btn, on){
      btn.classList.toggle("toggled", !!on);
    }

    btnBasePair.addEventListener("click", () => {
      highlight = (highlight === "basepair") ? null : "basepair";
      setToggle(btnBasePair, highlight === "basepair");
      setToggle(btnGene, highlight === "gene");
      setToggle(btnEpi, highlight === "epi");
    });

    btnGene.addEventListener("click", () => {
      highlight = (highlight === "gene") ? null : "gene";
      setToggle(btnBasePair, highlight === "basepair");
      setToggle(btnGene, highlight === "gene");
      setToggle(btnEpi, highlight === "epi");
    });

    btnEpi.addEventListener("click", () => {
      highlight = (highlight === "epi") ? null : "epi";
      setToggle(btnBasePair, highlight === "basepair");
      setToggle(btnGene, highlight === "gene");
      setToggle(btnEpi, highlight === "epi");
    });

    // ============================
    // Acts (story + modes)
    // Modes:
    //   act1_img, dna, epi, act4, act5, act6, act7, act8_img
    // ============================
    let actIndex = 0;
    let mode = "act1_img";

    const ACTS = [
      {
        mode: "act1_img",
        title: "How do cells know who they are?",
        sub: "Most cells carry the same DNA ‚Äî but they don‚Äôt behave the same. Why?",
        html: `
          <p>
            A skin cell, a neuron, and a blood cell usually contain the <strong>same DNA</strong>. Yet they do totally different jobs.
          </p>
          <p>
            The big idea is: <strong>cell identity</strong> is mostly about <em>which parts of DNA get read</em> and which parts stay quiet.
            If different ‚Äúchapters‚Äù get used, you get different cell types.
          </p>
          <p>
            In this story we‚Äôll build one more layer onto that idea:
            DNA isn‚Äôt just a code ‚Äî it‚Äôs also a <strong>3D object</strong> that folds and moves. That folding can change what gets read.
          </p>
        `,
        showLegend: false,
        buttons: { basepair:false, gene:false, epi:false },
      },
      {
        mode: "dna",
        title: "What is DNA?",
        sub: "DNA is information written in a simple alphabet ‚Äî and arranged in a famous shape.",
        html: `
          <p>
            DNA is a long molecule that stores biological information using just four ‚Äúletters‚Äù:
            <strong>A</strong>, <strong>C</strong>, <strong>G</strong>, and <strong>T</strong>.
            (Books use 26 letters ‚Äî life gets a lot done with 4.)
          </p>
          <p>
            DNA is shaped like a twisted ladder called the <strong>double helix</strong>.
            Each rung is a matched pair of letters: A pairs with T, and C pairs with G.
            Those rungs are called <strong>base pairs</strong>.
          </p>
          <p>
            Click the buttons below to highlight what a <strong>base pair</strong> looks like on the helix.
          </p>
        `,
        showLegend: false,
        buttons: { basepair:true, gene:false, epi:false },
      },
      {
        mode: "dna",
        title: "What is a gene?",
        sub: "If base pairs are letters, genes are meaningful ‚Äúsentences‚Äù the cell can read.",
        html: `
          <p>
            If <strong>base pairs</strong> are the letters, a <strong>gene</strong> is like a sentence (or recipe) inside the DNA book.
          </p>
          <p>
            When a cell ‚Äúreads‚Äù a gene, it makes an RNA copy and often uses that to build proteins ‚Äî the molecules that do work in the cell.
          </p>
          <p>
            Different cell types read different genes. That‚Äôs a huge part of how cells keep their identities.
            Click the <strong>Gene</strong> button to highlight one gene-sized region on the helix.
          </p>
        `,
        showLegend: false,
        buttons: { basepair:false, gene:true, epi:false },
      },
      {
        mode: "epi",
        title: "Epigenetics: locking some regions",
        sub: "Cells can keep the ‚Äòwrong‚Äô chapters harder to access ‚Äî to stay the same kind of cell.",
        html: `
          <p>
            Cells use <strong>epigenetics</strong> to help keep some DNA regions ‚Äúclosed‚Äù and others more ‚Äúopen‚Äù.
            You can think of it like placing locks and sticky notes in the DNA book: some chapters become hard to open.
          </p>
          <p>
            In the animation, locked regions glow in <span style="color: rgba(190,120,255,0.95); font-weight:900;">purple</span>.
            Click the <strong>Epigenetics</strong> button to highlight those locked sections.
          </p>
          <p>
            Epigenetics is one way identity stays stable. But there‚Äôs another ingredient:
            DNA also has <strong>physics</strong> ‚Äî it folds in 3D.
          </p>
        `,
        showLegend: false,
        buttons: { basepair:false, gene:false, epi:true },
      },
      {
        mode: "act4",
        title: "DNA is not a straight line ‚Äî it folds in 3D",
        sub: "When you zoom out, DNA becomes chromatin: a flexible chain packed inside the nucleus.",
        html: `
          <p>
            DNA is extremely long (about <strong>2 metres</strong> per cell if stretched out), but the nucleus is tiny.
            So DNA wraps around proteins and folds into <strong>chromatin</strong>.
          </p>
          <p>
            Physicists often model chromatin as a flexible chain (a <strong>polymer</strong>) made of connected beads.
            In this cartoon, <strong>each bead stands for ~millions of base pairs</strong>.
          </p>
          <p>
            <strong>Try it:</strong> drag the chain and fold it over itself. Let go and it will keep wiggling.
          </p>
        `,
        showLegend: true,
        buttons: { basepair:false, gene:false, epi:false },
      },
      {
        mode: "act5",
        title: "The book readers: transcription factors (TFs)",
        sub: "TFs drift around randomly. Before ‚Äústicking‚Äù, they have to find the right place.",
        html: `
          <p>
            The molecules that help ‚Äúread‚Äù genes include proteins called <strong>transcription factors</strong> (TFs).
            They move around the nucleus, bumping and drifting ‚Äî a bit like dust in the air.
          </p>
          <p>
            In this act, TFs (red) mostly wander. The chromatin chain is present, but nothing is pulling it together yet.
          </p>
        `,
        showLegend: true,
        buttons: { basepair:false, gene:false, epi:false },
      },
      {
        mode: "act6",
        title: "Sticky hubs: multivalent binding increases local density",
        sub: "A multivalent TF can bind in multiple places ‚Äî making it act like a hub that pulls chromatin in.",
        html: `
          <p>
            Some TFs are <strong>multivalent</strong>: they can bind at more than one point.
            That makes them act like a sticky hub that can pull in nearby chromatin.
          </p>
          <p>
            <strong>Drag the big red TF</strong>. The chromatin will slowly wrap around it, making a dense region.
          </p>
        `,
        showLegend: true,
        buttons: { basepair:false, gene:false, epi:false },
      },
      {
        mode: "act7",
        title: "Recruitment to a dense region",
        sub: "Once a dense region exists, more TFs are more likely to arrive there ‚Äî leaving other regions quieter.",
        html: `
          <p>
            If chromatin is denser in one region, TFs bump into that region more often ‚Äî so they tend to accumulate there.
            That can create a ‚Äúrich get richer‚Äù effect: <strong>density attracts readers</strong>.
          </p>
          <p>
            Here the chromatin is <strong>already wrapped</strong> around the main TF (a high-density hub),
            and additional TFs drift <strong>slowly</strong> toward it.
          </p>
        `,
        showLegend: true,
        buttons: { basepair:false, gene:false, epi:false },
      },
      {
        mode: "act8_img",
        title: "Transcription factories",
        sub: "A summary picture: active hubs (‚Äòfactories‚Äô) and quieter regions.",
        html: `
          <p>
            Dense hubs where many TFs gather are often called <strong>transcription factories</strong>.
            If most readers are pulled into a few hubs, other regions can be left relatively quiet.
          </p>
          <p>
            That means 3D structure isn‚Äôt just ‚Äúpacking‚Äù ‚Äî it can help bias which genes get read, and help stabilise a cell‚Äôs identity.
          </p>
        `,
        showLegend: false,
        buttons: { basepair:false, gene:false, epi:false },
      }
    ];

    // ============================
    // Navigation
    // ============================
    function applyAct(i){
      actIndex = clamp(i, 0, ACTS.length - 1);
      const A = ACTS[actIndex];
      mode = A.mode;

      // reset highlight when changing acts
      highlight = null;
      setToggle(btnBasePair, false);
      setToggle(btnGene, false);
      setToggle(btnEpi, false);

      // header text
      kicker.textContent = `Act ${actIndex + 1} of ${ACTS.length}`;
      sceneTitle.textContent = A.title;
      sceneSub.textContent = A.sub;
      storyText.innerHTML = A.html;

      // show/hide navigation buttons
      prevBtn.disabled = (actIndex === 0);
      nextBtn.disabled = (actIndex === ACTS.length - 1);

      // reset button from Act 4 onwards
      resetBtn.style.display = (actIndex >= 4) ? "inline-flex" : "none";

      // legend
      if (A.showLegend) legend.classList.add("show");
      else legend.classList.remove("show");

      // concept buttons
      btnBasePair.style.display = A.buttons.basepair ? "inline-flex" : "none";
      btnGene.style.display = A.buttons.gene ? "inline-flex" : "none";
      btnEpi.style.display = A.buttons.epi ? "inline-flex" : "none";

      // reset act state
      initActWorld(true);
    }

    prevBtn.addEventListener("click", () => applyAct(actIndex - 1));
    nextBtn.addEventListener("click", () => applyAct(actIndex + 1));
    resetBtn.addEventListener("click", () => initActWorld(true));

    // ============================
    // DNA helix rendering (Act 2‚Äì4)
    // No on-canvas arrow labels anymore (buttons control highlight)
    // ============================
    function roundRect(x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawDNAHelix(){
      const W = canvas.width, H = canvas.height;
      const cx = W * 0.52;
      const cy = H * 0.56;
      const amp = H * 0.14;
      const pitch = W * 0.022;
      const turns = 44;
      const tNow = performance.now() * 0.0016;

      const baseHi = (highlight === "basepair");
      const geneHi = (highlight === "gene");
      const epiHi  = (highlight === "epi");

      const geneStart = 15;
      const geneEnd   = 24;

      const lockSegments = [
        { a: 7,  b: 12 },
        { a: 28, b: 33 }
      ];

      function isLocked(i){
        for (const seg of lockSegments){
          if (i >= seg.a && i <= seg.b) return true;
        }
        return false;
      }

      // Epigenetic purple ‚Äúcurtains‚Äù behind locked segments
      if (mode === "epi") {
        ctx.save();
        ctx.globalAlpha = epiHi ? 0.30 : 0.20;
        ctx.fillStyle = "rgba(170, 90, 255, 1)";
        const x0 = cx - (turns*pitch)/2;
        for (const seg of lockSegments){
          const xa = x0 + seg.a*pitch - pitch*0.7;
          const xb = x0 + seg.b*pitch + pitch*0.7;
          roundRect(xa, cy - amp*1.38, (xb-xa), amp*2.76, 18, true, false);
        }
        ctx.restore();
      }

      for (let i=0;i<turns;i++){
        const t = i*0.55 + tNow;
        const x = cx - (turns*pitch)/2 + i*pitch;
        const y1 = cy + amp*Math.sin(t);
        const y2 = cy + amp*Math.sin(t + Math.PI);

        const inGene = (i>=geneStart && i<=geneEnd);
        const locked = isLocked(i);

        // rung styling
        let rungColor = "rgba(255,255,255,0.20)";
        let rungWidth = 2.0;

        // base-pair highlight: every 4th rung, brighter
        if (baseHi && (i%4===0)) { rungColor = "rgba(255,255,255,0.92)"; rungWidth = 3.0; }

        // gene highlight: a contiguous region
        if (geneHi && inGene) { rungColor = "rgba(0,255,140,0.92)"; rungWidth = 3.2; }

        // epigenetics highlight
        if (mode === "epi" && locked) {
          rungColor = epiHi ? "rgba(240, 220, 255, 0.98)" : "rgba(230, 200, 255, 0.62)";
          rungWidth = epiHi ? 3.2 : 2.3;
        }

        ctx.save();
        ctx.strokeStyle = rungColor;
        ctx.lineWidth = rungWidth;
        ctx.beginPath();
        ctx.moveTo(x,y1);
        ctx.lineTo(x,y2);
        ctx.stroke();
        ctx.restore();

        // backbones
        let backboneColor = "rgba(255,255,255,0.55)";
        if (geneHi && inGene) backboneColor = "rgba(0,255,140,0.65)";
        if (mode === "epi" && locked) backboneColor = epiHi ? "rgba(190, 120, 255, 0.85)" : "rgba(190, 120, 255, 0.55)";

        glowCircle(x, y1, 5.0, backboneColor, 18);
        glowCircle(x, y2, 5.0, backboneColor, 18);

        // little locks for epigenetics
        if (mode === "epi" && locked && (i % 3 === 0)) {
          ctx.save();
          ctx.font = "900 14px system-ui";
          ctx.fillStyle = epiHi ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.75)";
          ctx.shadowColor = "rgba(190,120,255,0.60)";
          ctx.shadowBlur = 16;
          ctx.fillText("üîí", x - 7, (0.5*(y1+y2)) + 5);
          ctx.restore();
        }
      }

      // simple caption
      ctx.save();
      ctx.font = "900 14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      const label =
        (mode === "epi")
          ? "DNA double helix ‚Ä¢ purple = harder-to-access regions"
          : "DNA double helix ‚Ä¢ click buttons to highlight features";
      ctx.fillText(label, 16, 22);
      ctx.restore();
    }

    // ============================
    // Act 4‚Äì7 worlds
    // ============================
    const world = {
      initialised: false,

      // polymer beads
      beads: [],
      bvx: [],
      bvy: [],

      // Act 4 interaction
      drag: { active:false, i:-1, offx:0, offy:0 },

      // TFs (small)
      tfs: [],

      // Big TF hub (Act 6/7)
      hub: { x:0, y:0, vx:0, vy:0, r:34, dragging:false, offx:0, offy:0 },

      // Act 7 big recruiters
      bigTFs: [],

      frame: 0
    };

    // Tunables (chosen to match your ‚Äúnear perfect‚Äù feel)
    const P = {
      // polymer
      beadCount: 220,
      restLen: 9,
      kSpring: 0.16,
      kBend: 0.010,
      damping: 0.92,
      brownian_act4: 0.22,   // more lively in Act 4
      brownian_act5: 0.10,   // calmer in Act 5 (no collapsing)
      brownian_act7: 0.10,
      beadR: 4.6,

      // excluded volume (prevents total collapse)
      repelK: 0.55,
      repelWindow: 14,

      // TFs (Act 5)
      tfCount: 34,
      tfR: 6.5,
      tfBrown: 0.55,
      tfDamp: 0.93,

      // Act 6 wrap speed
      wrapPull: 0.0032,
      wrapPullNear: 0.0072,

      // Act 7 recruitment speed (slower)
      recruitSpeed: 0.0028
    };

    function initPolymerLongChain(W, H){
      world.beads = [];
      world.bvx = new Array(P.beadCount).fill(0);
      world.bvy = new Array(P.beadCount).fill(0);

      const startX = W * 0.06;
      const midY = H * 0.58;

      for (let i=0;i<P.beadCount;i++){
        const x = startX + i*P.restLen;
        const y = midY + (H*0.05)*Math.sin(i*0.18);
        world.beads.push({x,y});
      }
    }

    function initActWorld(force=false){
      if (!force && world.initialised) return;

      resizeCanvas();
      const W = canvas.width, H = canvas.height;

      world.initialised = true;
      world.frame = 0;

      // reset drag states
      world.drag = { active:false, i:-1, offx:0, offy:0 };
      world.hub.dragging = false;
      world.hub.offx = 0;
      world.hub.offy = 0;

      // Act-specific init
      if (mode === "act4" || mode === "act5") {
        initPolymerLongChain(W, H);
      }

      if (mode === "act6") {
        // Zoomed-in vibe: shorter polymer around a big hub
        P.beadCount = 170; // a bit shorter for this act
        initPolymerLongChain(W, H);

        // place hub
        world.hub.x = W*0.55;
        world.hub.y = H*0.54;
        world.hub.vx = 0;
        world.hub.vy = 0;
        world.hub.r = 36;

        // No small TFs in Act 6 (focus on the hub)
        world.tfs = [];
        world.bigTFs = [];
      }

      if (mode === "act7") {
        // restore longer chain
        P.beadCount = 220;
        initPolymerLongChain(W, H);

        // hub in middle-ish with pre-wrapped polymer effect
        world.hub.x = W*0.56;
        world.hub.y = H*0.54;
        world.hub.vx = 0;
        world.hub.vy = 0;
        world.hub.r = 38;

        // pre-wrap: nudge beads near hub toward it (one-time) so it looks already dense
        for (let i=0;i<world.beads.length;i++){
          const p = world.beads[i];
          const dx = world.hub.x - p.x, dy = world.hub.y - p.y;
          const d = Math.sqrt(dx*dx+dy*dy);
          if (d < 220) {
            const t = (1 - d/220);
            p.x += 18 * t * dx/(d+1e-6);
            p.y += 18 * t * dy/(d+1e-6);
          }
        }

        // ‚Äúrecruiting‚Äù big TFs that drift slowly to hub
        world.bigTFs = [];
        const nBig = 6;
        for (let k=0;k<nBig;k++){
          world.bigTFs.push({
            x: W*(0.12 + 0.76*Math.random()),
            y: H*(0.18 + 0.64*Math.random()),
            vx: 0,
            vy: 0,
            r: 20
          });
        }

        world.tfs = []; // keep act7 clean: big recruiters only
      }

      if (mode === "act5") {
        // polymer + wandering TFs (no attraction)
        world.tfs = [];
        for (let i=0;i<P.tfCount;i++){
          world.tfs.push({
            x: W*(0.20 + 0.60*Math.random()),
            y: H*(0.18 + 0.64*Math.random()),
            vx: 0, vy: 0
          });
        }
        world.bigTFs = [];
      }
    }

    // ----------------------------
    // Interactions
    // ----------------------------
    function mouseToCanvas(e){
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left);
      const sy = (e.clientY - rect.top);
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: sx * scaleX, y: sy * scaleY };
    }

    canvas.addEventListener("mousedown", (e) => {
      const p = mouseToCanvas(e);

      if (mode === "act4") {
        // pick nearest bead
        let best = {i:-1, d2: Infinity};
        for (let i=0;i<world.beads.length;i++){
          const b = world.beads[i];
          const dx = p.x - b.x, dy = p.y - b.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < best.d2) best = {i, d2};
        }
        if (best.i >= 0 && best.d2 < (28*28)) {
          const b = world.beads[best.i];
          world.drag.active = true;
          world.drag.i = best.i;
          world.drag.offx = b.x - p.x;
          world.drag.offy = b.y - p.y;
        }
      }

      if (mode === "act6") {
        const dx = p.x - world.hub.x, dy = p.y - world.hub.y;
        if (dx*dx + dy*dy < (world.hub.r*1.8)*(world.hub.r*1.8)) {
          world.hub.dragging = true;
          world.hub.offx = world.hub.x - p.x;
          world.hub.offy = world.hub.y - p.y;
        }
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const p = mouseToCanvas(e);

      if (mode === "act4" && world.drag.active) {
        const i = world.drag.i;
        const b = world.beads[i];
        const tx = p.x + world.drag.offx;
        const ty = p.y + world.drag.offy;
        // mouse-spring
        world.bvx[i] += 0.25*(tx - b.x);
        world.bvy[i] += 0.25*(ty - b.y);
      }

      if (mode === "act6" && world.hub.dragging) {
        const tx = p.x + world.hub.offx;
        const ty = p.y + world.hub.offy;
        world.hub.vx += 0.20*(tx - world.hub.x);
        world.hub.vy += 0.20*(ty - world.hub.y);
      }
    });

    window.addEventListener("mouseup", () => {
      world.drag.active = false;
      world.drag.i = -1;
      world.hub.dragging = false;
    });

    // ----------------------------
    // Physics helpers
    // ----------------------------
    function springForce(ax, ay, bx, by, rest, k){
      const dx=bx-ax, dy=by-ay;
      const r=Math.sqrt(dx*dx+dy*dy)+1e-6;
      const f=k*(r-rest);
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function bendForce(p0,p1,p2,kB){
      const mx=0.5*(p0.x+p2.x);
      const my=0.5*(p0.y+p2.y);
      return {fx:kB*(mx-p1.x), fy:kB*(my-p1.y)};
    }
    function repelPair(ax, ay, bx, by, minDist, k){
      const dx=bx-ax, dy=by-ay;
      const r2=dx*dx+dy*dy+1e-6;
      const r=Math.sqrt(r2);
      if (r>=minDist) return {fx:0, fy:0};
      const overlap=minDist-r;
      const f=k*overlap;
      return {fx:f*dx/r, fy:f*dy/r};
    }
    function softWalls(x,y,vx,vy){
      const W=canvas.width, H=canvas.height;
      const margin=70;
      const k=0.0018;
      if (x<margin) vx += k*(margin-x);
      if (x>W-margin) vx -= k*(x-(W-margin));
      if (y<margin) vy += k*(margin-y);
      if (y>H-margin) vy -= k*(y-(H-margin));
      return {vx,vy};
    }

    // ----------------------------
    // Polymer step
    // ----------------------------
    function stepPolymer(brown){
      const n = world.beads.length;

      // neighbor springs
      for (let i=0;i<n-1;i++){
        const a=world.beads[i], b=world.beads[i+1];
        const f=springForce(a.x,a.y,b.x,b.y,P.restLen,P.kSpring);
        world.bvx[i] += f.fx; world.bvy[i] += f.fy;
        world.bvx[i+1] -= f.fx; world.bvy[i+1] -= f.fy;
      }

      // bending
      for (let i=1;i<n-1;i++){
        const f=bendForce(world.beads[i-1], world.beads[i], world.beads[i+1], P.kBend);
        world.bvx[i] += f.fx;
        world.bvy[i] += f.fy;
      }

      // excluded volume (local window)
      const minBB = 2*P.beadR;
      for (let i=0;i<n;i++){
        const i0=Math.max(0,i-P.repelWindow);
        const i1=Math.min(n-1,i+P.repelWindow);
        for (let j=i0;j<=i1;j++){
          if (j===i) continue;
          if (Math.abs(i-j)<=1) continue;
          const a=world.beads[i], b=world.beads[j];
          const f=repelPair(a.x,a.y,b.x,b.y,minBB,P.repelK);
          world.bvx[i] -= f.fx; world.bvy[i] -= f.fy;
          world.bvx[j] += f.fx; world.bvy[j] += f.fy;
        }
      }

      // integrate
      for (let i=0;i<n;i++){
        world.bvx[i] += brown*randn();
        world.bvy[i] += brown*randn();
        world.bvx[i] *= P.damping;
        world.bvy[i] *= P.damping;

        world.beads[i].x += world.bvx[i];
        world.beads[i].y += world.bvy[i];

        const out=softWalls(world.beads[i].x, world.beads[i].y, world.bvx[i], world.bvy[i]);
        world.bvx[i]=out.vx; world.bvy[i]=out.vy;
      }
    }

    // ----------------------------
    // Act 6: wrapping around a multivalent TF hub
    // ----------------------------
    function stepAct6(){
      // hub motion
      world.hub.vx *= 0.92;
      world.hub.vy *= 0.92;
      world.hub.x += world.hub.vx;
      world.hub.y += world.hub.vy;

      // soft walls for hub
      const out = softWalls(world.hub.x, world.hub.y, world.hub.vx, world.hub.vy);
      world.hub.vx = out.vx;
      world.hub.vy = out.vy;

      // polymer base motion (gentle)
      stepPolymer(0.10);

      // wrap pull: beads attracted to hub (stronger when near)
      for (let i=0;i<world.beads.length;i++){
        const p = world.beads[i];
        const dx = world.hub.x - p.x;
        const dy = world.hub.y - p.y;
        const d = Math.sqrt(dx*dx+dy*dy) + 1e-6;

        const near = (d < 160);
        const k = near ? P.wrapPullNear : P.wrapPull;

        world.bvx[i] += k * dx;
        world.bvy[i] += k * dy;
      }
    }

    // ----------------------------
    // Act 7: already dense hub + slow recruitment
    // No polymer ‚Äúcollapsing‚Äù ‚Äî just mild wiggle + hub attraction on recruiters
    // ----------------------------
    function stepAct7(){
      stepPolymer(P.brownian_act7);

      // keep polymer gently around hub (small pull to maintain wrapped look)
      for (let i=0;i<world.beads.length;i++){
        const p = world.beads[i];
        const dx = world.hub.x - p.x;
        const dy = world.hub.y - p.y;
        const d = Math.sqrt(dx*dx+dy*dy) + 1e-6;
        if (d < 260) {
          const k = 0.0009 * (1 - d/260);
          world.bvx[i] += k * dx;
          world.bvy[i] += k * dy;
        }
      }

      // big TFs drift slowly toward hub
      for (const tf of world.bigTFs){
        tf.vx *= 0.94;
        tf.vy *= 0.94;

        // little random wandering
        tf.vx += 0.20 * randn();
        tf.vy += 0.20 * randn();

        // attraction to hub (slow)
        tf.vx += P.recruitSpeed * (world.hub.x - tf.x);
        tf.vy += P.recruitSpeed * (world.hub.y - tf.y);

        tf.x += tf.vx;
        tf.y += tf.vy;

        // soft bounds (wrap)
        const W=canvas.width, H=canvas.height;
        if (tf.x<0) tf.x += W;
        if (tf.x>W) tf.x -= W;
        if (tf.y<0) tf.y += H;
        if (tf.y>H) tf.y -= H;
      }
    }

    // ----------------------------
    // Act 5: wandering TFs (no attraction) + stable polymer
    // ----------------------------
    function stepAct5(){
      // polymer: calm, no collapse
      stepPolymer(P.brownian_act5);

      // TFs wander
      for (const tf of world.tfs){
        tf.vx += P.tfBrown*randn();
        tf.vy += P.tfBrown*randn();
        tf.vx *= P.tfDamp;
        tf.vy *= P.tfDamp;
        tf.x += tf.vx;
        tf.y += tf.vy;

        const W=canvas.width, H=canvas.height;
        if (tf.x<0) tf.x += W;
        if (tf.x>W) tf.x -= W;
        if (tf.y<0) tf.y += H;
        if (tf.y>H) tf.y -= H;
      }
    }

    // ============================
    // Drawing: polymer scenes
    // ============================
    function drawPolymer(){
      // polymer line
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      world.beads.forEach((p,i)=>{
        if(i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();

      // beads
      for (let i=0;i<world.beads.length;i++){
        const p = world.beads[i];
        glowCircle(p.x,p.y, 4.8, "rgba(255,255,255,0.55)", 16);
      }
    }

    function drawAct5(){
      drawPolymer();
      // TFs red
      for (const tf of world.tfs){
        glowCircle(tf.x, tf.y, P.tfR, "rgba(255,60,60,0.62)", 20);
      }
    }

    function drawAct6(){
      // hub glow (pinkish halo)
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      glowCircle(world.hub.x, world.hub.y, world.hub.r*2.2, "rgba(255,120,200,0.025)", 120);
      glowCircle(world.hub.x, world.hub.y, world.hub.r*1.2, "rgba(255,120,200,0.045)", 70);
      ctx.restore();

      // polymer + beads
      drawPolymer();

      // hub (big TF) in red
      glowCircle(world.hub.x, world.hub.y, world.hub.r, "rgba(255,60,60,0.92)", 44);

      // hint label
      ctx.save();
      ctx.font = "900 14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.fillText("Drag the big TF (red hub)", 16, 22);
      ctx.restore();
    }

    function drawAct7(){
      // dense hub halo (pink)
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      glowCircle(world.hub.x, world.hub.y, world.hub.r*2.6, "rgba(255,120,200,0.025)", 140);
      glowCircle(world.hub.x, world.hub.y, world.hub.r*1.4, "rgba(255,120,200,0.055)", 90);
      ctx.restore();

      // polymer + beads
      drawPolymer();

      // central hub TF
      glowCircle(world.hub.x, world.hub.y, world.hub.r, "rgba(255,60,60,0.92)", 46);

      // recruiting big TFs (slower)
      for (const tf of world.bigTFs){
        glowCircle(tf.x, tf.y, tf.r, "rgba(255,60,60,0.70)", 28);
      }
    }

    // ============================
    // Act 4: interactive polymer (more folding, but not ‚Äútotal collapse‚Äù)
    // ============================
    function stepAct4(){
      // more lively wiggle than Act5
      stepPolymer(P.brownian_act4);

      // very gentle ‚Äúfold encouragement‚Äù (makes it fold a couple times, not implode)
      // we apply a weak long-range attraction to a few anchor points, then turn it off naturally by using small strength.
      const W = canvas.width, H = canvas.height;
      const anchors = [
        {x: W*0.34, y: H*0.52},
        {x: W*0.56, y: H*0.62}
      ];
      for (let i=0;i<world.beads.length;i++){
        const p = world.beads[i];
        // alternate beads feel tiny pull to one of the anchors
        const a = anchors[(i%2)];
        const dx = a.x - p.x;
        const dy = a.y - p.y;
        const d = Math.sqrt(dx*dx+dy*dy)+1e-6;
        // weak pull only within moderate distance so it folds "a bit"
        if (d < 520){
          const k = 0.00055 * (1 - d/520);
          world.bvx[i] += k * dx;
          world.bvy[i] += k * dy;
        }
      }
    }

    function drawAct4(){
      drawPolymer();
      ctx.save();
      ctx.font = "900 14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.fillText("Act 4 is interactive: click & drag the chain", 16, 22);
      ctx.restore();
    }

    // ============================
    // Main loop
    // ============================
    function tick(){
      resizeCanvas();
      drawBackground();

      if (mode === "act1_img") {
        if (whoReady) {
          fitImageCover(whoImg);
        } else {
          // fallback
          ctx.save();
          ctx.font = "900 18px system-ui";
          ctx.fillStyle = "rgba(255,255,255,0.75)";
          ctx.fillText("Loading image‚Ä¶", 16, 28);
          ctx.restore();
        }
      }
      else if (mode === "dna" || mode === "epi") {
        drawDNAHelix();
      }
      else if (mode === "act4") {
        initActWorld(false);
        stepAct4();
        drawAct4();
      }
      else if (mode === "act5") {
        initActWorld(false);
        stepAct5();
        drawAct5();
      }
      else if (mode === "act6") {
        initActWorld(false);
        stepAct6();
        drawAct6();
      }
      else if (mode === "act7") {
        initActWorld(false);
        stepAct7();
        drawAct7();
      }
      else if (mode === "act8_img") {
        // canvas intentionally just shows your summary picture
        if (bipsReady) {
          fitImageCover(bipsImg);
        } else {
          ctx.save();
          ctx.font = "900 18px system-ui";
          ctx.fillStyle = "rgba(255,255,255,0.75)";
          ctx.fillText("Loading image‚Ä¶", 16, 28);
          ctx.restore();
        }
      }

      requestAnimationFrame(tick);
    }

    // ============================
    // Start
    // ============================
    resizeCanvas();
    initActWorld(true);
    applyAct(0);
    tick();
  </script>
</body>
</html>
















